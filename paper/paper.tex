\documentclass{msc}

\usepackage{amsmath, amssymb, mathrsfs, wasysym, tikz, tikz-cd, lmodern, mathpazo, anyfontsize, xargs, environ, multirow, tabularx, caption, bookmark, booktabs, makecell, colortbl, minted, art.cls/colorpal, art.cls/ct, art.cls/sset, art.cls/lim, art.cls/joinargs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[prefix=bonak]{art.cls/xkeymask}

% Use the patterns library to draw the cubes figure
\usetikzlibrary{patterns}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{painting}{D}{(#1)}
\define@cmdkey[bonak]{painting}{E}{(#1)}
\define@cmdkey[bonak]{painting}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrpainting}{D}{(#1)}
\define@cmdkey[bonak]{restrpainting}{E}{(#1)}
\define@cmdkey[bonak]{restrpainting}{d}{(#1)}
\define@cmdkey[bonak]{restrpainting}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohpainting}{D}{(#1)}
\define@cmdkey[bonak]{cohpainting}{E}{(#1)}
\define@cmdkey[bonak]{cohpainting}{d}{(#1)}
\define@cmdkey[bonak]{cohpainting}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \ensuremath{{\color{carolina}{\nu\textsf{Set}}}_{#1}^{#2}}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and painting: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and painting: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4]}^{\joinargs[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

% Coherence conditions for frame, layer, and painting: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaHat}{\ensuremath{\hat{\boldsymbol{\Delta}}}}
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}{\ensuremath{\boldsymbol{{\square}}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommandx{\U}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HSet}}_{#1}}}
\newcommandx{\HGpd}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HGpd}}_{#1}}}
\newcommand{\Type}{\ensuremath{\mathsf{\color{spanish-blue}{Type}}}}
\newcommand{\SProp}{\ensuremath{\mathsf{\color{spanish-blue}{SProp}}}}

% Examples
\newtheorem{example}[therm]{Example}

% The unit and bool types
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\booltype}{\ensuremath{\mathsf{bool}}}
\newcommand{\unitpoint}{\ensuremath{\ast}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\refl}{\ensuremath{\mathsf{refl}}}

% Some abbreviations
\newcommand{\tl}{\ensuremath{\mathsf{tl}}}
\newcommand{\hd}{\ensuremath{\mathsf{hd}}}
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\newcommand{\ap}{\mathsf{ap}\;}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommand{\Dom}{\textsf{Dom}}
\newcommand{\UIP}{\textsf{UIP}}

\newcommand{\udensdash}[1]{%
    \tikz[baseline=(todotted.base)]{
        \node[inner sep=1pt,outer sep=0pt] (todotted) {$#1$};
        \draw[densely dashed] (todotted.south west) -- (todotted.south east);
    }%
}%

% These are renewed in tables, but let's define them now for in-document
% typesetting
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\newcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\newcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\newcommandx{\restrp}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\newcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\newcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\newcommandx{\cohp}{\coh{painting}[][][][][][][][]}
\newcommandx{\fullframe}[1][1]{\prim{fullframe}[][#1][][][]}

\newcommandx{\frametype}[2][1,2]{\prim{frametype}[][#1][#2][][]}
\newcommandx{\layertype}[2][1,2]{\prim{layertype}[][#1][#2][][]}
\newcommandx{\paintingtype}[2][1,2]{\prim{paintingtype}[][#1][#2][][]}
\newcommandx{\restrftype}[2][1,2]{\prim{restrftype}[][#1][#2][][]}
\newcommandx{\restrltype}[2][1,2]{\prim{restrltype}[][#1][#2][][]}
\newcommandx{\restrptype}[2][1,2]{\prim{restrptype}[][#1][#2][][]}
\newcommandx{\cohftype}[2][1,2]{\prim{cohftype}[][#1][#2][][]}
\newcommandx{\cohltype}[2][1,2]{\prim{cohltype}[][#1][#2][][]}
\newcommandx{\cohptype}[2][1,2]{\prim{cohptype}[][#1][#2][][]}
\newcommandx{\cohttype}[2][1,2]{\prim{cohttype}[][#1][#2][][]}

\newcommandx{\deps}[2][1,2]{\prim{deps}[][#1][#2][][]}
\newcommandx{\fulldeps}[2][1,2]{\prim{fulldeps}[][#1][][][]}
\newcommandx{\depscohs}[2][1,2]{\prim{depscohs}[][#1][#2][][]}
\newcommandx{\fulldepscohs}[2][1,2]{\prim{fulldepscohs}[][#1][][][]}
\newcommandx{\depscoht}[2][1,2]{\prim{depscoht}[][#1][#2][][]}
\newcommandx{\fulldepscoht}[2][1,2]{\prim{fulldepscoht}[][#1][][][]}
\newcommandx{\depstype}[2][1,2]{\prim{depstype}[][#1][#2][][]}
\newcommandx{\fulldepstype}[2][1,2]{\prim{fulldepstype}[][#1][][][]}
\newcommandx{\depscohstype}[2][1,2]{\prim{depscohstype}[][#1][#2][][]}
\newcommandx{\fulldepscohstype}[2][1,2]{\prim{fulldepscohstype}[][#1][][][]}
\newcommandx{\depscohttype}[2][1,2]{\prim{depscohttype}[][#1][#2][][]}
\newcommandx{\fulldepscohttype}[2][1,2]{\prim{fulldepscohttype}[][#1][][][]}

\newcommandx{\coht}[6][1,2,3,4,5,6]{\cohtwo{frame}[][#3][#4][#5][#6][#1,#2][][]}

% For typesetting type theory rules
\newcommand \seqr[3]
  {\shortstack{$#2$ \\ \mbox{}\\
                   \mbox{}\hrulefill\mbox{}\\ \mbox{}\\ $#3$} \raisebox{2ex}{$\;\;\mbox{$#1$}$}}

% Kerning for star
\newcommand{\kstar}{{\star}}

% Caption setup
\DeclareCaptionFormat{plain}{#1#3}
\captionsetup{font=footnotesize,labelfont=bf}

% The eqntable environment
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{eqntable}[1]{
  \fontsize{7.2}{9}\selectfont
  \begin{tabularx}{0.94\linewidth}{
    @{}
    >{$}l<{$}
    >{$}c<{$}
    >{$}c<{$}
    >{$}Y<{$}
    @{}}
    \toprule
    \BODY
    \bottomrule
  \end{tabularx}
  \captionof{table}{#1}
}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

% Double-spacing
% \linespread{2}

\begin{document}
\title{On the specific recursive structure of iterated parametricity}
\begin{authgrp}
  \author{Hugo Herbelin}
  \affiliation{Université Paris Cité, Inria, CNRS, IRIF, Paris
    \email{Hugo.Herbelin@inria.fr}}
  \author{Ramkumar Ramachandra}
  \affiliation{Unaffiliated \email{r@artagnon.com}}
\end{authgrp}
\begin{abstract}
  In a previous paper, we gave equations describing the construction of semi-simplicial and semi-cubical sets via iterated parametricity. The construction was formalised in the Rocq (formerly, Coq) proof assistant building $n$-truncated sets using an induction on a large structure embedding equational reasoning.

  The current paper describes a new and lighter presentation of the construction where equational reasoning is replaced by definition. Being lighter, it can now be described in full details, closely following the corresponding new machine-checked formalisation.
\end{abstract}
\maketitle
\vspace{-2em} % Remove space after abstract

\section{Introduction}
In the previous paper~\citep{hr25}, we described the construction of augmented semi-simplicial and semi-cubical sets in \emph{indexed form} as a special case of iterated parametricity, meaning that instead of the following illustration of the cubical case (upto faces identities),

\begin{equation*}
  \begin{tikzcd}
    X_0: \U & X_1: \U \arrow[l, "\partial^L" description, shift left=2] \arrow[l, "\partial^R" description, shift right=2] & X_2: \U \arrow[l, "\partial^{L\kstar}" description, shift left=6] \arrow[l, "\partial^{R\kstar}" description, shift left=2] \arrow[l, "\partial^{\kstar L}" description, shift right=2] \arrow[l, "\partial^{\kstar R}" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}
we consider a family of families as shown below:
\begin{equation*}
  \begin{array}{lll}
    X_0 & :               \U                                                                          \\
    X_1 & :               X_0 \times X_0 \rightarrow  \U                                              \\
    X_2 & : \Pi a b c d.\,  X_1(a,b) \times X_1 (c,d) \times X_1(a,c) \times X_1 (b,d) \rightarrow \U \\
    \ldots
  \end{array}
\end{equation*}

% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{painting}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrpainting}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohpainting}[D, d]

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and painting
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and painting
% Drop the universe letter
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrp}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
% Keep only ε, ω; n, p; proposition on n and p
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\renewcommandx{\cohp}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][][][][][#9]}

A $\nu$-set in indexed form is a sequence of families of $\U$, that is $\U[m]$ for some universe level $m$. We call such sequence a $\nu$-set at level $m$, whose type thus lives in $\U[m+1]$.

Table~\ref{tab:coind} describes the type of a $\nu$-set at level $m$ as a dependent stream of type families representing the limit of $n$-truncated $\nu$-sets: the recursive equation $\Xfrom{m}{n}{D} \,\defeq\, \Sigma R: \Xcomp{m}{n}[D=\D].\, \Xfrom{m}{n+1}[D=\pair{D}{R}]$ from the table formally corresponds to the stream $Stream_{\Sigma n.\, \Xto{m}{n},\, \lambda (n, \D).\, \Xcomp{m}{n}[D=\D],\,\lambda ((n, D),R).(n+1,(\pair{D}{R}))}(n, \D)$. Therefore, $\Xfrom{m}{n}$ denotes an infinite sequence $X_{n}, X_{n+1}, \ldots$ dependent on a $(<n)$-truncated $\nu$-set, $\Xto{m}{n}$, so that, when $n$ is $0$, it denotes a full $\nu$-set, written $\Xp{m}$. This is made possible because the $(<0)$-truncated $\nu$-set, $\Xto{m}{0}$, is degenerated: it is an empty family, and there is thus only one $(<0)$-truncated $\nu$-set, namely the canonical inhabitant $\kstar$ of $\unittype$.

The definition of the type of a $n$-truncated $\nu$-set is in turn described in table~\ref{tab:core}. In the infinite sequence of type families representing a $\nu$-set, the $n$-th component is a type dependent over a $\fullframe$. It is recursively defined in table~\ref{tab:frames}, using the auxiliary definitions of $\framep$, $\layer$ and $\painting$. A $\fullframe$ describes a boundary of a standard form (simplex, cube), which we decompose into $\layer$, and a $\painting$ corresponds to a filled frame. Notice that the type $\layer$ relies on an operator of frame restriction $\restrf$ which is defined in table~\ref{tab:faces}, and this restriction operator is in turn defined using auxiliary definitions $\restrl$ and $\restrp$.

Notably, the definition of $\restrl$ relies on an equality expressing the commutation of the composition of two $\restrf$. The proof of this commutation is worth being made explicit, which we do in table~\ref{tab:coh} using proof-term notations. The proof requires an induction on the dimension and on the structure of $\framep$, $\layer$, and $\painting$. This is what $\cohf$ does using auxiliary proofs $\cohl$ and $\cohp$. Even though it looks independent of the definitions from the other tables, $\cohf$ has to be proved mutually with the definitions of $\framep$, $\layer$, $\painting$, and their corresponding restrictions. More precisely, for a fixed $n$, the block of $\framep$, $\restrf$, and $\cohf$ has to be defined in one go by induction on $p$. Also, each of $\painting$, $\restrp$, and $\cohp$ is built by induction from $p$ to $n$. The $\painting$ block at $n$ relies on the $\framep$ block at $n$, but the converse dependency is only on lower $n$, so this is well-founded. Note that $\layer$, $\restrl$ and $\cohl$ are just abbreviations.

Note that for a fixed constant $n$, relying on the evaluation rules of type theory, the coherence conditions degenerate to a reflexivity proof, so that the construction builds an effective sequence of types not mentioning coherences anymore. \\

\def\lab{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

\def\lab{tab:core}
\input{tab-core.tex}

\def\lab{tab:frames}
\input{tab-frames.tex}

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\def\lab{tab:faces}
\input{tab-faces-ett.tex}

% Restriction for frame, layer, and painting
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrp}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohp}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][#4][#5][#6,#7][#8][#9]}

\def\lab{tab:coh}
\input{tab-coh-ett.tex}

\renewcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\renewcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\renewcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\renewcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrp}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\renewcommandx{\cohf}[6][1,2,3,4,5,6]{\coh{frame}[][#3][#4][#5][#6][#1,#2][][]}
\renewcommandx{\cohl}[6][1,2,3,4,5,6]{\coh{layer}[][#3][#4][#5][#6][#1,#2][][]}
\renewcommandx{\cohp}[6][1,2,3,4,5,6]{\coh{painting}[][#3][#4][#5][#6][#1,#2][][]}

In \citep{hr25}, the well-foundedness was justified by induction on $n$ and subinductions, one on $p$ to mutually build $\framep[n][p]$, $\restrf[n][p]$ and $\cohf[n][p]$, and three others to build each of $\painting[n][p]$, $\restrp[n][p]$ and $\cohp[n][p]$ by induction on $n-p$.

Since $\restrf[n][p]$ is referring to $\framep[n][p]$ and $\framep[n-1][p]$, and $\cohf[n][p]$ is referring to $\restrf[n][p]$ and $\restrf[n-1][p]$, thus also to $\framep[n][p]$, $\framep[n-1][p]$ and $\framep[n-2][p]$, we built all of these 6 components at the same time. But equations were also needed to state the properties of $\framep[n][p]$, $\framep[n-1][p]$ and $\restrf[n][p]$ so that we were building by induction on $n+p$ (that is on $n$, using the convention of \citep{hr25}) the following block of information:

\begin{align*}
  \framep[n][p]      & : \U                                                                                                                 \\
  \framep[n-1][p]    & :  \U                                                                                                                \\
  \framep[n-2][p]    & : \U                                                                                                                 \\
  \restrf[n][p]      & : \Pi q.\, \Pi \omega.\, \framep[n][p] \rightarrow \framep[n-1][p]                                                   \\
  \restrf[n-1][p]    & : \Pi q.\, \Pi \omega.\, \framep[n-1][p] \rightarrow \framep[n-2][p]                                                 \\                                                                 \\
  \cohf[n][p]        & : \Pi qr\epsilon\omega.\, \restrf[n-1][p][\epsilon][q] \circ \restrf[n][p][\omega][r] =                              \\
                     & \;\;\;\;\restrf[n-1][p][\omega][r] \circ \restrf[n][p][\epsilon][q+1]                                                \\
  \mathsf{hypF0}     & : \framep[n][0]         = \unitpoint
  \\
  \mathsf{hypFS0}    & : \framep[n][p+1]       = \Sigma d: \framep[n+1][p]. \Pi \omega.\, \painting[n][p] (\restrf[n+1][p](d))              \\
  \mathsf{hypPrevF}  & : \framep[n-1][0]                                                                                       = \unitpoint \\
  \mathsf{hypPrevFS} & : \framep[n-1][p+1] = \Sigma d: \framep[n][p]. \Pi \omega.\, \painting[n-1][p] (\restrf[n][p](d))                    \\
  \mathsf{hypRF0}    & : \restrf[n][0]        = \ldots \texttt{depending on hypF0}                                                          \\
  \mathsf{hypRFS}    & : \restrf[n][p+1]      = \ldots \texttt{depending on hypFS and hypPrevFS}                                            \\
  \ldots             & \;\;\;\;\texttt{fields for painting, restrf, cohp}
\end{align*}

In the current paper and associated formalisation, we replace the equational properties by definitions, building instead by induction a block of the form:

\begin{align*}
  \framep[n-2][p] & : \U                                                                                    \\
  \restrf[n-1][p] & : \Pi q \leq n+p.\, \framep[n-1][p] \rightarrow \framep[n-2][p]                         \\
  \cohf[n][p]     & : \Pi qr\epsilon\omega.\, \restrf[n-1][p][\epsilon][q] \circ \restrf[n][p][\omega][r] = \\
                  & \;\;\;\;\restrf[n-1][p][\omega][r] \circ \restrf[n][p][\epsilon][q+1]                   \\
  \ldots          & \;\;\;\;\texttt{fields for painting, restrf, cohp}
\end{align*}
where $\framep[n][p]$, $\framep[n-1][p]$ and $\restrf[n][p]$ are now appropriate definitions.

Turning $\framep[n][p]$, $\framep[n-1][p]$ and $\restrf[n][p]$ into definitions is however tricky: the definition of $\framep[n-1][p]$, which is by induction on $p$ (for all $n$), depends on $\restrf[n-1][p]$ whose type depends on $\framep[n][p-1]$. This means that $\framep[n-1][p]$ and the type of $\restrf[n-1][p]$ have to be mutually defined.

The well-foundedness of the construction can be justified by the observation that:

Defining $\framep[n][p]$ for $p \leq n$ requires the definition of $\painting[n-1][p-1]$, thus also $\framep[n-1][p-1]$ by typing dependency, as well as $\restrf[n][p-1]$, where $\restrf[n][p-1]$ in turn depends in $\framep[n][p-1]$ for its typing.

Moreover, $\framep[n][p]$ depends on $\framep[n][p-1]$, so these dependencies are between the blocks of $\framep[n][k]$ for all $k\leq p$, as well as $\framep[n-1][k]$, $\painting[n-1][k]$ and $\restrf[n][k]$ for all $k\leq p-1$, which we respectively abbreviate as $\framep[n][0,...,p]$, $\framep[n-1][0,...,p-1]$, $\painting[n-1][0,...,p-1]$ and $\restrf[n][0,...,p-1]$.

Also, $\restrf[n][p-1]$ depends on $n$.

Schematically, using dotted arrows for dependencies in the type and plain arrows for dependencies in the definition, this gives the following dependencies for $p\leq n$ fixed:
\begin{center}
  \fontsize{7.2}{9}\selectfont
  \begin{tikzcd}
    \framep[n][0,...,p] \arrow[d] \arrow[ddr]\\
    \painting[n-1][0,...,p-1] \arrow[d, dotted] \\
    \framep[n-1][0,...,p-1] &
    \restrf[n][0,...,p-1] \arrow[l, dotted] \arrow[uul, dotted, "\mbox{$[0,...,p-1]$}"', near start, shift right=2mm, hook']\\
  \end{tikzcd}
\end{center}

In particular, the mutual dependency on one side of $\framep[n][0,...,p-1]$ within the type of $\restrf[n][0,...,p-1]$ and on the other side of $\restrf[n][0,...,p-1]$ within the definition of $\framep[n][0,...,p]$ requires to mutually define the type of $\restrf[n][0,...,p-1]$ together with $\framep[n][p]$ (or $\framep[n][0,...,p]$) as a function from $\restrf[n][0,...,p-1]$.

To talk about sequences of $\framep$, $\painting$ or $\restrf$, we need to specify their types. The type of $\restrf$ will be defined mutually with $\framep$ of the same level, but the type of $\framep$, $\painting$ can be defined in advance, the second one being however dependent on the first one. In general, components of such sequences will have a type dependent on the previous components of the sequence, as it is the case for $\restrf$. So, the type of a sequence of length $p$ will be expressed as a $n$-iterated $\Sigma$-type. In the case of $\framep$ and $\painting$, there will be however no dependency, so an ordinary product can be used. If $\framep[n][0,...,p]$ is such a sequence of length $p+1$, we write $\framep[n][0,...,p-1]$ for its immediate subsequence of length $p$ and $\framep[n][p]$ for its last component. We can now define the types of sequences of $\framep$ and $\painting$ as follows:

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \frametype[n][0,...,p]    &                                              & :      & \U                                                                                           \\
    \frametype[n][]           &                                              & \defeq & \unittype                                                                                    \\
    \frametype[n][0,...,p]    &                                              & \defeq & \frametype[n+1][0,...,p-1] \times \U                                                         \\
    \\
    \paintingtype[n][0,...,p] & (\framep[n][0,...,p]:\frametype[n][0,...,p]) & :      & \U                                                                                           \\
    \paintingtype[n][]        & \unitpoint                                   & \defeq & \unittype                                                                                    \\
    \paintingtype[n][0,...,p] & (\framep[n][0,...,p])                        & \defeq & \paintingtype[n+1][0,...,p-1](\framep[n+1][0,...,p-1]) \times (\framep[n][p] \rightarrow \U) \\
  \end{array}
\end{equation*}

Formally, this can be described as:
\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \framep[n][0,...,p]                                                                    &
    \left(\begin{array}{l}
              \framep[n][0,...,p-1]:\frametype[n][0,...,p-1]                             \\
              \painting[n][0,...,p-1]:\paintingtype[n][0,...,p-1](\framep[n][0,...,p-1]) \\
              \restrf[n][0,...,p-1]:\restrftype[n][0,...,p-1]
              \left(\begin{array}{l}
                  \framep[n][0,...,p-1]   \\
                  \painting[n][0,...,p-1] \\
                \end{array}\right)                                              \\
            \end{array}\right) & :      & \frametype[n][0,...,p]                             \\
    \framep[n][0,]                                                                         &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)                                                                 & \defeq & (\unitpoint,unit) \\
    \framep[n][0,...,p+1]                                                                  &
    \left(\begin{array}{l}
              \framep[n][0,...,p]   \\
              \painting[n][0,...,p] \\
              \restrf[n][0,...,p]   \\
            \end{array}\right)                                                               & \defeq &
    \left(\begin{array}{l}
              \framep[n+1][0,...,p]
              \left(\begin{array}{l}
                  \framep[n+1][0,...,p-1]   \\
                  \painting[n+1][0,...,p-1] \\
                  \restrf[n+1][0,...,p-1]   \\
                \end{array}\right), \\
              \Sigma d:\framep[n+1][0,...,p]
              \left(\begin{array}{l}
                  \framep[n+1][0,...,p-1]   \\
                  \painting[n+1][0,...,p-1] \\
                  \restrf[n+1][0,...,p-1]   \\
                \end{array}\right).\, \\
              \quad \layer[n][p]
              \left(\begin{array}{l}
                  \framep[n+1][0,...,p-1]   \\
                  \painting[n+1][0,...,p-1] \\
                  \restrf[n+1][0,...,p-1]   \\
                \end{array}\right)(d) \\
            \end{array}\right)                                                                      \\
    \restrftype[n][0,...,p-1]                                                              &
    \left(\begin{array}{l}
              \framep[n][0,...,p-1]:\frametype[n][0,...,p-1]                             \\
              \painting[n][0,...,p-1]:\paintingtype[n][0,...,p-1](\framep[n][0,...,p-1]) \\
            \end{array}\right)          & :      & \U                                      \\
    \restrftype[n][0,...,0-1]                                                              &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)                                                                 & \defeq &
    \unittype                                                                                                             \\
    \restrftype[n][0,...,(p+1)-1]                                                          &
    \left(\begin{array}{l}
              \framep[n][0,...,p]   \\
              \painting[n][0,...,p] \\
            \end{array}\right)                                                               & \defeq &
    \begin{array}{l}
      \Sigma \restrf[n+1][0,...,p-1]
      :\restrftype[n+1][0,...,p-1]
      \left(\begin{array}{l}
                \framep[n+1][0,...,p-1]   \\
                \painting[n+1][0,...,p-1] \\
              \end{array}\right).                     \\
      \Pi q\leq n.\,\Pi \omega.\,\framep[n+1][p]
      \left(\begin{array}{l}
                \framep[n+1][0,...,p-1]   \\
                \painting[n+1][0,...,p-1] \\
                \restrf[n+1][0,...,p-1]   \\
              \end{array}\right) \rightarrow  \framep[n][p] \\
    \end{array}                                                    \\
    \layertype[n][p]                                                                       &
    \left(\begin{array}{l}
              \framep[n][0,...,p]:\frametype[n][0,...,p]        \\
              \painting[n][0,...,p]:\paintingtype[n][0,...,p]   \\
              \restrf[n+1][0,...,p-1]:\restrftype[n][0,...,p-1] \\
            \end{array}\right)
                                                                                           & :      & \Type               \\
    \layertype[n][p]                                                                       &
    \left(\begin{array}{l}
              \framep[n][0,...,p]     \\
              \painting[n][0,...,p]   \\
              \restrf[n+1][0,...,p-1] \\
            \end{array}\right)
                                                                                           & \defeq & \framep[n][p]
    \left(\begin{array}{l}
              \framep[n][0,...,p]     \\
              \painting[n][0,...,p]   \\
              \restrf[n+1][0,...,p-1] \\
            \end{array}\right) \rightarrow \U                                                                               \\
    \layer[n][p]                                                                           &
    \left(\begin{array}{l}
              \framep[n][0,...,p]:\frametype[n][0,...,p]        \\
              \painting[n][0,...,p]:\paintingtype[n][0,...,p]   \\
              \restrf[n+1][0,...,p-1]:\restrftype[n][0,...,p-1] \\
            \end{array}\right)                                   & :      & \layertype[n][p](\framep[n][0,...,p])           \\
    \layer[n][p]                                                                           &
    \left(\begin{array}{l}
              \framep[n][0,...,p]     \\
              \painting[n][0,...,p]   \\
              \restrf[n+1][0,...,p-1] \\
            \end{array}\right)                                                             & \defeq &
    d \mapsto \Pi\omega.\,\painting[n][p](\restrf[n][p](d))
  \end{array}
\end{equation*}

At this stage, it is convenient to use an abbreviation to combine sequences $\framep[n][0,..,p-1]$, $\painting[n][0,...,p-1]$ and $\restrf[n][0,...,p-1]$ in one block, which we call $\depstype[n][0,...p-1]$:

\begin{align*}
  \depstype[n][0,..,p-1] \defeq
  \left(\begin{array}{lll}
            \framep[n][0,...,p-1]   & : & \frametype[n][0,...,p-1]    \\
            \painting[n][0,...,p-1] & : & \paintingtype[n][0,...,p-1]
            (\framep[n][0,...,p-1])                                   \\
            \restrf[n][0,...,p-1]   & : & \restrftype[n][0,...,p-1]
            \left(\begin{array}{l}
                \framep[n][0,...,p-1]   \\
                \painting[n][0,...,p-1] \\
              \end{array}\right)                             \\
          \end{array}\right)
\end{align*}
so that the type of $\framep[n][0,...,p]$ can be shortened into $\depstype[n][0,..,p-1] \rightarrow \frametype[n][0,...,p]$ and similarly for $\layertype[n][p]$ and $\layer[n][p]$.
Later, we shall write $\deps.\framep$, $\deps.\painting$, $\deps.\restrf$ for the corresponding projections of a $\deps$. By abuse of notation, we also write $\unitpoint$ for the only inhabitant of $\depstype[n][0,..,0-1]$.

Defining $\painting[n][p]$, in addition to the type dependency in $\framep[n][p]$, requires the definition of $\painting[n-1][p-1]$, thus also $\framep[n-1][p-1]$ by typing dependency, as well as $\restrf[n][p-1]$. Since $\painting[n][p]$ also depends on $\painting[n][p+1]$ when $p<n$, these dependencies are actually between $\painting[n][p,...,n]$, $\painting[n-1][p,...,n-1]$, $\framep[n][p,...,n]$, $\framep[n-1][p,...,n-1]$ and $\restrf[n][p,...,n]$. Also, for the case $p=n$, this also requires the assumption of an inhabitant $X_{n}$ of $\nu$Set$^{=n}$. Finally, $\framep[n][p,...,n]$, $\framep[n-1][p,...,n-1]$ and $\restrf[n][p,...,n-1]$ respectively depend on the earlier values $\framep[n][0,...,p-1]$, $\framep[n-1][0,...,p-1]$ and $\restrf[n][0,...,p-1]$.  Below, we use dashed underline and dashed arrows for dependencies in subconstructions, here in the construction of $\framep$ at level $n-1$ and $\restrftype$ at level $n$:
\begin{center}
  \fontsize{7.2}{9}\selectfont
  \begin{tikzcd}
    & & \painting[n][p,...,n] \arrow[dd, bend right=70] \arrow[dddr] \arrow[d, dotted]\\
    \udensdash{\framep[n][0,...,p-1]} \arrow[d, dashed] \arrow[ddr, dashed] & &
    \udensdash{\framep[n][p,...,n]} \arrow[ll, dotted] \arrow[d, dashed] \arrow[ddr, dashed, shift right=2mm] \\
    \painting[n-1][0,...,p-1] \arrow[d, dotted] & &
    \painting[n-1][p,...,n-1] \arrow[ll, dotted] \arrow[d, dotted] \\
    \framep[n-1][0,...,p-1] &
    \udensdash{\restrf[n][0,...,p-1]} \arrow[l, dotted] \arrow[uul, dotted, shift right=2mm, hook'] &
    \framep[n-1][p,...,n-1] \arrow[ll, dotted, bend left=15] &
    \udensdash{\restrf[n][p,...,n-1]},X_n \arrow[ll, dotted, bend left=15] \arrow[l, dotted] \arrow[uul, dotted, hook']\\
  \end{tikzcd}
\end{center}

Let us introduce another abbreviation to combine a full $\deps[n][0,n]$ with a family $E:\framep[n-1][n-1]\rightarrow \U$:
\begin{align*}
  \fulldepstype[n] \defeq
  \left(\begin{array}{lll}
            \deps[n][0,...,n-1] & : & \depstype[n][0,...,n-1]                          \\
            E                   & : & \frame[n][n](\deps[n][0,...,n-1]) \rightarrow \U \\
          \end{array}\right)
\end{align*}
TODO: say the convention on projection in the Introduction

Also, when $n$ is 0, we write $E$ to denote an element $(\unitpoint, E)$ of $\fulldepstype[0]$.

We can now formally define $\painting[n][p]$ by recursion on $n-p$:
\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \painting[n][p]      &
    (\fulldeps[n-1]:\fulldepstype[n-1])                     \\
    \painting[n][n]      &
    (\fulldeps[n-1])     & \defeq & \fulldeps.E             \\
    \painting[n][p](p<n) &
    (\fulldeps[n-1])     & \defeq & d \mapsto
    \left(\begin{array}{l}
              \Sigma l:\layer(\fulldeps.\deps[n-1][0,...,p-1]). \\
              \painting[n][p+1]
              (\fulldeps[n-1])(d,l)                             \\
            \end{array}\right) \\
  \end{array}
\end{equation*}

From which we can deduce $\painting[n][0,...,p]$ by a second recursion, this time on $p$:

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \painting[n][0,...,p]   &
    (\fulldeps[n-1])        & :      & \paintingtype[n][0,...,p](\framep[n][0,...,p](\fulldeps.\deps[n-1][0,...,p])) \\
    \painting[n][0,...,0-1] &
    E                       & \defeq & \unittype                                                                     \\
    \painting[n][0,...,p]   &
    (\fulldeps[n-1])
                            & \defeq &
    (\painting[n][0,...,p-1](\fulldeps[n-1]),\painting[n][p](\fulldeps[n-1]))                                        \\
  \end{array}
\end{equation*}

At this stage, we are able to define $\framep[n][0,...,n]$, $\painting[n][0,...,n]$ and $\restrftype[n][0,...,n-1]$ from $\framep[n-1][0,...,n-1]$, $\painting[n-1][0,...,n-1]$ and $\restrf[n-1][0,...,n-1]$, that is from $\deps[n-1][0,...,n-1]$. To go further, we need to define the sequence $\restrptype[n][0,...,p]$ of types of painting restrictions:

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \restrptype[n][0,...,p]             &
    (\fulldeps[n-1]:\fulldepstype[n-1]) & :      & \U                                                    \\
    \restrptype[n][]                    & E      & \defeq                                    & \unittype \\
    \restrptype[n][0,...,p]             &
    (\fulldeps[n-1])
                                        & \defeq & \restrptype[n+1][0,...,p-1] \times \left(
    \begin{array}{l}
        \Pi q\leq n.\Pi \epsilon.\Pi d:\framep[n][p](\fulldeps.\deps[n][0,...,p]). \\
        \painting[n][p]
        (\fulldeps[n-1])(d) \rightarrow                                            \\ \fulldeps.\deps.\painting[n][p](\fulldeps.\deps.\restrf[n][p][q][\epsilon](d))\end{array}
    \right)                                                                                              \\
  \end{array}
\end{equation*}

Thanks to $\restrptype[n][0,...,n]$, we can mutually define $\restrf[n][p]$ and $\cohftype[n][p]$ from ``full dependencies'', that is from $\frame[n][0,...,n]$, $\painting[n][0,...,n]$, $\restrf[n][0,...,n]$ and some $E:\frame[n+1][n+1]$, using abbreviations in passing for $\layer$ and $\layertype$:

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \restrf[n][0,...,p]                                                          &
    \multicolumn{3}{l}{
      \left(\begin{array}{l}
                \fulldeps[n]:\fulldepstype[n] \\
                \restrp[n][0,...,p-2]:\restrptype[n][0,...,p-1]
                \left(\begin{array}{l}
                    \fulldeps[n] \\
                  \end{array}\right)      \\
                \cohf[n][0,...,p]:\cohftype[n][0,...,p]
                \left(\begin{array}{l}
                    \fulldeps[n]          \\
                    \restrp[n][0,...,p-2] \\
                  \end{array}\right)   \\
              \end{array}\right) :
      \restrftype[n][0,...,p]
      \left(\begin{array}{l}
                \framep[n][0,...,p](\fulldeps.\deps[n][0,...,p]) \\
                \painting[n][0,...,p](\fulldeps[n])              \\
              \end{array}\right)
    }                                                                                                                                                                                 \\
    \restrf[n][0,...,0-1]                                                        &
    \left(\begin{array}{l}
              E          \\
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)                                                       & \defeq & (\unitpoint,\lambda q. \lambda\epsilon. \lambda \_.\unitpoint)                          \\
    \restrf[n][0,...,(p+1)-1]                                                    &
    \left(\begin{array}{l}
              \fulldeps[n]        \\
              \restrp[n][0,...,p] \\
              \cohf[n][0,...,p]   \\
            \end{array}\right)                                                       & \defeq &
    \left(\begin{array}{l}
              \restrf[n+1][0,...,p][q][\epsilon]
              \left(\begin{array}{l}
                  \fulldeps[n+1]          \\
                  \restrp[n+1][0,...,p-1] \\
                  \cohf[n+1][0,...,p-1]   \\
                \end{array}\right),             \\
              \lambda q.\lambda \epsilon.\lambda (d,l). \\
              \left(\restrf[n][p][q][\epsilon]
              \left(\begin{array}{l}
                    \fulldeps[n+1]          \\
                    \restrp[n+1][0,...,p-1] \\
                    \cohf[n+1][0,...,p-1]   \\
                  \end{array}\right)(d), \restrl[n][p][q][\epsilon]
              \left(\begin{array}{l}
                    \fulldeps[n]            \\
                    \restrp[n+1][0,...,p-1] \\
                    \cohf[n][0,...,p]       \\
                  \end{array}\right)(d)(l)\right)     \\
            \end{array} \right)                                                                                                                        \\
    \cohftype[n][0,...,p-1]                                                      &
    \multicolumn{3}{l}{
      \left(\begin{array}{l}
              \fulldeps[n]:\fulldepstype[n]                                 \\
              \restrp[n][0,...,p-1]:\restrptype[n][0,...,p-1](\fulldeps[n]) \\
            \end{array}\right) : \U
    }                                                                                                                                                                                 \\
    \cohftype[n][0,...,0-1]                                                      &
    \left(\begin{array}{l}
              E          \\
              \unitpoint \\
            \end{array}\right)                                                       & \defeq &
    \unittype                                                                                                                                                                         \\
    \cohftype[n][0,...,(p+1)-1]                                                  &
    \left(\begin{array}{l}
              \fulldeps[n]        \\
              \restrp[n][0,...,p] \\
            \end{array}\right)                                                       & \defeq &
    \begin{array}{l}
      \Sigma \cohf[n+1][0,...,p-1]
      :\cohftype[n+1][0,...,p-1]
      \left(\begin{array}{l}
                \fulldeps[n+1]          \\
                \restrp[n+1][0,...,p-1] \\
              \end{array}\right).                           \\
      \Pi q\leq n.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega.\,\Pi d:\framep[n][p]
      \left(\begin{array}{l}
                \frame(\fulldeps.\deps[n][0,...,p])     \\
                \painting[n+1][0,...,p-1](\fulldeps[n]) \\
                \restrf[n][0,...,p]
                \left(\begin{array}{l}
                    \fulldeps[n+1]          \\
                    \restrp[n+1][0,...,p-1] \\
                    \cohf[n][0,...,p]       \\
                  \end{array}\right)           \\
              \end{array}\right). \\
      \\
      \fulldeps.\deps.\restrf[n][p][q][\epsilon](\restrf[n+1][p][r][\omega]
      \left(\begin{array}{l}
                \fulldeps[n+1]          \\
                \restrp[n+1][0,...,p-1] \\
                \cohf[n][0,...,p]       \\
              \end{array}\right)(d)) =                          \\
      \fulldeps.\deps.\restrf[n][p][r][\omega](\restrf[n+1][p][q+1][\epsilon]
      \left(\begin{array}{l}
                \fulldeps[n+1]          \\
                \restrp[n+1][0,...,p-1] \\
                \cohf[n][0,...,p]       \\
              \end{array}\right)(d))                           \\
    \end{array}                                                                                                        \\
    \restrltype[n][p]                                                            &
    \left(\begin{array}{l}
              \fulldeps[n]:\fulldepstype[n]                                        \\
              \restrp[n][0,...,p-1]:\restrptype[n][0,...,p-1](\deps[n][0,...,p-1]) \\
              \cohf[n][0,...,p]:\cohftype[n][0,...,p]                              \\
            \end{array}\right)      & :      & \U                                                                                                        \\
    \restrltype[n][p]                                                            &
    \left(\begin{array}{l}
              \fulldeps[n]          \\
              \restrp[n][0,...,p-1] \\
              \cohf[n][0,...,p]     \\
            \end{array}\right)
                                                                                 & \defeq & \Pi q \leq n. \Pi \epsilon. \Pi d: \framep[n][p].\left(
    \begin{array}{l}
        \layer[n][p]\left(
        \begin{array}{l}
            \framep[n][p](\fulldeps.\deps[n][0,...,p]) \\
            \painting[n][p](\fulldeps[n])              \\
            \restrf[n][p]
            \left(\begin{array}{l}
                      \fulldeps[n]          \\
                      \restrp[n][0,...,p-1] \\
                      \cohf[n][0,...,p]
                    \end{array}\right)                \\
          \end{array}\right)(d) \rightarrow \\
        \layer[n][p](\fulldeps.\deps[n][0,...,n])(\restrf[n][p]
        \left(\begin{array}{l}
                  \fulldeps[n]          \\
                  \restrp[n][0,...,p-1] \\
                  \cohf[n][0,...,p]
                \end{array}\right)(d))
      \end{array}\right)                                                                                                            \\
    \restrl[n][p]                                                                &
    \left(\begin{array}{l}
              \fulldeps[n]:\fulldepstype[n]                                 \\
              \restrp[n][0,...,p-1]:\restrptype[n][0,...,p-1](\fulldeps[n]) \\
              \cohf[n][0,...,p-1]:\cohftype[n][0,...,p-1]
              \left(\begin{array}{l}
                  \fulldeps[n]          \\
                  \restrp[n][0,...,p-1] \\
                \end{array}\right)                                   \\
            \end{array}\right) & :      &
    \restrltype[n][p] \left(\begin{array}{l}
                                \deps[n][0,...,n]     \\
                                \restrp[n][0,...,p-1] \\
                                \cohf[n][0,...,p]     \\
                              \end{array}
    \right)                                                                                                                                                                           \\
    \restrl[n][p]                                                                &
    \left(\begin{array}{l}
              \fulldeps[n]          \\
              \restrp[n][0,...,p-1] \\
              \cohf[n][0,...,p]     \\
            \end{array}\right)                                                     & \defeq &
    \lambda q\leq n. \lambda \epsilon.\,\lambda d.\lambda l.\overrightarrow{\cohf[n][p][q][q][\epsilon][\omega](d)}{\restrp[n][p][q][\epsilon](\restrf[n][p][q][\epsilon])(l \omega)} \\
  \end{array}
\end{equation*}

At this new stage, it is convenient to use a new abbreviation to combine sequences of $\deps[n][0,..,n]$, $\restrp[n][0,...,p-1]$ and $\cohf[n][0,...,p-1]$ in one block, which we call $\depscohstype[n][0,...p-1]$:

\begin{align*}
  \depscohstype[n][0,..,p-1] \defeq
  \left(\begin{array}{lcl}
            \fulldeps[n][0,...,n] & : & \fulldepstype[n][0,...,n] \\
            \restrp[n][0,...p-1]  & : & \restrptype[n][0,...,p-1] \\
            \cohf[n][0,...,p-1]   & : & \cohftype[n][0,...,p-1]   \\
          \end{array}\right)
\end{align*}
so that the type of $\restrf[n][0,...,p]$ can be rephrased as $\Pi \depscohs[n][0,...,p-1]:\depscohstype[n][0,..,p-1]. \restrftype[n][0,...,p]      \left(\begin{array}{l}
      \depscohs.\fulldeps.\deps.\framep[n][0,...,p]   \\
      \depscohs.\fulldeps.\deps.\painting[n][0,...,p] \\
    \end{array}\right)$, and similarly for $\restrltype$ and $\restrl$. Later, we shall write $\depscohs.\deps$, $\depscohs.\restrp$, and $\depscohs.\cohf$ for the corresponding projections of an element $\depscohs$ in $\depscohstype$. By abuse of notation, we also write $\unitpoint$ for the only inhabitant of $\depscohstype[n][0,..,0-1]$.

It is also convenient to build $\deps$ from $\depscohs$ at the previous level:

\begin{align*}
  \overline{\deps}(\depscohs:\depscohstype) & :      & \depstype \\
  \overline{\deps}(\depscohs)               & \defeq &
  \left(\begin{array}{l}
            \framep[n][p](\depscohs.\fulldeps.\deps[n][0,...,p]) \\
            \painting[n][p](\depscohs.\fulldeps[n][0,...,n])     \\
            \restrf[n][p](\depscohs[n][0,...,p])                 \\
          \end{array}\right)     \\
\end{align*}

\begin{align*}
  \overline{\fulldeps}(\fulldepscohs:\fulldepscohstype) & :      & \fulldepstype \\
  \overline{\fulldeps}(\fulldepscohs)                   & \defeq &
  \left(\begin{array}{l}
            \overline{\deps}(\fulldepscohs.\depscohs) \\
            \fulldepscohs.\depscohs.\fulldeps.E       \\
          \end{array}\right)                                \\
\end{align*}

We need also the notion of full dependencies at the level of coherence conditions, that combines a full $\depscohs[n][0,...,n]$ with a set $E:\framep[n][n](\overline{\deps}(\depscohs[n][0,...,n-1])) \rightarrow \U$:
\begin{align*}
  \fulldepscohstype[n] \defeq
  \left(\begin{array}{lcl}
            \depscohs[n][0,...,n-1] & : & \depscohstype[n][0,...,n-1]                                                \\
            E                       & : & \framep[n+1][n+1](\overline{\deps}(\depscohs[n][0,...,n-1]))\rightarrow \U \\
          \end{array}\right)
\end{align*}
TODO: say the convention on projection in the Introduction

Also, when $n$ is 0, we write $(E',E)$ to denote an element $(E', E)$ of $\fulldepscohstype[0]$.

Armed with $\restrf$, $\cohftype$ and these abbreviations, it is now possible to define $\restrp[n][p]$ by recursion on $n-p$:

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \restrp[n][p]                           &
    (\fulldepscohs[n]:\fulldepscohstype[n]) & :      &
    \left(
    \begin{array}{l}
        \Pi q\leq n. \Pi \epsilon. \Pi d:\framep[n][p]
        (\overline{\deps}(\depscohs)).                         \\
        \painting[n][p]
        (\overline{\fulldeps}(\fulldepscohs[n])(d) \rightarrow \\
        \painting[n-1][p](\fulldepscohs.\depscohs.\fulldeps[n])
        (\restrf[n][p](\fulldepscohs.\depscohs[n][0,...,n])(d))\end{array}\right)                                                        \\
    \restrp[n][n]                           &
    (\fulldepscohs[n][0,...,n])             & \defeq & \lambda q\leq n.\lambda \epsilon. \lambda d. \lambda (l,c). l\epsilon \\
    \restrp[n][p](p<n)                      &
    (\fulldepscohs[n][0,...,n])             & \defeq & \lambda q\leq n.\lambda \epsilon. \lambda d. \lambda (l,c).
    \left(\begin{array}{l}
              \restrl[n][p][q][\epsilon](\fulldepscohs.\depscohs[n-1][0,...,p-1])(...)(l), \\
              \restrp[n][p][q][\epsilon]
              (\fulldepscohs[n])(\restrf[n][p](\fulldepscohs.\depscohs[n][0,...,p])(d))(c) \\
            \end{array}\right)                                       \\
  \end{array}
\end{equation*}

From which we can deduce $\restrp[n][0,...,p]$ again by a second recursion, this time on $p$:

...

\section{...}

At this stage, we are then able to define $\restrf$, $\restrp$ and $\cohftype$
from $\depscohs$ at the previous level. To go further, we need to define the
sequence $\cohptype$ of types of painting coherence laws:

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \cohptype[n][0,...,p] & (\fulldepscohs[n]:\fulldepscohstype[n]) & :      & \U                                      \\
    \cohptype[n][]        & \unitpoint                              & \defeq & \unittype                               \\
    \cohptype[n][0,...,p] & (\fulldepscohs[n])                      & \defeq & \cohptype[n+1][0,...,p-1] \times \left(
    \begin{array}{l}
        \Pi q\leq n.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega.\,\Pi d:...\,\Pi c \\
        \fulldepscohs.\depscohs.\restrp[n][p][q][\epsilon](\restrf(d))(\restrp[n+1][p][r][\omega]
        (\fulldepscohs[n+1])(d)(c)) =                                            \\
        \fulldepscohs.\depscohs.\restrp[n][p][r][\omega](\restrf(d))(\restrp[n+1][p][q+1][\epsilon]
        (\fulldepscohs[n+1])(d)(c))
      \end{array}
    \right)                                                                                                            \\
  \end{array}
\end{equation*}

This is enough to define $\cohf[n][p]$, using $\UIP$ to solve the dependency in $\coht[n][p]$.

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \cohf[n][0,...,p]                                                           &
    \left(\begin{array}{l}
              \fulldepscohs[n]:\fulldepscohstype[n]                                    \\
              \cohp[n][0,...,p-2]:\restrptype[n][0,...,p-1](\fulldepscohs[n][0,...,n]) \\
              \coht[n][0,...,p]:\cohttype[n][0,...,p]
              \left(\begin{array}{l}
                  \fulldepscohs[n]    \\
                  \cohp[n][0,...,p-1] \\
                \end{array}\right)
            \end{array}\right) & :      & \cohftype[n][0,...,p]                                                                                             \\
    \cohf[n][0]                                                                 &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)                                                      & \defeq & (\unitpoint,\lambda q.\lambda r. \lambda\epsilon. \lambda\omega.\lambda \_.\refl) \\
    \cohf[n][0,...,p+1]                                                         &
    \left(\begin{array}{l}
              \fulldepscohs[n]  \\
              \cohp[n][0,...,p] \\
              \coht[n][0,...,p] \\
            \end{array}\right)                                                      & \defeq &
    \left(\begin{array}{l}
              \cohf[n+1][0,...,p]
              \left(\begin{array}{l}
                  \fulldepscohs[n+1]    \\
                  \cohp[n+1][0,...,p-1] \\
                  \coht[n+1][0,...,p-1] \\
                \end{array}\right),                                        \\
              \lambda q.\lambda r.\lambda \epsilon.\lambda \omega.\lambda (d,l). \\
              (\cohf[n][0,...,p][q][r][\epsilon][\omega]
              \left(\begin{array}{l}
                  \fulldepscohs[n+1]    \\
                  \cohp[n+1][0,...,p-1] \\
                  \coht[n+1][0,...,p-1] \\
                \end{array}\right)(d), \cohl[n][p][q][r][\epsilon][\omega]
              \left(\begin{array}{l}
                  \fulldepscohs[n]      \\
                  \cohp[n+1][0,...,p-1] \\
                  \coht[n][0,...,p]     \\
                \end{array}\right)(d)(l))                                    \\
            \end{array}\right)                                                                                    \\
    \cohttype[n][0,...,p-1]                                                     &
    \left(\begin{array}{l}
              \fulldepscohs[n]:\fulldepscohstype[n]                         \\
              \cohp[n][0,...,p-1]:\cohptype[n][0,...,p-1](\fulldepscohs[n]) \\
            \end{array}\right)            & :      & \U                                                                                                        \\
    \cohttype[n][0,...,0-1]                                                     &
    \left(\begin{array}{l}
              (E',E)     \\
              \unitpoint \\
            \end{array}\right)                                                      & \defeq &
    \unittype                                                                                                                                                                  \\
    \cohttype[n][0,...,(p+1)-1]                                                 &
    \left(\begin{array}{l}
              \fulldepscohs[n]  \\
              \cohp[n][0,...,p] \\
            \end{array}\right)                                                      & \defeq &
    \left(\begin{array}{l}
              \Sigma \coht[n+1][0,...,p-1]
              :\cohttype[n+1][0,...,p-1]
              \left(\begin{array}{l}
                  \fulldepscohs[n+1]      \\
                  \restrp[n+1][0,...,p-1] \\
                \end{array}\right).                                       \\
              \Pi q\leq n.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega.\,\Pi \theta  \\
              \fulldepscohs.\depscohs.\cohf[n][p][r][p][\omega][\theta] \circ \cohf[n+1][p][q+1][p][\epsilon][\theta]
              \left(\begin{array}{l}
                  \fulldepscohs[n+1]    \\
                  \cohp[n+1][0,...,p-1] \\
                  \coht[n+1][0,...,p-1]
                \end{array}\right)
              \circ \fulldepscohs.\depscohs.\cohf[n][p][q][r][\epsilon][\omega] = \\
              \cohf[n+1][p][q+1][r+1][\epsilon][\omega]
              \left(\begin{array}{l}
                  \fulldepscohs[n+1]    \\
                  \cohp[n+1][0,...,p-1] \\
                  \coht[n+1][0,...,p-1]
                \end{array}\right)
              \circ \fulldepscohs.\depscohs.\cohf[n][p][q][p][\epsilon][\theta]
              \circ \cohf[n+1][p][r][p][\omega][\theta]
              \left(\begin{array}{l}
                  \fulldepscohs[n+1]    \\
                  \cohp[n+1][0,...,p-1] \\
                  \coht[n+1][0,...,p-1]
                \end{array}\right)                                         \\
            \end{array}\right)                                                               \\
    \cohl[n][p]                                                                 &
    \left(\begin{array}{l}
              \fulldepscohs[n]:\fulldepscohstype[n]   \\
              \cohp[n+1][p]:\cohptype[n+1][p]         \\
              \coht[n][0,...,p]:\cohttype[n][0,...,p] \\
            \end{array}\right)                                  & :      &
    \begin{array}{l}
      \Pi q\leq n.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega.                                                                             \\
      \Pi d.\Pi l. \overrightarrow{\cohf[n][p][r+1][q+1][\epsilon][\omega]}{(\restrl[n][p][q][\epsilon](\restrl[n][p][r][\omega](l)))} = \\
      \restrl[n][p][r][\omega](\restrl[n][p][q+1][\epsilon](l))
    \end{array}                                         \\
    \cohl[n][p][q][\epsilon][r][\omega]                                         &
    \left(\begin{array}{l}
              \fulldepscohs[n]  \\
              \cohp[n][p]       \\
              \cohf[n][0,...,p] \\
            \end{array}\right)                                                      & \defeq &
    \lambda d. \lambda l. \lambda \theta. (\cohp[n][p][q][\epsilon][r][\omega](l))  ...                                                                                        \\
  \end{array}
\end{equation*}

This is time for a new abbreviation:

\begin{align*}
  \depscohttype[n][0,..,p-1] \defeq
  \left(\begin{array}{lll}
            \fulldepscohs[n]    & : & \fulldepscohstype[n]                      \\
            \cohp[n][0,...p-1]  & : & \cohptype[n][0,...,p-1](\fulldepscohs[n]) \\
            \coht[n][0,...,p-1] & : & \cohttype[n][0,...,p-1]
            \left(\begin{array}{l}
                \fulldepscohs[n]    \\
                \cohp[n][0,...,p-1] \\
              \end{array}\right)                                           \\
          \end{array}\right)
\end{align*}

It is also convenient to build $\depscohs$ from $\depscoht$ at the previous level:

\begin{align*}
  \overline{\depscohs}(\depscoht:\depscohttype) & :      & \depscohstype      \\
  \overline{\depscohs}(\depscoht)               & \defeq &
  \left(\begin{array}{l}
            \overline{\deps}[n][p](\depscoht.\fulldepscohs.\depscohs[n][0,...,p]) \\
            \restrp[n][p](\depscoht.\fulldepscohs[n][0,...,n])                    \\
            \cohf[n][p](\depscoht[n][0,...,p])                                    \\
          \end{array}\right) \\
\end{align*}

\begin{align*}
  \overline{\fulldepscohs}(\fulldepscoht:\fulldepscohstype) & :      & \fulldepscohstype \\
  \overline{\fulldepscohs}(\fulldepscoht)                   & \defeq &
  \left(\begin{array}{l}
            \overline{\depscohs}(\fulldepscoht.\depscoht) \\
            \fulldepscoht.\depscoht.\fulldepscohs.E       \\
          \end{array}\right)                                    \\
\end{align*}

We need also the notion of full dependencies at the level of the coherence conditions of dimension 2, that combines a full $\depscoht[n][0,...,n]$ with a set $E:\framep[n][n](\overline{\depscohs}(\depscoht[n][0,...,n-1])) \rightarrow \U$:
\begin{align*}
  \fulldepscohttype[n] \defeq
  \left(\begin{array}{lll}
            \depscoht[n][0,...,n-1] & : & \depscohttype[n][0,...,n-1]                                                    \\
            E                       & : & \framep[n+2][n+2](\overline{\depscohs}(\depscoht[n][0,...,n-1]))\rightarrow \U \\
          \end{array}\right)
\end{align*}

The next step is to define $\cohp[n][p]$ by recursion on $n-p$:

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \cohp[n][p]                                               &
    (\fulldepscoht[n][0,...,n]:\fulldepscohttype[n][0,...,n]) & :      &
    \left(
    \begin{array}{l}
        \Pi q\leq n.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega.\,\Pi d.\,\Pi c.\, \\
        \restrp[n][p][q][\epsilon](\overline{\fulldeps}(\depscoht))(\restrp[n+1][p][r][\omega]
        (\fulldepscoht.\depscoht.\fulldepscohs[n+1][0,...,n])(d)(c)) =           \\
        \restrp[n][p][r][\omega](\overline{\fulldeps}(\depscoht))(\restrp[n+1][p][q+1][\epsilon]
        (\fulldepscoht.\depscoht.\fulldepscohs[n+1][0,...,n])(d)(c))             \\
      \end{array}\right)                                                                                 \\
    \cohp[n][n]                                               &
    (\fulldepscoht[n][0,...,n])
                                                              & \defeq & \lambda q\leq n.\lambda r\leq q.\lambda \epsilon.\lambda \omega.\lambda d. \lambda (l,c). l\epsilon \\
    \cohp[n][p](p<n)                                          &
    (\fulldepscoht[n][0,...,n])
                                                              & \defeq & \lambda q\leq n.\lambda r\leq q.\lambda \epsilon.\lambda \omega.\lambda d. \lambda (l,c).
    \left(\begin{array}{l}
              \cohl[n][p][q][\epsilon](\fulldepscoht.\depscoht[n-1][0,...,p-1])(...)(l),          \\
              \cohp[n][p][q][\epsilon]
              (\fulldepscoht[n][0,...,n])(\cohf[n][p](\fulldepscoht.\depscoht[n][0,...,p])(d))(c) \\
            \end{array}\right)                                                                                \\
  \end{array}
\end{equation*}

From which we can deduce $\cohp[n][0,...,p]$ again by a second recursion, this time on $p$:

Armed with all the constructions we can now define
\bibliographystyle{msclike}
\bibliography{paper}

\end{document}
