\documentclass[10pt]{art}

\usepackage{multirow, minted, tabularx, booktabs, setspace, makecell, caption, xkeyval, xstring, xpatch, stringstrings, pdflscape}
\usepackage[a4paper, inner=25mm, outer=25mm, top=25mm, bottom=25mm]{geometry}

% Some lua magic to join a variable number of arguments with commas
% Comma-separeated optional arguments
\begin{luacode*}
  function remove_empty(tbl)
    for i, v in ipairs(tbl) do
        if v == "" then
          table.remove(tbl, i)
          return remove_empty(tbl)
        end
    end
    return tbl
  end
  function join_with_comma(prefix, tbl)
    str = table.concat(remove_empty(tbl), ",")
    if str == "" then
      return str
    end
    return prefix .. str
  end
\end{luacode*}

\newcommandx{\joinargs}[6][2=,3=,4=,5=,6=]{\directlua{tex.sprint(join_with_comma("#1", {"\luaescapestring{#2}";"\luaescapestring{#3}";"\luaescapestring{#4}";"\luaescapestring{#5}";"\luaescapestring{#6}"}))}}

% Simplicial and Cubical sets
\newcommand{\DeltaHat}{\ensuremath{\hat{\boldsymbol{\Delta}}}}
\newcommand{\Cube}[1]{\ensuremath{\boldsymbol{\square^{#1}}}}
\renewcommand{\I}[1]{\ensuremath{\mathsf{I}^{#1}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommand{\U}[1]{\ensuremath{\mathsf{\color{spanish-blue}{U}}_{#1}}}

% The unit type
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\unitpoint}{\ensuremath{\star}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\eqHSet}{\ensuremath{\equiv_{\mathit{HSet}}}}
\newcommand{\reflHSet}{\ensuremath{\mathsf{refl}_{\mathit{HSet}}}}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[base]{X}{D}{(#1)}

\define@cmdkey[prim]{frame}{D}{(#1)}
\define@cmdkey[prim]{layer}{D}{(#1)}
\define@cmdkey[prim]{layer}{d}{(#1)}
\define@cmdkey[prim]{filler}{D}{(#1)}
\define@cmdkey[prim]{filler}{E}{(#1)}
\define@cmdkey[prim]{filler}{d}{(#1)}
\define@cmdkey[prim]{fullframe}{D}{(#1)}

\define@cmdkey[restr]{frame}{D}{(#1)}
\define@cmdkey[restr]{frame}{d}{(#1)}
\define@cmdkey[restr]{layer}{D}{(#1)}
\define@cmdkey[restr]{layer}{d}{(#1)}
\define@cmdkey[restr]{layer}{l}{(#1)}
\define@cmdkey[restr]{filler}{D}{(#1)}
\define@cmdkey[restr]{filler}{E}{(#1)}
\define@cmdkey[restr]{filler}{d}{(#1)}
\define@cmdkey[restr]{filler}{c}{(#1)}

\define@cmdkey[coh]{frame}{D}{(#1)}
\define@cmdkey[coh]{frame}{d}{(#1)}
\define@cmdkey[coh]{layer}{D}{(#1)}
\define@cmdkey[coh]{layer}{d}{(#1)}
\define@cmdkey[coh]{layer}{l}{(#1)}
\define@cmdkey[coh]{filler}{D}{(#1)}
\define@cmdkey[coh]{filler}{E}{(#1)}
\define@cmdkey[coh]{filler}{d}{(#1)}
\define@cmdkey[coh]{filler}{c}{(#1)}
\makeatother

% More magic: we patch xkeyval's \setkeys to use a mask to ignore keys
\makeatletter
% Our global mask
\def\bonak@mask{}

% First we define \appendmask
\long\def\bonak@appendmask[#1]{
  \XKV@for@eo\XKV@fams\XKV@tfam{
    \def\bonak@hdr{\XKV@prefix\XKV@tfam @}
    \XKV@for@o{#1}\XKV@tempa{
      \XKV@addtolist@x\bonak@mask{\bonak@hdr\XKV@tempa}
      }
  }
}
\def\appendmask{\XKV@testopta{\XKV@testoptc\bonak@appendmask}}

% A small utility helper, since \XKV@delete isn't suitable
\long\def\bonak@delete#1#2#3{
  \let\XKV@tempb#1
  \let#1\@empty
  \XKV@for@o\XKV@tempb\XKV@tempb{
    #3\XKV@tempb\XKV@tempc
    \ifx \XKV@tempc #2
    \else
      \XKV@addtolist@o#1\XKV@tempb
    \fi
  }
}

% Now we patch \XKV@setkeys
\xpretocmd{\XKV@setkeys}{
  \XKV@checksanitizea{#2}\XKV@resb
  \XKV@for@o\XKV@fams\XKV@tfam{
    \def\bonak@hdr{\XKV@prefix\XKV@tfam @}
    \XKV@for@o{\bonak@mask}\XKV@tempa{
      \whereisword[q]{\XKV@tempa}{\bonak@hdr}
      \ifx \theresult 0
      \else
        \substring[q]{\XKV@tempa}{$}{$}
        \bonak@delete\XKV@resb\thestring\XKV@getkeyname
      \fi
    }
  }
}{}{}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx*{\X}[3][1=,2=,3=]{
  \ensuremath{\mathsf{\color{carolina}{X}}_{#1}^{#2}}
  \setkeys*[base]{X}{#3}
}

% Frame, layer, and filler: the general macro
\newcommandx*{\prim}[6][2=,3=,4=,5=,6=]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs{}[#3][#4][#5]}}
  \setkeys*[prim]{#1}{#6}
}

% Restriction for frame, layer, and filler: the general macro
\newcommandx*{\restr}[8][2=,3=,4=,5=,6=,7=,8=]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4]}^{\joinargs{}[#5][#6][#7]}}
  \setkeys*[restr]{#1}{#8}
}

% Coherence conditions for frame, layer, and filler: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx*{\coh}[9][2=,3=,4=,5=,6=,7=,8=,9=]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4][#5][#6]}^{\joinargs{}[#7][#8]}}
  \setkeys*[coh]{#1}{#9}
}

% Some abbreviations
\newcommand{\imp}{\ensuremath{\rightarrow}}
\newcommand{\overright}[1]{\ensuremath{\overrightarrow{#1}}}
\renewcommand{\D}{\ensuremath{D}}
\newcommand{\hdD}{\ensuremath{D.1}}
\newcommand{\tlD}{\ensuremath{D.2}}
\renewcommand{\d}{\ensuremath{d}}
\newcommand{\E}{\ensuremath{E}}
\renewcommand{\l}{\ensuremath{l}}
\renewcommand{\c}{\ensuremath{c}}
\newcommand{\pair}[2]{\ensuremath{#1, #2}}

% Fancy headers
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\footnotesize\textcolor{gray80}{{\thepage / \pageref{LastPage}}}}
\renewcommand{\sectionmark}[1]{\markboth{}{\thesection.\ #1}}
\fancyhead[L]{\footnotesize\textcolor{gray80}{{\MakeUppercase{\rightmark}}}}

% Section and subsection styles
\renewcommand{\thesection}{\Roman{section}}
\titleformat{\section}{\centering\scshape\Large\color{raspeberry}}{\thesection}{0.7em}{}
\titleformat{\subsection}{\strongenv\large\color{gray80}}{\thesubsection}{0.7em}{}

% Pack enumerate items and bibitems
\setlist{nolistsep}
\setlength{\bibitemsep}{.2\baselineskip plus .05\baselineskip minus .05\baselineskip}

% The eqntable environment, displaying the various
\NewDocumentEnvironment{eqntable}{m}{\table[H]\small\hrule\vspace{0.5em}
\tabularx{\textwidth}{@{} l c c >{\centering\arraybackslash}X @{}}}
{\endtabularx\vspace{0.3em}\hrule\vspace{0.5em}\caption{#1}\endtable}

% A block in the eqntable environment
\newcommand{\eqnline}[4]{$#1$ & $#2$ & $#3$ & $#4$ \\}
\newcommand{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% Table caption set up
\DeclareCaptionFormat{hfillstart}{\hfill#1#2#3\par}
\DeclareCaptionFont{mdit}{\mdseries\itshape}
\captionsetup[table]{
  justification=centering,
  font=bf,
  labelfont=mdit,
}

% Code listings
\usemintedstyle{solarized-dark}
\setminted{escapeinside=~~}
\setmintedinline{escapeinside=~~}

% Fonts
\setmainfont{Avenir Next}
\setmonofont{Source Code Pro}
\defaultfontfeatures{Ligatures=TeX, Scale=MatchUppercase}

\title{An indexed construction of semi-simplicial and semi-cubical types}
\author{
  \textcolor{gray80}{Ramkumar Ramachandra} \\
  \itshape \textcolor{gray80}{Université Paris-Cité}
  \and
  \textcolor{gray80}{Hugo Herbelin} \\
  \itshape \textcolor{gray80}{Instit de Recherche en Informatique Fondamentale}
}
\date{}

\color{gray65}

\begin{document}
\thispagestyle{empty}
\maketitle
\begin{abstract}
  A model of homotopy type theory, formalizing augmented semi-simplicial sets, that naturally generalizes to semi-cubical sets as well, in dependent type theory. The accompanying artifact is an axiom-less~\footnote{Technically speaking, we use some axioms related to functional extensionality, but the requirement arises only from our generalization to $\nu$-types; if $\nu$ is finite (say, unit type corresponding to augmented semi-simplicial types), this requirement vanishes.} Coq formalization that uses sophisticated rewriting techniques and pushes the boundaries of proof assistant technology.
\end{abstract}
\tableofcontents
\newpage

\section{Overture}
Cubical type theory~\cite{Bezem14}~\cite{Cohen16}~\cite{Angiuli17} is an extension of dependent type theory that provides a computational interpretation of Voevodsky's \emph{univalence axiom}, in a field known as \emph{homotopy type theory}, or HoTT. Two real-world projects that implement cubical type theory are worthy of mention: an experimental branch of Agda, known as \emph{Cubical Agda}~\cite{Vezzosi21}, and the Arend theorem prover~\footnote{\href{https://arend-lang.github.io}{arend-lang.github.io}}. Cubical type theory is usually modeled as cubical sets, in the set-theoretic setting. Efforts to model cubical type theory have been ongoing since 2014, and many of these efforts are in the set-theoretic setting.

Our contribution is to model the core of semi-cubical sets that naturally generalizes to semi-simplicial sets in type theory, and we call our generalization \emph{truncated $n$-sets}. In contrast to previous efforts that use a fibered representation, we use an indexed representation, that can be derived from the fibered one using a \emph{iterated reverse-Grothendieck} construction. Our work is, in principle axiom-free, although the accompanying artifact uses functional extensionality in order to generalize our work to $n$-truncated sets.

\begin{table}[H]
  \begin{tabularx}{\linewidth}{p{.3\linewidth}|p{.3\linewidth}|p{.3\linewidth}}
    \toprule
            & Set theory & Type theory \\
    \midrule
    Fibered & CCHM       &             \\
    \midrule
    Indexed &            & Our work    \\
    \bottomrule
  \end{tabularx}
\end{table}

The outline of the paper is as follows. First, we take the opportunity to familize the reader with simplicial sets, as it appears in mathematical literature, along with a short section on semi-cubical sets. We then proceed to explain our construction, with the help of diagrams. Before spelling out the details of our formalization in type-theoretic language, we have a section on reasoning in sets, in which we spell out \texttt{HSet}.

\section{\texorpdfstring{$\nu$}{nu}-sets}
Simplicial sets are powerful mathematical objects, that form the basis of much of modern homotopy theory. Their power derives from the fact that their homotopy category is exceptionally well-behaved, and that there are multiple model structures defined on them. Unlike CW-complexes that rely on pure topological notions like spheres and disks to ``tame'' a topological space, the definition of simplicial sets is purely categorical, and exist independent of topological spaces. The \emph{geometric realization} and \emph{singular complex} functors facilitate travelling back-and-forth between simplicial sets and topological spaces, and these are non-trivial constructions. As such, simplicial sets exist purely in the imagination of the mathematician, as every simplicial set has an infinite number of degenerate simplices.

\subsection{Augmented semi-simplicial sets}
The first step towards formalizing simplicial sets is to forget about the degeneracies, and we restrict ourselves to representing \emph{augmented simplicial sets}, otherwise known as delta-sets in mathematical literature. We now proceed to describe \DeltaHat, which is identical to \Simplex{}, but for the fact that the maps $\sq{m} \rightarrow \sq{n}$ are \emph{strictly} order-preserving. The degeneracies then vanish, and we're left with the task of defining gluing conditions solely on the basis of face maps. In mathematical literature, there is little interest in studying \DeltaHat, since maps between delta sets are not well-defined, and it is therefore not possible to construct a category of delta sets.

\subsection{Semi-cubical sets}
We might naively attempt to define $\Cube{}$ identically to \DeltaHat, but let us briefly explain why this wouldn't work, motivating the definition of semi-cubical sets as in \cite{Antolini00}. If there were morphisms from every $\sq{m}$ to \sq{n}, we would end up with:

$$
  \begin{tikzcd}
    \bullet \arrow[r] \arrow[dr] \arrow[d] & \bullet \arrow[d] \\
    \bullet \arrow[r] \arrow[ur] & \bullet
  \end{tikzcd}
$$

where the filling conditions are conflated with the cube itself. $\Simplex{n}$ can be defined quite simply as the convex hull of $n$ points, but even defining the standard $n$-cube becomes a problem if we start with $\sq{n}$, but the situation becomes much more amenable if we define:

\begin{definition}[\Cube{n}]
  \begin{equation*}
    \Cube{n} := \I{n} = \sq{0, 1}^n
  \end{equation*}
\end{definition}

\begin{example}[$\Cube{0}$, $\Cube{1}$ and $\Cube{2}$]
  $\Cube{0}$ can be drawn as:

  $$
    \begin{tikzcd}
      0 \equiv 1
    \end{tikzcd}
  $$

  $\Cube{1}$ can be drawn as:

  $$
    \begin{tikzcd}
      0 \arrow[r, dash] & 1
    \end{tikzcd}
  $$

  and $\Cube{2}$ can be drawn as:

  $$
    \begin{tikzcd}
      (0, 1) \arrow[r, dash] & (1, 1) \arrow[d, dash] \\
      (0, 0) \arrow[u, dash] & (1, 0) \arrow[l, dash]
    \end{tikzcd}
  $$
\end{example}

Here, $\I{n}$ serves the purpose of \sq{n}, but this change will cascade into other definitions. In view of defining a category \CSet, we will restrict the morphisms in \Cube{}.

\begin{definition}[\Cube{}]
  \begin{align*}
    \obj(\Cube{}) & := \I{n}                                           \\
    \mor(\Cube{}) & := \delta^\epsilon_i : \I{n + 1} \rightarrow \I{n}
  \end{align*}

  where $\delta^\epsilon_i$ must satisfy the corresponding face map condition:

  \begin{equation*}
    \delta^\epsilon_i \delta^\omega_j = \delta^\omega_{j - 1} \delta^\epsilon_i
  \end{equation*}

  where $\epsilon$ and $\omega$ correspond to opposite faces.
\end{definition}

\begin{definition}[\CSet]
  Just as in \SSet, we define semi-cubical sets as the functor category:

  \begin{equation*}
    \CSet := \Set^{\Cube{}^{op}}
  \end{equation*}
\end{definition}

Or, in terms of objects and morphisms:

\begin{definition}[$\CSet$ in terms of objects and morphisms]
  \begin{align*}
    \obj(\CSet) & := X_n                                                   \\
    \mor(\CSet) & := X_\lambda, \text{where $\lambda$ is \Cube{}-morphism}
  \end{align*}

  where we term $X_n$ as the $n$-cubex, and $X_\lambda$ as the ``face map'', defined similarly:

  \begin{align*}
    X_n       & := X(\I{n}), \text{where X is the semi-cubical set} \\
    X_\lambda & := X(\lambda)
  \end{align*}
\end{definition}

\begin{theorem}
  $\CSet$ does not admit degeneracies.
  \begin{proof}
    The reader is advised to refer to \cite{Antolini00} for the proof.
  \end{proof}
\end{theorem}

\section{Our construction}
The fibered representation:

\begin{equation*}
  \begin{tikzcd}
    X_0 : \U{} & X_1 : \U{} \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] & X_2 : \U{} \arrow[l, "\delta^\epsilon_1" description, shift left=6] \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] \arrow[l, "\delta^\omega_1" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}

The indexed representation:
\begin{align*}
  X_0 & : \U{}                                                                                                      \\
  X_1 & : X_0 \times X_0 \rightarrow \U{}                                                                           \\
  X_2 & : \forall a b c d, X_1 : ab \rightarrow X_1 : bc \rightarrow X_1 : cd \rightarrow X_1 : da \rightarrow \U{} \\
  \ldots
\end{align*}

\section{Reasoning about sets in type theory}
We dedicate this section to discussing UIP in different settings, and supply intuitions into this notion.

UIP is a flavor of proof-irrelevance:

\begin{align*}
  \forall x y, \forall p q : x = y, p = q
\end{align*}

which is to say that any two proofs of \emph{equality} of the same two types are \emph{equal}. In other words, the proofs cannot be distinguished from one another.

Proof irrelevance is an inherent part of set theory and first-order logic, although the property cannot be stated in the language of natural deductions. Intuititively, what it means is that a tree of deductions converges to a result, with no memory of the proof route; the tree itself is forgotten once the final result is obtained.

\section{Type-theoretic construction of \texorpdfstring{$\nu$}{nu}-sets}
In this section, we give the core of the definition of truncated $\nu$-sets
as a coinductive limit.

% Now, we write the type theory bit, and input the abbreviated tables

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and filler
% Drop the universe letter
\newcommandx{\framep}[5][1=,2=,3=,4=,5=]{\prim{frame}[][#2][#3][#4][#5]}
\newcommandx{\layer}[5][1=,2=,3=,4=,5=]{\prim{layer}[][#2][#3][#4][#5]}
\newcommandx{\filler}[5][1=,2=,3=,4=,5=]{\prim{filler}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and filler
% Drop the unviverse letter and q
\newcommandx{\restrf}[7][1=,2=,3=,4=,5=,6=,7=]{\restr{frame}[][#2][][#4][#5][#6][#7]}
\newcommandx{\restrl}[7][1=,2=,3=,4=,5=,6=,7=]{\restr{layer}[][#2][][#4][#5][#6][#7]}
\newcommandx{\restrc}[7][1=,2=,3=,4=,5=,6=,7=]{\restr{filler}[][#2][][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and filler
% Keep only ε, ω; n, p; proposition on n and p
\newcommandx{\cohf}[9][1=,2=,3=,4=,5=,6=,7=,8=,9=]{\coh{frame}[][#2][#3][][][][][#9]}
\newcommandx{\cohl}[9][1=,2=,3=,4=,5=,6=,7=,8=,9=]{\coh{layer}[][#2][#3][][][][][#9]}
\newcommandx{\cohc}[9][1=,2=,3=,4=,5=,6=,7=,8=,9=]{\coh{filler}[][#2][#3][][][][][#9]}

The definition is dispatched over tables \ref{tab:core}, \ref{tab:frames}, \ref{tab:faces} and \ref{tab:coh}. It describes the structure of the underlying higher-dimensional relations on which fillers are built. Note the presence of a coherence condition $\cohf$ to ensuring that both sides of the equality in $\restrl$ and $\restrc$ are in the same type. The proof of $\cohf$ itself requires an higher-dimensional coherence condition which we obtain by working in HSet. Note that if the proofs of the same equality were not equated, there would be a need for arbitrary many higher-dimensional coherences (see e.g.~\cite{Herbelin15} for a discussion on the de facto need for recursive higher-dimensional coherence conditions in formulating higher-dimensional structures in type theory). Note also that for a given $n$, the coherence conditions evaluate to a reflexivity proof, so that the construction evaluates to an effective sequence of types of iterated relations not mentioning $\restrf$ nor $\cohf$ anymore.

We call the structure thus defined \emph{bare truncated sets}: \emph{bare} because it can be seen as defining truncated $\nu$-sets corresponding to simplical sets with only faces as part of the structure.

\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\newcommandx{\fullframe}[3][1=,2=,3=]{\prim{fullframe}[#1][#2][][][#3]}
\input{tab-core.tex}

% Drop the universe letter in fullframe for all remaining tables
\renewcommandx{\fullframe}[3][1=,2=,3=]{\prim{fullframe}[][#2][][][#3]}
\input{tab-frames.tex}

% From the third table onwards, make the {D, E} arguments of prims implicit
\appendmask[prim]{frame}[D]
\appendmask[prim]{layer}[D]
\appendmask[prim]{filler}[D,E]

% Truncated sets, otherwise referred to as X
% Drop the universe letter for the third and fourth tables
\renewcommandx{\Xto}[3][3=]{\X[][<#2][#3]}
\renewcommandx{\Xcomp}[3][3=]{\X[][=#2][#3]}
\renewcommandx{\Xfrom}[3][3=]{\X[][\geq#2][#3]}

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1=,2=,3=,4=,5=,6=,7=,8=,9=]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}
\input{tab-faces.tex}

% Restriction for frame, layer, and filler
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1=,2=,3=,4=,5=,6=,7=]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1=,2=,3=,4=,5=,6=,7=]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1=,2=,3=,4=,5=,6=,7=]{\restr{filler}[][#2][#3][#4][#5][#6][#7]}

% Frame, layer, and filler
% Drop all arguments for coh table; they're not present in coind table.
\renewcommandx{\framep}[5][1=,2=,3=,4=,5=]{\prim{frame}[][][][][#5]}
\renewcommandx{\layer}[5][1=,2=,3=,4=,5=]{\prim{layer}[][][][][#5]}
\renewcommandx{\filler}[5][1=,2=,3=,4=,5=]{\prim{filler}[][][][][#5]}

% Coherence conditions for frame, layer, and filler
% Drop universe letter, ε, and ω
\renewcommandx{\cohf}[9][1=,2=,3=,4=,5=,6=,7=,8=,9=]{\coh{frame}[][][][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1=,2=,3=,4=,5=,6=,7=,8=,9=]{\coh{layer}[][][][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1=,2=,3=,4=,5=,6=,7=,8=,9=]{\coh{filler}[][][][#4][#5][#6,#7][#8][#9]}
\input{tab-coh.tex}

\section{Future work}

\newpage
\appendix
\section{Tables in full detail}
% Keep all arguments for all macros
% Frame, layer, and filler
\renewcommandx{\framep}[5][1=,2=,3=,4=,5=]{\prim{frame}[#1][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1=,2=,3=,4=,5=]{\prim{layer}[#1][#2][#3][#4][#5]}
\renewcommandx{\filler}[5][1=,2=,3=,4=,5=]{\prim{filler}[#1][#2][#3][#4][#5]}
\renewcommandx{\fullframe}[3][1=,2=,3=]{\prim{fullframe}[#1][#2][][][#3]}

% Restriction for frame, layer, and filler
\renewcommandx{\restrf}[7][1=,2=,3=,4=,5=,6=,7=]{\restr{frame}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1=,2=,3=,4=,5=,6=,7=]{\restr{layer}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1=,2=,3=,4=,5=,6=,7=]{\restr{filler}[#1][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohf}[9][1=,2=,3=,4=,5=,6=,7=,8=,9=]{\coh{frame}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1=,2=,3=,4=,5=,6=,7=,8=,9=]{\coh{layer}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1=,2=,3=,4=,5=,6=,7=,8=,9=]{\coh{filler}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}

\input{tab-coind.tex}
\input{tab-core.tex}
\input{tab-frames.tex}

\begin{landscape}
  \input{tab-faces.tex}
  \input{tab-coh.tex}
\end{landscape}

\newpage
\begin{thebibliography}{10}
  \bibitem[Bez]{Bezem14}
  Bezem, M., Coquand, T., \& Huber, S. (2014, July). A model of type theory in cubical sets. \emph{In 19th International Conference on Types for Proofs and Programs (TYPES 2013)} (Vol. 26, pp. 107-128). Wadern, Germany: Schloss Dagstuhl–Leibniz Zentrum fuer Informatik.

  \bibitem[CubAgda]{Vezzosi21}
  Vezzosi, A., Mörtberg, A., \& Abel, A. (2021). Cubical Agda: a dependently typed programming language with univalence and higher inductive types. \emph{Journal of Functional Programming, 31}.

  \bibitem[CohCoq]{Cohen16}
  Cohen, C., Coquand, T., Huber, S., \& Mörtberg, A. (2016). Cubical type theory: a constructive interpretation of the univalence axiom. \emph{arXiv preprint arXiv:1611.02108}.

  \bibitem[Angiuli]{Angiuli17}
  Carlo Angiuli, Guillaume Brunerie, Thierry Coquand, Kuen-Bang Hou (Favonia), Robert Harper, \& Daniel R. Licata. arXiv preprint.

  \bibitem[Fri]{Friedman08}
  Friedman, G. (2008). An elementary illustrated introduction to simplicial sets. \emph{arXiv preprint arXiv:0809.4221}.

  \bibitem[Rie]{Riehl11}
  Riehl, E. (2011). A leisurely introduction to simplicial sets. \emph{Unpublished expository article available online from the author's web page}.

  \bibitem[CubSet]{Antolini00}
  Antolini, R. (2000). Cubical structures, homotopy theory. \emph{Annali di Matematica pura ed applicata, 178}(1), 317-324.

  \bibitem[Her]{Herbelin15}
  Herbelin, H. (2015). A dependently-typed construction of semi-simplicial types. \emph{Mathematical Structures in Computer Science, 25}(5), 1116-1131.

  \bibitem[CoqInCoq]{Barras97}
  Barras, B., \& Werner, B. (1997). Coq in coq. \emph{Available on the WWW.}
\end{thebibliography}

\end{document}
