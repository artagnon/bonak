%% -*- latex-command: pdflatex -shell-escape -*-
\documentclass[10pt]{art.cls/art}

\usepackage{multirow, float, tabularx, environ, booktabs, setspace, makecell, caption, art.cls/joinargs, colortbl, multicol, rotating, flushend}

\makeatletter
\@namedef{ver@lineno.sty}{9999/12/31}
\@namedef{opt@lineno.sty}{}
\makeatother
\usepackage{minted}

\usepackage[prefix=bonak]{art.cls/xkeymask}
\usetikzlibrary{patterns}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{painting}{D}{(#1)}
\define@cmdkey[bonak]{painting}{E}{(#1)}
\define@cmdkey[bonak]{painting}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrpainting}{D}{(#1)}
\define@cmdkey[bonak]{restrpainting}{E}{(#1)}
\define@cmdkey[bonak]{restrpainting}{d}{(#1)}
\define@cmdkey[bonak]{restrpainting}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohpainting}{D}{(#1)}
\define@cmdkey[bonak]{cohpainting}{E}{(#1)}
\define@cmdkey[bonak]{cohpainting}{d}{(#1)}
\define@cmdkey[bonak]{cohpainting}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \ensuremath{{\color{carolina}{\nu\textsf{Set}}}_{#1}^{#2}}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and painting: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and painting: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4]}^{\joinargs[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

% Coherence conditions for frame, layer, and painting: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6][#7]}^{\joinargs[#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaHat}{\ensuremath{\hat{\boldsymbol{\Delta}}}}
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}{\ensuremath{\boldsymbol{\square}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommandx{\U}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HSet}}_{#1}}}
\newcommandx{\HGpd}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HGpd}}_{#1}}}
\newcommand{\Type}{\ensuremath{\mathsf{\color{spanish-blue}{Type}}}}
\newcommand{\SProp}{\ensuremath{\mathsf{\color{spanish-blue}{SProp}}}}


% The unit and bool types
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\booltype}{\ensuremath{\mathsf{bool}}}
\newcommand{\unitpoint}{\ensuremath{\ast}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\refl}{\ensuremath{\mathsf{refl}}}

% Some abbreviations
\newcommand{\tl}{\ensuremath{\mathsf{tl}}}
\newcommand{\hd}{\ensuremath{\mathsf{hd}}}
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\newcommand{\ap}{\mathsf{ap}\;}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommand{\Dom}{\textsf{Dom}}
\newcommand{\UIP}{\textsf{UIP}}

% These are renewed in tables, but let's define them now for in-document
% typesetting
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\newcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\newcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\newcommandx{\restrc}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\newcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\newcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\newcommandx{\cohc}{\coh{painting}[][][][][][][][]}
\newcommandx{\coht}{\cohtwo{frame}[][][][][][][][]}
\newcommandx{\fullframe}[1][1]{\prim{fullframe}[][#1][][][]}

% For typesetting type theory rules
\newcommand \seqr[3]
  {\shortstack{$#2$ \\ \mbox{}\\
                   \mbox{}\hrulefill\mbox{}\\ \mbox{}\\ $#3$} \raisebox{2ex}{$\;\;\mbox{$#1$}$}}

% Kerning for star
\newcommand{\kstar}{{\star}}

% The eqntable environment, displaying the various
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{onecoltbl}[1]{
  \begin{table}[H]
    \small
    \begin{tabularx}{\linewidth}{@{}>{$}l<{$} >{$}c<{$} >{$}c<{$} >{$}Y<{$} @{}}
      \toprule
      \BODY
      \bottomrule
    \end{tabularx}
    \caption{#1}
  \end{table}
}

\NewEnviron{eqntable}[1]{
  \begin{table*}[!t]
    \small
    \begin{tabularx}{\linewidth}{@{}>{$}l<{$} >{$}c<{$} >{$}c<{$} >{$}Y<{$} @{}}
      \toprule
      \BODY
      \bottomrule
    \end{tabularx}
    \caption{#1}
  \end{table*}
}

% The label, since we're including twice
\newcommand*{\lab}{}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

% Table caption set up
\DeclareCaptionFormat{hfillunittypet}{\hfill#1#2#3\par}
\DeclareCaptionFont{mdit}{\mdseries\itshape}
\captionsetup[table]{
  justification=centering,
  font=bf,
  labelfont=mdit,
}

\title{A parametricity-based formalization of semi-simplicial and semi-cubical sets}
\author{\IEEEauthorblockN{Hugo Herbelin \\ and Ramkumar Ramachandra}\\\IEEEauthorblockA{Université Paris Cité, Inria, CNRS, IRIF, Paris\\\texttt{Hugo.Herbelin@inria.fr} and \texttt{r@artagnon.com}}}

\begin{document}
\maketitle
\begin{abstract}
  Constructions such as semi-simplicial and semi-cubical sets can be defined in the ``usual way'' as presheaves over respectively, the semi-simplex or semi-cube category, which we call \emph{fibered} definitions, but also defined like in e.g. Voevodsky~\cite{voevodsky12} or in previous work~\cite{herbelin15}, as a dependently-typed construction, which we call \emph{indexed}.

  This paper describes a uniform indexed characterization of both augmented semi-simplicial and semi-cubical sets arising respectively as unary and binary iterated parametricity-based constructions.

  Additionally, our construction is fully formalized in Coq's dependent type theory.
\end{abstract}

\section{Introduction}
In the context of functional programming, Reynolds' parametricity~\cite{reynolds83} interprets types as relations characterizing the observational behavior of programs of this type. Parametricity can be iterated, and it has been noted that iterated Reynolds' parametricity can be interpreted in various cubical sets~\cite{johann17,altenkirch15,moulin16,moeneclaey21,moeneclaey22phd}. We obtain a \emph{unary} variant of Reynolds' \emph{binary} parametricity by using predicates or families instead of relations or graphs, in which case, we obtain a form of realizability~\cite{bernardy12,lasson12,moulin16}. It has then been noted that iterated unary parametricity has an augmented simplicial flavor~\footnote{Private communication with Hugo Moeneclaey and Thorsten Altenkirch}.

We exploit the connection between iterated unary parametricity and augmented simplicial sets, and between iterated binary parametricity and cubical sets to present a uniform construction of both augmented semi-simplicial and semi-cubical sets obtained by applying rules inspired from iterated parametricity. In contrast to the standard presheaf presentation of augmented semi-simplicial and semi-cubical sets~\cite{fri08,grandis03,buchholtz17}, our uniform construction, which we call \emph{$\nu$-sets}, is \emph{indexed}. That is, instead of having the set of augmented semi-simplices or semi-cubes in dimension $n+1$ \emph{fibered} over the set of augmented semi-simplices or semi-cubes in dimension $n$, we consider families of augmented semi-simplices and semi-cubes indexed over their faces.

The outline of the paper is as follows. We recall the definition of the augmented semi-simplicial and semi-cubical categories using a combinatorial presentation, that directly leads to our generalization to $\nu$-sets, in \ref{sec:nu}. We then proceed to explain our setting in \ref{sec:setting}. Before spelling out the details of our formalization in type-theoretic language in \ref{sec:itt}, we explain the connection between the indexed representation and parametricity in \ref{sec:indexed-param}, and build up intuitions in \ref{sec:intuition}. We end with some of the finer details of our mechanization in \ref{sec:mech}.

See \href{https://github.com/artagnon/bonak}{github.com/artagnon/bonak} for our mechanization. The construction was conceived in Summer 2019, and the mechanization began in late 2019. A sketch of the construction was presented at the 2020 HoTT-UF workshop and the completion of the mechanization was reported at the TYPES 2022 conference.

\section{Semi-simplicial and semi-cubical sets\label{sec:nu}}
\subsection{Augmented semi-simplicial sets}
Augmented semi-simplicial sets are defined similarly to semi-simplicial sets, except that the connected components are additionally dependent on a ``color''. Conversely, semi-simplicial sets can be seen as augmented semi-simplicial sets over a singleton set of colors.

Let us associate dimension $0$ to colors; then, points are dimension $1$, lines are dimension $2$, and so on. There is hence a shift by one when compared to semi-simplicial sets. We can then draw augmented semi-simplicial sets like semi-simplicial sets, except for this shift by one.

While ordinary semi-simplicial sets are presheaves over the semi-simplex category \DeltaHat, augmented semi-simplicial sets are presheaves over, what we will define as, \DeltaPlus. There are different ways to define \DeltaPlus, up to equivalence, and we use a definition that will later straightforwardly extend to semi-cubical sets.

\begin{notation}[Finite sequences]
  We denote finite sequences by $[i_1, \ldots i_n]$ for $i_j$ ranging over some domain. In particular, the empty sequence is written $[]$ and we define $i :: [j_1, \ldots, j_n]$ to be $[i, j_1, \ldots, j_n]$.
\end{notation}

\begin{definition}[$\DeltaPlus$]
  \begin{figure*}[!t]
    \begin{align*}
      \Obj(\DeltaPlus) & := \Nat                                                                     \\
      \Hom(p, n)       & := \{l \in [0, \kstar]^n \mid \text{number of $\kstar$ in $l = p$}\}        \\
      g \circ f        & :=
      \begin{cases}
        f                  & \text{if $g = []$}                                                        \\
        0 :: (g' \circ f)  & \text{if $g = (0 :: g')$}                                                 \\
        a :: (g' \circ f') & \text{if $g = (\star :: g')$, $f = (a :: f')$, where $a = 0$ or $\kstar$} \\
      \end{cases} \\
      \id              & := [\kstar, \ldots, \kstar] \text{ $n$ times for $\id \in \Hom(n, n)$}
    \end{align*}
    \caption{Definition of \DeltaPlus}\label{fig:deltaplus}
  \end{figure*}

  The definition of $\DeltaPlus$ is shown in Fig.~\ref{fig:deltaplus}. Note that, if $g \circ f$ is well-defined, then the length of $f$ is less than that of $g$. It can be shown that composition is associative and that $\id$ is neutral.
\end{definition}

\begin{definition}[$\Set_{\DeltaPlus}$]
  We define the category of augmented semi-simplicial sets as the functor category:
  \begin{equation*}
    \Set_{\DeltaPlus} := \Set^{\DeltaPlus^{\mathsf{op}}}
  \end{equation*}
\end{definition}

To provide examples, we define the standard augmented $n$-semi-simplex.

\begin{definition}[$\DeltaPlus^n$]
  The standard augmented $n$-semi-simplex $\DeltaPlus^n$ is defined as what is called the Yoneda embedding of $n \in \Obj(\DeltaPlus)$:
  \begin{align*}
    \DeltaPlus^n    & : \Set_{\DeltaPlus}        \\
    \DeltaPlus^n(p) & := \Hom(p, n)              \\
    \DeltaPlus^n(f) & := \lambda g .\, g \circ f
  \end{align*}
\end{definition}

The standard augmented $0$-semi-simplex is a singleton of one color. Standard augmented $n$-semi-simplices have a geometric interpretation, and we illustrate them for dimensions $1$, $2$, and $3$.

\begin{example}[$\DeltaPlus^1$]
  In dimension $1$, the standard augmented semi-simplex can be pictured as a point, colored black, corresponding to the unique morphism in $\Hom(0, 1)$. This point is the identity in $\Hom(1, 1)$; it is hence shown as a singleton $\kstar$.
  \begin{equation*}
    \begin{tikzcd}
      \kstar
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\DeltaPlus^2$]
  The standard augmented $2$-semi-simplex is drawn as two points, given by $\Hom(1, 2)$, along with a line connecting them, given by $\Hom(2, 2)$. We use the color black to denote the unique morphisms in $\Hom(0, 1)$ and $\Hom(0, 2)$.
  \begin{equation*}
    \begin{tikzcd}
      \kstar0 \arrow[r, dash, "\kstar\kstar"] & 0\kstar
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\DeltaPlus^3$]
  $\DeltaPlus^3$ is drawn as three points, given by $\Hom(1, 3)$, three lines connecting them, given by $\Hom(2, 3)$, and a triangular filler given by $\Hom(3, 3)$.
  \begin{equation*}
    \begin{tikzcd}
      & |[alias=F]|00\kstar \arrow[ddr, dash, "0\kstar\kstar"] & \\\\
      \kstar00 \arrow[rr, dash, "\kstar\kstar0"{name=T, below}]\arrow[uur, dash, "\kstar0\kstar"] && 0\kstar0 \\
      \arrow[rightarrow, from=F, to=T, phantom, "\kstar\kstar\kstar" description]
    \end{tikzcd}
  \end{equation*}
\end{example}

More generally, the standard augmented $(n + 1)$-semi-simplex can be obtained by taking a copy of the standard augmented $n$-semi-simplex serving as a base and gluing on top of it another copy lifted by one dimension. In the second copy, the color becomes an extra point, the points become lines connecting the points of the base to the extra point and so on. In particular, the components of the base are those of the standard augmented $n$-semi-simplex postfixed by $0$ while the components of the lifted copy are postfixed by~$\kstar$.

\subsection{Semi-cubical sets}
Semi-cubical sets are defined like augmented semi-simplicial sets except that $\DeltaPlus$ is replaced by $\Cube$ in which we take sequences of $L$, $R$ and $\star$, instead of sequences of $0$ and $\kstar$.

\begin{definition}[\Cube]
  The definition of $\Cube$ is shown in Fig.~\ref{fig:cube}. The symbols $L$ and $R$ indicate opposite faces of a cube.
  \begin{figure*}[!t]
    \begin{align*}
      \Obj(\Cube) & := \Nat                                                                                \\
      \Hom(p, n)  & := \{l \in [L, R, \kstar]^n \mid \text{number of $\kstar$ in $l = p$}\}                \\
      g \circ f   & :=
      \begin{cases}
        f                  & \text{if $g = []$}                                                              \\
        a :: (g' \circ f)  & \text{if $g = (a :: g')$}, \text{where $a = L$ or $R$}                          \\
        a :: (g' \circ f') & \text{if $g = (\star :: g')$, $f = (a :: f')$, where $a = L$, $R$, or $\kstar$} \\
      \end{cases} \\
      \id         & := [\kstar, \ldots, \kstar] \text{ $n$ times}
    \end{align*}
    \caption{Definition of \Cube}\label{fig:cube}
  \end{figure*}

  Again, if $g \circ f$ is well-defined, then the length of $f$ is less than that of $g$. It can be shown that composition is associative and that $\id$ is neutral.
\end{definition}

\begin{definition}[\CSet]
  We define the category of semi-cubical sets as the functor category:
  \begin{equation*}
    \CSet := \Set^{\op{\Cube}}
  \end{equation*}
\end{definition}

\begin{definition}[$\Cube^n$]
  The standard semi-cube $\Cube^n$ is defined as the Yoneda embedding of $n \in \Obj(\Cube)$:
  \begin{align*}
    \Cube^n    & : \CSet                    \\
    \Cube^n(p) & := \Hom(p, n)              \\
    \Cube^n(f) & := \lambda g .\, g \circ f
  \end{align*}
\end{definition}

Standard $n$-semi-cubes have a geometric interpretation, which we illustrate for dimensions $0$, $1$, and $2$.

\begin{example}[$\Cube^0$]
  $\Cube^0$ is $\Hom(0, 0)$, or the singleton set of the empty sequence:
  \begin{equation*}
    \begin{tikzcd}
      \{\}
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\Cube^1$]
  $\Cube^1$ consists of two points, given by $\Hom(0, 1)$ and a line, given by $\Hom(1, 1)$.
  \begin{equation*}
    \begin{tikzcd}
      L \arrow[r, "\kstar", dash] & R
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\Cube^2$]
  $\Cube^2$ consists of four points, given by $\Hom(0, 2)$, four lines connecting the four points, given by $\Hom(1, 2)$, and a filler, given by $\Hom(2, 2)$:
  \begin{equation*}
    \begin{tikzcd}
      LR \arrow[r, dash, "\kstar R"{name=F}] \arrow[d, dash, "L\kstar" left] & RR \arrow[d, dash, "R\kstar"] \\
      LL \arrow[r, dash, "\kstar L"{name=T, below}] & RL \\
      \arrow[rightarrow, from=F, to=T, phantom, "\kstar\kstar" description]
    \end{tikzcd}
  \end{equation*}
\end{example}

More generally, the standard $(n + 1)$-semi-cube can be obtained by taking two copies of the standard $n$-semi-cube serving as bottom and top face and connecting them on their border by a cylinder obtained as a third copy stretched in the new dimension. The bottom and top faces are obtained from the standard $n$-semi-cube by postfixing with respectively $L$ and $R$ while the cylinder is obtained by postfixing with $\kstar$.

\subsection{Generalization to \texorpdfstring{$\nu$}{ν}-sets}
Let us call $\nu$-sets, the generalization of augmented semi-simplicial sets and semi-cubical sets. To obtain this, we extend $\DeltaPlus$ and $\Cube$ in a straightforward manner into a category which we call $\nu$-semi-shape category. The morphisms of the $\nu$-semi-shape category are sequences of elements of a set $\nu$ of arbitrary cardinal, extended with $\kstar$, so that the following holds.

\begin{table}[H]
  \centering
  \begin{tabularx}{0.95\linewidth}{X|X|X}
    \toprule
    Value of $\nu$ & 1                               & 2                  \\
    \graymidrule
    Interpretation & Augmented semi-simplicial types & Semi-cubical types \\
    \bottomrule
  \end{tabularx}
\end{table}

A $\nu$-set is thus a contravariant functor $\phi$ from the $\nu$-semi-shape category to $\Set$ and we call $n$-$\nu$-semi-shape an element of $\phi(n)$. As in the augmented semi-simplicial and semi-cubical cases, the standard $(n + 1)$-$\nu$-semi-shape is obtained by connecting together $\nu$ copies of the standard $n$-$\nu$-semi-shape with an extra copy stretched in the new dimension. We clarify in the next sections how this process of construction is similar to the parametricity translation developed for functional programming~\cite{reynolds83} and more generally for type theory~\cite{bernardy10, bernardy11, atkey14, bernardy15}.

\section{Our setting\label{sec:setting}}
We now explain how we recover the notion of sets in type theory, explain the difference between the fibered and indexed representations, and supply an example of indexed semi-cubical sets.

\subsection{Working with sets in type theory}
Martin-Löf's Type theory~\cite{martinlof75,martinlof84} is a logical formalism based on the notion of a \emph{type} rather than that of a \emph{set}. It can be seen as a foundation of mathematics alternative to set theory and is the core of several tools for the formalization of mathematics such as Agda~\cite{agda23}, Coq~\cite{coq22} or Lean~\cite{lean15}. In type theory, propositions are types and proofs are programs. A particularity of type theory is also that types and programs, hence propositions and proofs also, are considered modulo an equational theory called definitional equality.

Type theory is a flexible formalism supporting different models. Some models are based on topological spaces, where equality is interpreted as path, and substitutivity of equality as transport~\cite{kapulkin21}. These models support the univalence principle stating that equality of types mimics equivalence of types, leading to the development of Homotopy Type Theory~\cite{hottbook}. In type theory, types are organized in a hierarchy of universes written $\Type_m$ for $m$ a natural number. Main types in type theory are the types of dependent pairs, written $\Sigma a : A.\,B(a)$, the types of dependent functions, written $\Pi a:A.\,B(a)$, for $A$ a type and $B(a)$ a type dependent on the inhabitant $a$ of $A$, and the type of propositional equality, written $t = u$. We assume our type theory to also include a distinguished singleton type, written $\unittype$, and with inhabitant $\unitpoint$, the type of boolean values, called $\textsf{bool}$, and the type of natural numbers. We also write $\hd$ and $\tl$ the projections of dependent pairs, and $\refl$ for reflexivity. Logical propositions being types themselves, we use $\Pi$ to represent universal quantification and $\Sigma$ to represent existential quantification.

A notion of sets can be recovered in each universe as $\U[m]$, denoting the subtype of $\Type_m$ for which paths are degenerated, what can be expressed by the property of Uniqueness of Identity Proofs (UIP). Technically, this is expressed as a structure equipping a domain $\Dom$ with the property $\UIP$:
\begin{align*}
  \Dom & : \Type_m                                  \\
  \UIP & : \Pi x y: \Dom.\, \Pi p q: x = y.\, p = q
\end{align*}

In $\U[m]$, the following properties hold:

\begin{enumerate}
  \item[(i)] UIP holds on the unit type, bool type, as well as all types of finite cardinal $\nu$.
  \item[(ii)] UIP propagates to $\Sigma$-types.
  \item[(iii)] UIP propagates to $\Pi$-types, with some additional functional extensionality axioms.
\end{enumerate}

Unless otherwise specified, we fix a universe level $m$ and abbreviate
$\Type_m$ as $\Type$ and $\U[m]$ as $\U$.

\subsection{Relating the indexed representation to parametricity\label{sec:indexed-param}}
% \begin{equation*}
%   \Sigma S: \U.\, S\rightarrow T ~\simeq~ T \rightarrow \U
% \end{equation*}

Let us now come back to semi-cubical sets. A semi-cubical set can be represented as a sequence of fibrations, together with appropriate coherence conditions.
\begin{equation*}
  \begin{tikzcd}
    X_0: \U & X_1: \U \arrow[l, "\delta^L" description, shift left=2] \arrow[l, "\delta^R" description, shift right=2] & X_2: \U \arrow[l, "\delta^{L\kstar}" description, shift left=6] \arrow[l, "\delta^{R\kstar}" description, shift left=2] \arrow[l, "\delta^{\kstar R}" description, shift right=2] \arrow[l, "\delta^{\kstar L}" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}

If we think of $X_1$ fibered over two copies of $X_0$ in an indexed way, we get $X_1$ of type $X_0 \rightarrow X_0 \rightarrow \U$. Continuing the process, we can think of $X_2$ fibered over four copies of $X_1$ themselves fibered over two copies of $X_0$ as a dependent type. We have a priori a dependency over eight copies of $X_0$ but these are actually four due to the coherence conditions. Based on these coherence conditions, the types of $X_0, X_1, X_2$ happen to have the form:
\begin{align*}
  X_0 & :              & \U                                                     \\
  X_1 & :              & X_0 \rightarrow X_0 \rightarrow \U                     \\
  X_2 & : \Pi a b c d. & X_1(a)(b) \rightarrow X_1(a)(c) \rightarrow X_1 (b)(d) \\
      &                & \rightarrow X_1 (c)(d) \rightarrow \U                  \\
  \ldots
\end{align*}

The process of construction of the type of $X_1$ from that of $X_0$, and from the type of $X_2$ to that of $X_1$ in the last section, is similar to applying a binary parametricity translation and expecting the resulting translation to be inhabited. The parametricity which we consider interprets a type $A$ by a graph $A_\kstar$ over this type, and a term $t: A$ as an edge in $A_\kstar(t)(t)$. In particular, $\U$ is interpreted as the graph ${\U}_\kstar$, which takes $A_L$ and $A_R$ in $\U$ and returns the type $A_L \rightarrow A_R \rightarrow \U$ of graphs over $A_L$ and $A_R$. Also, for $A$ interpreted by $A_\kstar$ and $B$ interpreted by $B_\kstar$, a dependent function type $\Pi a: A.\, B$ is interpreted as the graph $(\Pi a: A.\, B)_\kstar$ that takes two functions $f_L$ and $f_R$ of type $\Pi a: A.\, B$, and expresses that these functions map related arguments in $A$ to related arguments in $B$:
\begin{align*}
   & (\Pi a: A.\, B)_\kstar(f_L)(f_R) \defeq                                                      \\
   & \Pi a_L: A.\, \Pi a_R: A.\, \Pi a_\kstar: A_\kstar(a_L)(a_R).\, B_\kstar(f_L(a_L))(f_R(a_R))
\end{align*}

\begin{figure*}[!t]
  \begin{equation*}
    \begin{array}{ll}
      X_0                                : \underbrace{\unittype}_{\framep[0][0]}                                                    \rightarrow \U \\
      X_1                                : \underbrace{\Sigma \unitpoint: \unittype. \underbrace{\left(
      \begin{array}{c}
          \underbrace{X_0(\unitpoint)}_{\painting[0][0]}
          \\ \times \\
          \underbrace{X_0(\unitpoint)}_{\painting[0][0]}
        \end{array}\right)}_{\layer[1][0]}}_{\framep[1][1]} \rightarrow \U                                                                            \\
      X_2                                : \underbrace{\Sigma a: \underbrace{\left(\Sigma \unitpoint: \unittype. \underbrace{\left(
          \begin{array}{c}
            \underbrace{\Sigma b: \left(
            \hspace{-0.4em}\begin{array}{c}
                             X_0(\unitpoint)
                             \\ \times \\
                             X_0(\unitpoint)
                           \end{array}\hspace{-0.4em}
            \right).\, \underbrace{X_1 \underbrace{(\unitpoint, b)}_{\restrf[2][0][L]}}_{\painting[1][1]}}_{\painting[1][0]}
            \\ \times \\
            \underbrace{\Sigma b: \left(
            \hspace{-0.4em}\begin{array}{c}
                             X_0(\unitpoint)
                             \\ \times \\
                             X_0(\unitpoint)
                           \end{array}\hspace{-0.4em}
            \right).\, \underbrace{X_1 \underbrace{(\unitpoint, b)}_{\restrf[2][0][R]}}_{\painting[1][1]}}_{\painting[1][0]}
          \end{array}
          \right)}_{\layer[2][0]}\right)}_{\framep[2][1]}.\underbrace{\left(
        \begin{array}{c}
          \underbrace{X_1 \underbrace{\left(a.\hd, \left(
              \hspace{-0.4em}\begin{array}{c}
                               a.\tl.L.\hd.L, \\
                               a.\tl.R.\hd.L
                             \end{array}\hspace{-0.4em}
              \right)\right)}_{\restrf[2][1][L]}}_{\painting[1][1]}
          \\ \times \\
          \underbrace{X_1 \underbrace{\left(a.\hd, \left(
              \hspace{-0.4em}\begin{array}{c}
                               a.\tl.L.\hd.R, \\
                               a.\tl.R.\hd.R
                             \end{array}\hspace{-0.4em}
              \right)\right)}_{\restrf[2][1][R]}}_{\painting[1][1]}
        \end{array}
        \right)}_{\layer[2][1]}}_{\framep[2][2]}
      \rightarrow \U                                                                                                                                \\
      \ldots
    \end{array}
  \end{equation*}
  \caption{Intuition for formal construction ($\nu = 2$)}\label{fig:intuition}
\end{figure*}

In particular, for $X: \U$, applying the parametricity translation is about canonically associating to $X$ an inhabitant $X_\kstar$ of ${\U}_\kstar(X)(X)$ i.e. of $X \rightarrow X \rightarrow \U$. In turn, applying the parametricity translation to $X_\kstar: X \rightarrow X \rightarrow \U$ is about canonically associating to $X_\kstar$ an inhabitant $X_{\kstar\kstar}$ of $(X \rightarrow X \rightarrow \U)_\kstar(X_\kstar)(X_\kstar)$ i.e. of:
\begin{align*}
  \Pi x_{LL}: X.\, \Pi x_{LR}: X.\, X_\kstar(x_{LL})(x_{LR})             \\
  \rightarrow \Pi x_{RL}: X.\, \Pi x_{RR}: X.\, X_\kstar(x_{RL})(x_{RR}) \\ \rightarrow X_\kstar(x_{LL}, x_{RL}) \rightarrow X_\kstar(x_{LR})(x_{RR})  \rightarrow \U
\end{align*}
which hints us at how the sequence $X_0$, $X_1$, $X_2$ can be seen as a sequence of inhabitants of the iteration of binary parametricity applied to an initial $X: \U$:
\begin{equation*}
  \begin{array}{llllr}
    X_0 & \defeq & X                & : & \U                                               \\
    X_1 & \defeq & X_\kstar         & : & {\U}_\kstar(X)(X)                                \\
    X_2 & \defeq & X_{\kstar\kstar} & : & ({\U}_\kstar(X)(X))_{\kstar}(X_\kstar)(X_\kstar) \\
    \ldots
  \end{array}
\end{equation*}

This tells us how the informal type given to $X_2$ in the previous section could be rephrased so that it comes as the instance of a general recipe characterizing the type of all $X_i$.

Notice, however, that the recipe obtained so far, $X_{n + 1}: ({S_n})_\kstar(X_n)(X_n)$ for $X_n: S_n$, applies parametricity on the \emph{syntax} of the type of $X_n$. It does not directly yield a characterization of $S_n$ as a function from $n$. Reformulating the recipe as an explicit recursive construction, without requiring an interpretation of the syntax of types, is the main outcome of this work, together with the mechanization and the uniform treatment of augmented semi-simplicial and semi-cubical sets by means of the generalization to $\nu$-sets.

\section{Our construction}
In this section, we gradually build up an intuition for our construction, followed by the details.

\subsection{Intuition for our formal construction\label{sec:intuition}}
To assign types to $X_0, X_1, X_2, \ldots$ in the above indexed representation, we give a recursive definition relying on building blocks, which we call $\framep$, $\layer$, and $\painting$. A $\framep$ is a boundary of a standard form (simplex, cube, etc.), which we decompose into $\layer$, and a $\painting$ corresponds to a filled $\framep$. Some $\framep$ are full and we call them $\fullframe$.

We assign every $X_n$ the type $\fullframe[n] \rightarrow \U$ uniformly, applying to the description above the isomorphism between $A \rightarrow B \rightarrow C$ and $A \times B \rightarrow C$, or between $\Pi a: A.\, (B a \rightarrow C)$ and $(\Sigma a: A.\, B a) \rightarrow C$. Let us now illustrate how we build $\fullframe[n]$. To begin, let us set $\fullframe[0] = \unittype$, so that the type $\U$ of $X_0$ can be equivalently formulated as $\unittype \rightarrow \U$. Then, more generally, we let each $\fullframe[n]$ consist of $n$ layers, written $\layer[n][p]$ with $p < n$, that we stack in order, starting from the $\unittype$ type and writing $\framep[n][p]$ for the $p$ first layers of a $\fullframe[n]$, so that $\fullframe[n]$ is $\framep[n][n]$. For instance, $X_1$ is made of one layer, so that it can be written as a $\Sigma$-type of an inhabitant of the $\unittype$ and $\layer[1][0]$, as shown in Fig.~\ref{fig:intuition}. Fig.~\ref{fig:intuition} also mentions how the type of $X_2$ is structured.

Let us now illustrate the construction of $\fullframe[3]$, necessary to build the type of $X_3$.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=2]
    \draw[spanish-blue, fill=spanish-blue] (0, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- (0, 0);
    \draw[spanish-blue, fill=spanish-blue, nearly transparent] (0.6, 1) -- (0.6, 1.6) -- (1.6, 1.6) -- (1.6, 0.6) -- (1, 0.6);
  \end{tikzpicture}
  \;\;
  \begin{tikzpicture}[scale=2]
    \draw[spanish-blue, fill=spanish-blue] (0, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- (0, 0);
    \draw[spanish-blue, fill=spanish-blue, nearly transparent] (0.6, 1) -- (0.6, 1.6) -- (1.6, 1.6) -- (1.6, 0.6) -- (1.0, 0.6);
    \draw[raspeberry, pattern=dots] (1.1, 1.1) -- (1.5, 1.5) -- (1.5, 0.5) -- (1.1, 0.1) -- (1.1, 1.1);
    \draw[raspeberry] (1.3, 1.3) -- (1.3, 0.3);
    \draw[raspeberry, pattern=dots] (0.1, 1.1) -- (0.5, 1.5) -- (0.5, 1.1);
    \draw[raspeberry] (0.3, 1.3) -- (0.3, 1.1);
  \end{tikzpicture}
  \newline\newline
  \begin{tikzpicture}[scale=2]
    \draw[spanish-blue, fill=spanish-blue] (0, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- (0, 0);
    \draw[spanish-blue, fill=spanish-blue, nearly transparent] (0.6, 1) -- (0.6, 1.6) -- (1.6, 1.6) -- (1.6, 0.6) -- (1.0, 0.6);
    \draw[raspeberry, pattern=dots] (1.1, 1.1) -- (1.5, 1.5) -- (1.5, 0.5) -- (1.1, 0.1) -- (1.1, 1.1);
    \draw[raspeberry] (1.3, 1.3) -- (1.3, 0.3);
    \draw[raspeberry] (0.1, 1.1) -- (0.5, 1.5);
    \draw[russian-green, pattern=dots] (0.2, 1.1) -- (1.0, 1.1) -- (1.4, 1.5) -- (0.6, 1.5) -- (0.2, 1.1);
    \filldraw[russian-green] (0.8, 1.3) circle (0.6pt);
  \end{tikzpicture}
\end{figure}

The figure on the left is $\framep[3][1]$, on the right is $\framep[3][2]$, and on the bottom is $\framep[3][3]$, which is full. Further, $\framep[3][1]$ is made of one layer, $\layer[3][0]$, shown in blue, $\framep[3][2]$ is made of one additional layer, $\layer[3][1]$, shown in red, $\framep[3][3]$ is made of one more layer, $\layer[3][2]$, shown in green.

We illustrated here the cubical case, that is $\nu = 2$, but, in general, a $\layer[n][p]$ is a product of $\nu$ $\painting[n - 1][p]$. A $\painting[n][0]$ is a $n$-dimensional object corresponding to a filled $\fullframe[n]$. More generally, a $\painting[n][p]$ is an $n$-dimensional object which has the form of a $\painting[n-p][0]$, thus of $(n-p)$-dimensional form, but shifted and living in dimensions $p$ to $n$. Such $\painting[n][p]$ fills a space framed by a partial $\framep[n][p]$ so that, together, they form a filled $\fullframe[n]$. For instance, in the picture, each of the two $\painting[2][0]$ of $\layer[3][0]$ is a filled blue square, each of the two $\painting[2][1]$ of $\layer[3][1]$ is the line shown in red, stretched into a partial square filling the partial frames made of respectively the left and right border of the blue square, and each of the two $\painting[2][2]$ of $\layer[3][2]$ is a point shown in green, stretched into a partial square filling the full frames made respectively of the upper and lower borders of the blue and red squares. A $\painting[n][p]$ complements a $\framep[n][p]$ by adding layers needed to form a $\fullframe[n]$ and by filling the resulting $\fullframe[n]$ with an inhabitant of $X_n$. Layers are added from dimension $n$ to dimension $p$ that is opposite to the order from $0$ to $p$ the $\framep[n][p]$ are built, as shown below.
\begin{align*}
  \framep[n][p]   & \defeq \Sigma a_n: (\ldots (\Sigma \unitpoint: \unittype .\, \layer[n][0]) \ldots) .\, \layer[n][p] \\
  \painting[n][p] & \defeq \Sigma l_p: \layer[n][p]. (\ldots (\Sigma l_n: \layer[n][n - 1] .\, X_n) \ldots)
\end{align*}

So far, we have not paid attention to the fact that we have a dependent type, shown as a $\Sigma$. Let us be more precise about this requirement. First, $\fullframe[n]$ depends on all $X_i$ up to $n - 1$. So, we need to package up $X_i$, for $i < n$, into a type, which we call $\X[][<n][]$. This allows us to give the type $\X[][<n][] \rightarrow \U$ to $\fullframe[n]$. Then, for $D: \X[][<n][]$, representing an initial prefix of $X_0, X_1, \ldots X_{n - 1}$, the indexed set $X_n$ has type $\fullframe[n](D) \rightarrow \U$. Thus, $\framep[n][p]$, $\layer[n][p]$ and $\painting[n][p]$ also depend on $D$. We can then refine the previous equation by showing the dependencies on $D$. In particular, $X_n$ is just $D.\tl$.
\begin{align*}
   & \framep[n][p](D) \defeq                                                                                  \\
   & \;\;\;\;\Sigma a_n: (\ldots (\Sigma \unitpoint: \unittype.\, \layer[n][0](D)) \ldots) .\,\layer[n][p](D) \\
   & \painting[n][p](D) \defeq                                                                                \\
   & \;\;\;\;\Sigma l_p: \layer[n][p](D).\, (\ldots (\Sigma l_n: \layer[n][n - 1](D) .\, D.\tl) \ldots)
\end{align*}

\begin{figure*}[!t]
  \begin{align*}
    \framep[n][p](D)      & \defeq & \Sigma d: (\ldots (\Sigma \unitpoint: \unittype.\, \layer[n][0](D)(\unitpoint)) \ldots).\, \layer[n][p](D)(d)                                \\
    \painting[n][p](D)(d) & \defeq & \Sigma l_p: \layer[n][p](D)(d).\, (\ldots (\Sigma l_n: \layer[n][n - 1](D)(d, l_p, \ldots, l_{n - 1}).\, D.\tl(d, l_p, \ldots, l_n)) \ldots) \\
                          &        & \text{where } (d, l_p, \ldots, l_q) \text{ abbreviates } ((\ldots(d, l_p), \ldots), l_q)
  \end{align*}
  \caption{Refinement of definition of $\framep$ and $\painting$\label{fig:refinement}}
\end{figure*}

An extra refinement arises from the fact that each addition of a layer to a frame has to be glued onto the border of the partial frame built so far. So, each $\layer[n][p]$ has to depend on $\framep[n][p]$. We also need a way to characterize the border of the $\nu$ $\painting[n-1][p]$ that compose a $\layer[n][p]$, and this is $\restrf[n][p][\epsilon][p]$, for all $\epsilon < \nu$. For instance, on the picture, the left and right $\painting[2][1]$, shown in red, are laid on respectively the left and right borders of the blue boxes, and hence needs to depend on $\framep[3][1]$. The left and right borders of the two blue boxes are extracted as $\restrf[2][1][L](D)(d)$ and $\restrf[2][1][R](D)(d)$. We can then refine the previous equation by showing the dependencies on $d$, as shown in Fig.~\ref{fig:refinement}.

When $\nu = 2$, the formation of layers from paintings amounts to:
\begin{align*}
  \layer[n][p](D)(d) & \defeq & \painting[n-1][p](D.\hd)(\restrf[n][p][L][p](d)) & \times \\
                     &        & \painting[n-1][p](D.\hd)(\restrf[n][p][R][p](d)) &
\end{align*}

The operation $\restrf[n][p][\epsilon][q]$ indicates restriction on $q$ layers of a frame, and the induction is on $p$, from $0$ to $q$. In particular, $\restrf[n][p][\epsilon][p]$ is a ``full restriction''. We define $\restrf[n][p][\epsilon][p](d)$ by recursion on the structure of a frame $d$, which necessitates definitions of $\restrl[n][p][\epsilon][q](d)(l)$ and $\restrc[n][p][\epsilon][q](d)(c)$, for $l$ a $\layer$ and $c$ a $\painting$. The key case is $\restrc[n][p][\epsilon][p](d)(c)$, where $c$, a $\painting[n][p]$, has necessarily the form of $((c_L, c_R), \_)$: $\restrc[n][p][L][p]$ picks out $c_L$, a $\painting[n-1][p]$, $\restrc[n][p][R][p]$ picks out the $c_R$, also a $\painting[n-1][p]$, and $\_$, a $\painting[n][p+1]$, is discarded. There is one more difficulty, which we illustrate by writing down expected and actual types.

Given $c_\omega$ of type
\begin{align*}
  c_\omega & : \painting[n-1][p](D.\hd)(\restrf[n-1][p][\omega][q](d))
\end{align*}
$\restrl[n][p][\epsilon](d)(c_L, c_R)$ produces a layer, in which the $\omega$-component has the type
\begin{equation*}
  \painting[n-2][p](D.\hd.\hd)(\restrf[n-1][p][\epsilon][q](\restrf[n][p][\omega][p](d)))
\end{equation*}
while we expect a term of type
\begin{equation*}
  \painting[n-2][p](D.\hd.\hd)(\restrf[n-1][p][\omega][p](\restrf[n][p][\epsilon][q+1](d)))
\end{equation*}

Hence, we need a coherence condition to commute the restrictions. Coherence conditions similar to this necessitate, what are shown as, $\cohf$, $\cohl$ and $\cohc$ in tables in the next section. These are by induction on the structure of $\framep$, $\layer$ and $\painting$. Note that, for the construction in \ref{sec:itt}, we further need a $2$-dimensional coherence condition, $\coht$, for $\cohl$.

\subsection{Formal construction in ETT}
% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{painting}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrpainting}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohpainting}[D, d]

% Now, we write the type theory bit, and input the abbreviated tables

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and painting
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and painting
% Drop the universe letter
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
% Keep only ε, ω; n, p; proposition on n and p
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][][][][][#9]}

We now present the construction in \emph{extensional} type theory; i.e. in a type theory with the following reflection rule, where $=$ is propositional equality in some type and $\equiv$ is definitional equality~\cite{martinlof84}:
\begin{equation*}
  \seqr{}{\Gamma \vdash p: t = u}{\Gamma \vdash t \equiv u}
\end{equation*}

For the presentation corresponding to the formalization in \emph{intensional} type theory, see \ref{sec:itt}.

The definition is dispatched over tables \ref{tab:coind}, \ref{tab:core}, \ref{tab:frames}, \ref{tab:faces} and~\ref{tab:coh}. Table \ref{tab:coind} describes a $\nu$-set in indexed form, as a coinductive limit of $n$-truncated $\nu$-sets. The $n$-truncated $\nu$-sets are themselves described in \ref{tab:core}. The $n$th component is a family over a $\fullframe$. The type $\fullframe$ is recursively defined in \ref{tab:frames}, using the auxiliary definitions of $\layer$ and $\painting$. The type $\layer$ and $\painting$ are dependent over $\restrf$, and these restrictions are defined on \ref{tab:faces}. These restrictions are defined using auxiliary definitions of $\restrl$ and $\restrc$.

Notably, the definition of $\restrl$ relies on a definitional equality expressing the commutation of the composition of $\restrf$. This commutation is not provable by computation so we have to prove it propositionally before using the reflection rule. Proving this itself requires an induction on the dimension, and on the structure of $\framep$, $\layer$, and $\painting$. This is what $\cohf$ proves, as shown in the table \ref{tab:coh}, using auxiliary definitions $\cohl$ and $\cohc$. Even though it looks independent of the other tables, $\cohf$ has to be proved mutually with the definitions of $\framep$, $\layer$, $\painting$, and their corresponding restrictions. More precisely, for a fixed $n$, the block of $\framep$, $\restrf$, and $\cohf$ has to be mutually defined by induction on $p$. Also, each of $\painting$, $\restrc$, and $\cohc$ is built by induction from $p$ to $n$. The $\painting$ block at $n$ relies on the $\framep$ block at $n$, but, the converse dependency is only on lower $n$, so this is well-founded. Note that $\layer$, $\restrl$ and $\cohl$ are just abbreviations. We leave however implicit the exact way this mutual recursion can be formalized as this stage.

Most components of the construction takes inequality constraints as parameters, and we have left implicit that they are satisfied in the tables. Comparison of inequality proofs depends on the definition of inequality, which we leave implicit, only assuming that we can pick a definition for which proofs of $m \leq n$ are provably unique and thus definitionally equal by the reflection rule.

The construction takes benefit of various provable equalities over proofs of equality being definitional by the reflection rule. This includes in particular the groupoid properties of equality. Notably, uniqueness of identity proofs holds in extensional type theory, so that any type is automatically an $\U$. Also, we left implicit in table~\ref{tab:coh} the use of the isomorphism between $u = v$ and $\Sigma (p:u.\hd = v.\hd). (u.\tl = v.\tl)$ for $u$ and $v$ in a $\Sigma$-type. In the same table, we also left implicit the use of the isomorphism between $f = g$ and $\Pi a: A.\, f(a) = g(a)$ for $f$ and $g$ in $\Pi a: A.\, B$, where it should be recalled that the right-to-left map, that is function extensionality, holds by default in extensional type theory.

Note that for a fixed constant $n$, the coherence conditions evaluate to a reflexivity proof, so that the construction evaluates to an effective sequence of types of iterated relations not mentioning them anymore. For instance, it produces figure \ref{fig:intuition} for $n=2$ and $\nu=2$.

\renewcommand*{\lab}{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

\renewcommand*{\lab}{tab:core}
\input{tab-core.tex}

% Drop the universe letter in fullframe for all remaining tables
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[][#2][][][#3]}
\renewcommand*{\lab}{tab:frames}
\input{tab-frames.tex}

% Truncated sets, otherwise referred to as X
% Drop the universe letter for the third and fourth tables
\renewcommandx{\Xto}[3][3]{\X[][<#2][#3]}
\renewcommandx{\Xcomp}[3][3]{\X[][=#2][#3]}
\renewcommandx{\Xfrom}[3][3]{\X[][\geq#2][#3]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\renewcommand*{\lab}{tab:faces}
\input{tab-faces-ett.tex}

% Restriction for frame, layer, and painting
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Frame, layer, and painting
% Drop all arguments for coh table; they're not present in coind table.
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][][][][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][][][][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[][][][][#5]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

% Coherence conditions for frame, layer, and painting
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{tab:coh}
\input{tab-coh-ett.tex}

\subsection{Formal construction in ITT\label{sec:itt}}
\renewcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\renewcommandx{\cohl}{\coh{layer}[][][][][][][][]}

Since we have formalized the proof in the Coq proof assistant, which implements an intensional type theory, we now present the tables in \emph{intensional} type theory~\cite{martinlof84,coq22}, leaving implicit some details, which we will explain here, and other details, which we will explain in \ref{sec:mech}.

Tables \ref{fulltab:coind}, \ref{fulltab:core}, and \ref{fulltab:frames} are unchanged, except that we make explicit all arguments, including those that can be inferred from the context. The need for transport along a proof of commutation of $\restrf$ in the definition of $\restrl$ is made explicit as shown in table~\ref{fulltab:faces}, where the arrow over $\cohf$ indicates the direction of rewrite. The proof of $\cohf$ is described on~\ref{fulltab:coh}, and it requires making explicit several rewritings which were invisible in extensional type theory. The commutation of $\restrl$ lives in a type referring to $\cohf$, so we need a transport along the commutation of $\restrf$ in the statement of $\cohl$. The proof of $\cohl$ is the most involved proof in the construction. This is where the higher-dimensional coherence condition is needed. The exact formulation of this coherence condition is as follows.
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\begin{align*}
  \cohf[m][\omega][\theta][r][p][n][p][][d = {\restrf[m][\epsilon][q+2][n][p][][d = \d]}]\;\bullet     \\
  \ap \restrf[m][\omega][r][n][p][][]\;(\cohf[m][\epsilon][\theta][q+1][p][n][p][][d = \d])\;\bullet   \\
  \cohf[m][\epsilon][\omega][q][r][n][p][][d = {\restrf[m][\theta][p][n][p][][d = \d]}] =              \\
  \ap \restrf[m][\theta][p][n][p][][]\;(\cohf[m][\epsilon][\omega][q+1][r+1][n][p][][d = \d])\;\bullet \\
  \cohf[m][\epsilon][\theta][q][p][n][p][][d = {\restrf[m][\omega][r+1][n][p][][d = \d]}]\;\bullet     \\
  \ap \restrf[m][\epsilon][q][n][p][]\;(\cohf[m][\omega][\theta][r][p][n][p][][d = \d])
\end{align*}
where $\mathsf{ap}$ applies a function on two sides of an equality, and $\bullet$ is transitivity of equality. This property of equality proofs holds in \U, and since our formalization is done in \U, the term is trivially discharged.

\renewcommandx{\coht}{\cohtwo{frame}[][][][][][][][]}
\renewcommandx{\restrf}{\restr{frame}[][][][][][][]}
\renewcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\renewcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\renewcommandx{\cohc}{\coh{painting}[][][][][][][][]}

Notice that each $\restrl$ in the type of $\cohl$ is hiding a $\cohf$ rewrite: this makes a sum total of three $\cohf$ rewrites on the left-hand side, and two $\cohf$ rewrites on the right-hand side. In the proof term of $\cohl$, $\cohc$ has one $\cohf$ rewrite on its left-hand side and zero on the right-hand side. This combined with the two terms of the form $\ap \cohf$ matches our expectation of three $\cohf$ on the left-hand side and two $\cohf$ on the right-hand side. Then, $\coht$ can roughly be seen as a commutation of these $\cohf$ terms.

Finally, let us explain $\cohc$. The base case $p = r$ is the key case of the commutation of $\restrf$, when one of the $\restrc$ collapses, and the remaining equation holds trivially. The case of $p < r$ follows the structure of $\restrc$ by induction.

Like in \ref{tab:coh}, we leave implicit in \ref{fulltab:coh}, the use of the isomorphism between the type of equalities of dependent pairs in a $\Sigma$-type with the $\Sigma$-type of equalities of the components of the pair, as well as the isomorphism between equality of functions with point-wise equality. Contrary to the ETT case, functional extensionality does not hold, so we assume it. However, the requirement of functional extensionality disappears if $\nu$ is finite. As for basic groupoid properties of equalities, which no longer hold definitionally, we do not mention them for simplicity.

The way recursion is implemented is still left implicit at this stage. See \ref{sec:mech} for the details.

Depending on how inequality on natural numbers is defined, different equalities may hold or not definitionally, such as transitivity of inequality or the computational properties of induction over inequality proofs. Details are given in~\ref{sec:mech}.

Remark: If we were not working in \U, but in \HGpd, we would need to prove one more higher-dimensional coherence, and if we were working in \Type, we would need to prove arbitrarily many higher-dimensional coherences. Here, $\HGpd$ is the subset of types $A$ such that for all $x$ and $y$ in $A$, $x = y$ is in \U. See \cite{herbelin15,altenkirch16,kraus21} for a discussion on the need for recursive higher-dimensional coherence conditions in formulating higher-dimensional structures in type theory.

% Full tables in this section
%
% Clear the mask and label
\clearmask

% Keep all arguments for all macros
% Frame, layer, and painting
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[#1][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[#1][#2][#3][#4][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[#1][#2][#3][#4][#5]}
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

% Restriction for frame, layer, and painting
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{painting}[#1][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[#1][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{fulltab:coind}
\input{tab-coind.tex}
\renewcommand*{\lab}{fulltab:core}
\input{tab-core.tex}
\renewcommand*{\lab}{fulltab:frames}
\input{tab-frames.tex}

\begin{sidewaystable*}
  \renewcommand*{\lab}{fulltab:faces}
  \input{tab-faces.tex}
  \vspace{5em}
  \renewcommand*{\lab}{fulltab:coh}
  \input{tab-coh.tex}
\end{sidewaystable*}

\subsection{Details on the mechanization\label{sec:mech}}
\renewcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\renewcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\renewcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\renewcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrc}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\renewcommandx{\cohf}[1][1]{\coh{frame}[][][][][][#1][][]}
\renewcommandx{\cohl}[1][1]{\coh{layer}[][][][][][#1][][]}
\renewcommandx{\cohc}[1][1]{\coh{painting}[][][][][][#1][][]}

Since the construction shown in the previous sections is by induction on $n$, and dependencies are on lower $n$ and $p < n$, one would imagine formalizing this using well-founded induction in dependent type theory. We initially tried this approach: we had terms dependent on the proofs of the case distinction of $n' \leq n$ implies $n' < n$ or $n' = n$, and these proofs did not have definitional computational rule; it started to be necessary to reason propositionally on the computational property of the case distinction, and it eventually turned out to be unmanageable. Hence, we chose a different route: in practice, since $\restrf[n]$ depends on $\framep[n]$ and $\framep[n-1]$, while $\cohf[n]$ depends on $\framep[n]$, $\framep[n-1]$, and $\framep[n-2]$, we only need to keep track of three ``levels'', and we built separate data structures for the levels, with dependencies. More concretely, we build the ten definitions shown in the tables by induction, and this is part of the definition of a larger record. The other fields of the record are $\framep$, $\layer$, $\painting$ at levels $n - 1$ and $n - 2$, $\restrf$, $\restrl$, and $\restrc$ at level $n - 1$, and equations to recall the definitions of these objects at lower levels.

The entire construction relies on inequalities over natural numbers, and we use two different definitions of $\leq$ addressing different concerns in our formalization. In order to build our first variant, we present an intermediate ``recursive definition'', phrased as:

\begin{figure}[H]
  \begin{minted}{coq}
  Fixpoint leR (n m : nat) : SProp :=
  match n, m with
  | O, _ => STrue
  | S n, O => SFalse
  | S n, S m => leR n m
  end.
  \end{minted}
\end{figure}

Here $\SProp$ is a definitionally proof-irrelevant impredicative universe at the bottom of the universe hierarchy~\cite{gilbert19}. By placing the definition in \SProp, we have definitional equality of all inequality proofs. For the purpose of unification, however, this definition does not go far enough. Consider the unification problems:

\begin{figure}[H]
  \begin{minted}{coq}
  leR_trans ?p leR_refl = ?p
  leR_trans leR_refl ?p = ?p
  \end{minted}
\end{figure}
where \texttt{leR\_trans} is transitivity, \texttt{leR\_refl} is reflexivity, and \texttt{?p} is an existential variable. These two problems definitionally hold in \SProp, but equalizing them does not solve the existential. For unification to be useful in inferring existentials, we present our first variant of $\leq$, which we dub as the ``Yoneda variant'':

\begin{figure}[H]
  \begin{minted}{coq}
  Definition leY n m :=
    forall p, leR p n -> leR p m.
  \end{minted}
\end{figure}

This definition is an improvement over \texttt{leR} since reflexivity is now definitionally the neutral element of transitivity, and associativity of transitivity also holds definitionally. Although it significantly eases our proof, there are some instances where unification is unable to solve the existentials, and we have to provide them explicitly.

The second variant of $\leq$, the ``inductive variant'', is phrased as:

\begin{figure}[H]
  \begin{minted}{coq}
  Inductive leI : nat -> nat -> Type :=
  | leI_refl n : n <~ n
  | leI_down {n p} : p.+1 <~ n -> p <~ n
  where "n <~ m" := (leI n m) : nat_scope.
  \end{minted}
\end{figure}

Compared to \texttt{leY}, \texttt{leI} has no proof-irrelevance properties. This definition is specially crafted for $\painting$, where we have to reason inductively from $p \leq n$ to $n$. In our usage, we have lemmas \texttt{leY\_of\_leI} and \texttt{leI\_of\_leY} in order to equip \texttt{leY} with the induction scheme of \texttt{leI}. The resulting induction scheme has computational rules holding propositionally.

\section{Future work}
In the cubical case, we expect the construction to eventually provide a model of (some version of) parametric type theory~\cite{nuyts17,cavallo19} by adding degeneracies, a hierarchy of universes (as sketched e.g. in a talk by Herbelin at the HoTT-UF workshop for the bridge case~\cite{herbelin-hott-uf}), as well as reasoning modulo permutations~\cite{grandis03}.

By equipping the universe construction with a structure of equivalences, as suggested along the lines of Altenkirch and Kaposi~\cite{altenkirch15}, we expect the construction to be able to serve as a basis for syntactic models of various versions of cubical type theory~\cite{bezem13,cohen16,angiuli21}. A key point is that, thanks to the indexed approach, we expect univalence to hold by definition. If these intuitions are correct, this would definitively root cubical type theory on top of iterated parametricity translation.

\bibliographystyle{IEEEtran}
\bibliography{paper}

\end{document}
