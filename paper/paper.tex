\documentclass{msc}

\usepackage{amsmath, amssymb, mathrsfs, wasysym, tikz, tikz-cd, lmodern, mathpazo, anyfontsize, xargs, environ, multirow, tabularx, caption, bookmark, booktabs, makecell, colortbl, minted, art.cls/colorpal, art.cls/ct, art.cls/sset, art.cls/lim, art.cls/joinargs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[prefix=bonak]{art.cls/xkeymask}

% Use the patterns library to draw the cubes figure
\usetikzlibrary{patterns}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{painting}{D}{(#1)}
\define@cmdkey[bonak]{painting}{E}{(#1)}
\define@cmdkey[bonak]{painting}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrpainting}{D}{(#1)}
\define@cmdkey[bonak]{restrpainting}{E}{(#1)}
\define@cmdkey[bonak]{restrpainting}{d}{(#1)}
\define@cmdkey[bonak]{restrpainting}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohpainting}{D}{(#1)}
\define@cmdkey[bonak]{cohpainting}{E}{(#1)}
\define@cmdkey[bonak]{cohpainting}{d}{(#1)}
\define@cmdkey[bonak]{cohpainting}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \ensuremath{{\color{carolina}{\nu\textsf{Set}}}_{#1}^{#2}}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and painting: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and painting: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4]}^{\joinargs[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

% Coherence conditions for frame, layer, and painting: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaHat}{\ensuremath{\hat{\boldsymbol{\Delta}}}}
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}{\ensuremath{\boldsymbol{{\square}}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommandx{\U}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HSet}}_{#1}}}
\newcommandx{\HGpd}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HGpd}}_{#1}}}
\newcommand{\Type}{\ensuremath{\mathsf{\color{spanish-blue}{Type}}}}
\newcommand{\SProp}{\ensuremath{\mathsf{\color{spanish-blue}{SProp}}}}

% Examples
\newtheorem{example}[therm]{Example}

% The unit and bool types
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\booltype}{\ensuremath{\mathsf{bool}}}
\newcommand{\unitpoint}{\ensuremath{\ast}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\refl}{\ensuremath{\mathsf{refl}}}

% Some abbreviations
\newcommand{\tl}{\ensuremath{\mathsf{tl}}}
\newcommand{\hd}{\ensuremath{\mathsf{hd}}}
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\newcommand{\ap}{\mathsf{ap}\;}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommand{\Dom}{\textsf{Dom}}
\newcommand{\UIP}{\textsf{UIP}}

\newcommand{\udensdash}[1]{%
    \tikz[baseline=(todotted.base)]{
        \node[inner sep=1pt,outer sep=0pt] (todotted) {$#1$};
        \draw[densely dashed] (todotted.south west) -- (todotted.south east);
    }%
}%

% These are renewed in tables, but let's define them now for in-document
% typesetting
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\newcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\newcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\newcommandx{\restrp}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\newcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\newcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\newcommandx{\cohp}{\coh{painting}[][][][][][][][]}
\newcommandx{\fullframe}[1][1]{\prim{fullframe}[][#1][][][]}

\newcommandx{\frametype}[2][1,2]{\prim{frametype}[][#1][#2][][]}
\newcommandx{\layertype}[2][1,2]{\prim{layertype}[][#1][#2][][]}
\newcommandx{\paintingtype}[2][1,2]{\prim{paintingtype}[][#1][#2][][]}
\newcommandx{\restrftype}[2][1,2]{\prim{restrftype}[][#1][#2][][]}
\newcommandx{\restrltype}[2][1,2]{\prim{restrltype}[][#1][#2][][]}
\newcommandx{\restrptype}[2][1,2]{\prim{restrptype}[][#1][#2][][]}
\newcommandx{\cohftype}[2][1,2]{\prim{cohftype}[][#1][#2][][]}
\newcommandx{\cohltype}[2][1,2]{\prim{cohltype}[][#1][#2][][]}
\newcommandx{\cohptype}[2][1,2]{\prim{cohptype}[][#1][#2][][]}
\newcommandx{\cohttype}[2][1,2]{\prim{cohttype}[][#1][#2][][]}

\newcommandx{\deps}[2][1,2]{\prim{deps}[][#1][#2][][]}
\newcommandx{\extradeps}[2][1,2]{\prim{deps}[][#1][#2][][]}
\newcommandx{\depscohs}[2][1,2]{\prim{depscohs}[][#1][#2][][]}
\newcommandx{\extradepscohs}[2][1,2]{\prim{depscohs}[][#1][#2][][]}
\newcommandx{\depstype}[2][1,2]{\prim{depstype}[][#1][#2][][]}
\newcommandx{\extradepstype}[2][1,2]{\prim{depstype}[][#1][#2][][]}
\newcommandx{\depscohstype}[2][1,2]{\prim{depscohstype}[][#1][#2][][]}
\newcommandx{\extradepscohstype}[2][1,2]{\prim{depscohstype}[][#1][#2][][]}

\newcommandx{\coht}[6][1,2,3,4,5,6]{\cohtwo{frame}[][#3][#4][#5][#6][#1,#2][][]}

% For typesetting type theory rules
\newcommand \seqr[3]
  {\shortstack{$#2$ \\ \mbox{}\\
                   \mbox{}\hrulefill\mbox{}\\ \mbox{}\\ $#3$} \raisebox{2ex}{$\;\;\mbox{$#1$}$}}

% Kerning for star
\newcommand{\kstar}{{\star}}

% Caption setup
\DeclareCaptionFormat{plain}{#1#3}
\captionsetup{font=footnotesize,labelfont=bf}

% The eqntable environment
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{eqntable}[1]{
  \fontsize{7.2}{9}\selectfont
  \begin{tabularx}{0.94\linewidth}{
    @{}
    >{$}l<{$}
    >{$}c<{$}
    >{$}c<{$}
    >{$}Y<{$}
    @{}}
    \toprule
    \BODY
    \bottomrule
  \end{tabularx}
  \captionof{table}{#1}
}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

% Double-spacing
% \linespread{2}

\begin{document}
\title{On the specific recursive structure of iterated parametricity}
\begin{authgrp}
  \author{Hugo Herbelin}
  \affiliation{Université Paris Cité, Inria, CNRS, IRIF, Paris
    \email{Hugo.Herbelin@inria.fr}}
  \author{Ramkumar Ramachandra}
  \affiliation{Unaffiliated \email{r@artagnon.com}}
\end{authgrp}
\begin{abstract}
  In a previous paper, we gave equations describing the construction of semi-simplicial and semi-cubical sets via iterated parametricity. The construction was formalised in the Rocq (formerly, Coq) proof assistant building $n$-truncated sets using an induction on a large structure embedding equational reasoning.

  The current paper describes a new and lighter presentation of the construction where equational reasoning is replaced by definition. Being lighter, it can now be described in full details, closely following the corresponding new machine-checked formalisation.
\end{abstract}
\maketitle
\vspace{-2em} % Remove space after abstract

\section{Introduction}
In the previous paper~\citep{hr25}, we described the construction of augmented semi-simplicial and semi-cubical sets in \emph{indexed form} as a special case of iterated parametricity, meaning that instead of the following illustration of the cubical case (upto faces identities),

\begin{equation*}
  \begin{tikzcd}
    X_0: \U & X_1: \U \arrow[l, "\partial^L" description, shift left=2] \arrow[l, "\partial^R" description, shift right=2] & X_2: \U \arrow[l, "\partial^{L\kstar}" description, shift left=6] \arrow[l, "\partial^{R\kstar}" description, shift left=2] \arrow[l, "\partial^{\kstar L}" description, shift right=2] \arrow[l, "\partial^{\kstar R}" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}
we consider a family of families as shown below:
\begin{equation*}
  \begin{array}{lll}
    X_0 & :               \U                                                                          \\
    X_1 & :               X_0 \times X_0 \rightarrow  \U                                              \\
    X_2 & : \Pi a b c d.\,  X_1(a,b) \times X_1 (c,d) \times X_1(a,c) \times X_1 (b,d) \rightarrow \U \\
    \ldots
  \end{array}
\end{equation*}

% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{painting}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrpainting}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohpainting}[D, d]

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and painting
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and painting
% Drop the universe letter
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrp}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
% Keep only ε, ω; n, p; proposition on n and p
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\renewcommandx{\cohp}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][][][][][#9]}

A $\nu$-set in indexed form is a sequence of families of $\U$, that is $\U[m]$ for some universe level $m$. We call such sequence a $\nu$-set at level $m$, whose type thus lives in $\U[m+1]$.

Table~\ref{tab:coind} describes the type of a $\nu$-set at level $m$ as a dependent stream of type families representing the limit of $n$-truncated $\nu$-sets: the recursive equation $\Xfrom{m}{n}{D} \,\defeq\, \Sigma R: \Xcomp{m}{n}[D=\D].\, \Xfrom{m}{n+1}[D=\pair{D}{R}]$ from the table formally corresponds to the stream $Stream_{\Sigma n.\, \Xto{m}{n},\, \lambda (n, \D).\, \Xcomp{m}{n}[D=\D],\,\lambda ((n, D),R).(n+1,(\pair{D}{R}))}(n, \D)$. Therefore, $\Xfrom{m}{n}$ denotes an infinite sequence $X_{n}, X_{n+1}, \ldots$ dependent on a $(<n)$-truncated $\nu$-set, $\Xto{m}{n}$, so that, when $n$ is $0$, it denotes a full $\nu$-set, written $\Xp{m}$. This is made possible because the $(<0)$-truncated $\nu$-set, $\Xto{m}{0}$, is degenerated: it is an empty family, and there is thus only one $(<0)$-truncated $\nu$-set, namely the canonical inhabitant $\kstar$ of $\unittype$.

The definition of the type of a $n$-truncated $\nu$-set is in turn described in table~\ref{tab:core}. In the infinite sequence of type families representing a $\nu$-set, the $n$-th component is a type dependent over a $\fullframe$. It is recursively defined in table~\ref{tab:frames}, using the auxiliary definitions of $\framep$, $\layer$ and $\painting$. A $\fullframe$ describes a boundary of a standard form (simplex, cube), which we decompose into $\layer$, and a $\painting$ corresponds to a filled frame. Notice that the type $\layer$ relies on an operator of frame restriction $\restrf$ which is defined in table~\ref{tab:faces}, and this restriction operator is in turn defined using auxiliary definitions $\restrl$ and $\restrp$.

Notably, the definition of $\restrl$ relies on an equality expressing the commutation of the composition of two $\restrf$. The proof of this commutation is worth being made explicit, which we do in table~\ref{tab:coh} using proof-term notations. The proof requires an induction on the dimension and on the structure of $\framep$, $\layer$, and $\painting$. This is what $\cohf$ does using auxiliary proofs $\cohl$ and $\cohp$. Even though it looks independent of the definitions from the other tables, $\cohf$ has to be proved mutually with the definitions of $\framep$, $\layer$, $\painting$, and their corresponding restrictions. More precisely, for a fixed $n$, the block of $\framep$, $\restrf$, and $\cohf$ has to be defined in one go by induction on $p$. Also, each of $\painting$, $\restrp$, and $\cohp$ is built by induction from $p$ to $n$. The $\painting$ block at $n$ relies on the $\framep$ block at $n$, but the converse dependency is only on lower $n$, so this is well-founded. Note that $\layer$, $\restrl$ and $\cohl$ are just abbreviations.

Note that for a fixed constant $n$, relying on the evaluation rules of type theory, the coherence conditions degenerate to a reflexivity proof, so that the construction builds an effective sequence of types not mentioning coherences anymore. \\

\def\lab{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

\def\lab{tab:core}
\input{tab-core.tex}

\def\lab{tab:frames}
\input{tab-frames.tex}

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\def\lab{tab:faces}
\input{tab-faces-ett.tex}

% Restriction for frame, layer, and painting
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrp}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohp}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][#4][#5][#6,#7][#8][#9]}

\def\lab{tab:coh}
\input{tab-coh-ett.tex}

\renewcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\renewcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\renewcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\renewcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrp}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#4][][]}
\renewcommandx{\cohf}[6][1,2,3,4,5,6]{\coh{frame}[][#3][#4][#5][#6][#1,#2][][]}
\renewcommandx{\cohl}[6][1,2,3,4,5,6]{\coh{layer}[][#3][#4][#5][#6][#1,#2][][]}
\renewcommandx{\cohp}[6][1,2,3,4,5,6]{\coh{painting}[][#3][#4][#5][#6][#1,#2][][]}

In \citep{hr25}, the well-foundedness was justified by induction on $n$ and subinductions, one on $p$ to mutually build $\framep[n][p]$, $\restrf[n][p]$ and $\cohf[n][p]$, and three others to build each of $\painting[n][p]$, $\restrp[n][p]$ and $\cohp[n][p]$ by induction on $n-p$.

Since $\restrf[n][p]$ is referring to $\framep[n][p]$ and $\framep[n-1][p]$, and $\cohf[n][p]$ is referring to $\restrf[n][p]$ and $\restrf[n-1][p]$, thus also to $\framep[n][p]$, $\framep[n-1][p]$ and $\framep[n-2][p]$, we built all of these 6 components at the same time. But equations were also needed to state the properties of $\framep[n][p]$, $\framep[n-1][p]$ and $\restrf[n][p]$ so that we were building by induction on $n+p$ (that is on $n$, using the convention of \citep{hr25}) the following block of information:

\begin{align*}
  \framep[n][p]      & : \U                                                                                                                 \\
  \framep[n-1][p]    & :  \U                                                                                                                \\
  \framep[n-2][p]    & : \U                                                                                                                 \\
  \restrf[n][p]      & : \Pi q.\, \Pi \omega.\, \framep[n][p] \rightarrow \framep[n-1][p]                                                   \\
  \restrf[n-1][p]    & : \Pi q.\, \Pi \omega.\, \framep[n-1][p] \rightarrow \framep[n-2][p]                                                 \\                                                                 \\
  \cohf[n][p]        & : \Pi qr\epsilon\omega.\, \restrf[n-1][p][\epsilon][q] \circ \restrf[n][p][\omega][r] =                              \\
                     & \;\;\;\;\restrf[n-1][p][\omega][r] \circ \restrf[n][p][\epsilon][q+1]                                                \\
  \mathsf{hypF0}     & : \framep[n][0]         = \unitpoint
  \\
  \mathsf{hypFS0}    & : \framep[n][p+1]       = \Sigma d: \framep[n+1][p]. \Pi \omega.\, \painting[n][p] (\restrf[n+1][p](d))              \\
  \mathsf{hypPrevF}  & : \framep[n-1][0]                                                                                       = \unitpoint \\
  \mathsf{hypPrevFS} & : \framep[n-1][p+1] = \Sigma d: \framep[n][p]. \Pi \omega.\, \painting[n-1][p] (\restrf[n][p](d))                    \\
  \mathsf{hypRF0}    & : \restrf[n][0]        = \ldots \texttt{depending on hypF0}                                                          \\
  \mathsf{hypRFS}    & : \restrf[n][p+1]      = \ldots \texttt{depending on hypFS and hypPrevFS}                                            \\
  \ldots             & \;\;\;\;\texttt{fields for painting, restrf, cohp}
\end{align*}

In the current paper and associated formalisation, we replace the equational properties by definitions, building instead by induction a block of the form:

\begin{align*}
  \framep[n-2][p] & : \U                                                                                    \\
  \restrf[n-1][p] & : \Pi q \leq n+p.\, \framep[n-1][p] \rightarrow \framep[n-2][p]                         \\
  \cohf[n][p]     & : \Pi qr\epsilon\omega.\, \restrf[n-1][p][\epsilon][q] \circ \restrf[n][p][\omega][r] = \\
                  & \;\;\;\;\restrf[n-1][p][\omega][r] \circ \restrf[n][p][\epsilon][q+1]                   \\
  \ldots          & \;\;\;\;\texttt{fields for painting, restrf, cohp}
\end{align*}
where $\framep[n][p]$, $\framep[n-1][p]$ and $\restrf[n][p]$ are now appropriate definitions.

Turning $\framep[n][p]$, $\framep[n-1][p]$ and $\restrf[n][p]$ into definitions is however tricky: the definition of $\framep[n-1][p]$, which is by induction on $p$ (for all $n$), depends on $\restrf[n-1][p]$ whose type depends on $\framep[n][p-1]$. This means that $\framep[n-1][p]$ and the type of $\restrf[n-1][p]$ have to be mutually defined.

The well-foundedness of the construction can be justified by the observation that:

Defining $\framep[n][p]$ for $p \leq n$ requires the definition of $\painting[n-1][p-1]$, thus also $\framep[n-1][p-1]$ by typing dependency, as well as $\restrf[n][p-1]$, where $\restrf[n][p-1]$ in turn depends in $\framep[n][p-1]$ for its typing.

Moreover, $\framep[n][p]$ depends on $\framep[n][p-1]$, so these dependencies are between the blocks of $\framep[n][k]$ for all $k\leq p$, as well as $\framep[n-1][k]$, $\painting[n-1][k]$ and $\restrf[n][k]$ for all $k\leq p-1$, which we respectively abbreviate as $\framep[n][0,...,p]$, $\framep[n-1][0,...,p-1]$, $\painting[n-1][0,...,p-1]$ and $\restrf[n][0,...,p-1]$.

Also, $\restrf[n][p-1]$ depends on $n$.

Schematically, using dotted arrows for dependencies in the type and plain arrows for dependencies in the definition, this gives the following dependencies for $p\leq n$ fixed:
\begin{center}
  \fontsize{7.2}{9}\selectfont
  \begin{tikzcd}
    \framep[n][0,...,p] \arrow[d] \arrow[ddr]\\
    \painting[n-1][0,...,p-1] \arrow[d, dotted] \\
    \framep[n-1][0,...,p-1] &
    \restrf[n][0,...,p-1] \arrow[l, dotted] \arrow[uul, dotted, "\mbox{$[0,...,p-1]$}"', near start, shift right=2mm, hook']\\
  \end{tikzcd}
\end{center}

In particular, the mutual dependency on one side of $\framep[n][0,...,p-1]$ within the type of $\restrf[n][0,...,p-1]$ and on the other side of $\restrf[n][0,...,p-1]$ within the definition of $\framep[n][0,...,p]$ requires to mutually define the type of $\restrf[n][0,...,p-1]$ together with $\framep[n][p]$ (or $\framep[n][0,...,p]$) as a function from $\restrf[n][0,...,p-1]$.

To talk about sequences of $\framep$, $\painting$ or $\restrf$, we need to specify their types. The type of $\restrf$ will be defined mutually with $\framep$ of the same level, but the type of $\framep$, $\painting$ can be defined in advance, the second one being however dependent on the first one. In general, components of such sequences will have a type dependent on the previous components of the sequence, as it is the case for $\restrf$. So, the type of a sequence of length $p$ will be expressed as a $n$-iterated $\Sigma$-type. In the case of $\framep$ and $\painting$, there will be however no dependency, so an ordinary product can be used. If $\framep[n][0,...,p]$ is such a sequence of length $p+1$, we write $\framep[n][0,...,p-1]$ for its immediate subsequence of length $p$ and $\framep[n][p]$ for its last component. We can now define the types of sequences of $\framep$ and $\painting$ as follows:

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \frametype[n][0,...,p]    &                                              & :      & Type_{l+1}                                                                                       \\
    \frametype[n][]           &                                              & \defeq & \unittype                                                                                        \\
    \frametype[n][0,...,p]    &                                              & \defeq & \frametype[n+1][0,...,p-1] \times Type_l                                                         \\
    \\
    \paintingtype[n][0,...,p] & (\framep[n][0,...,p]:\frametype[n][0,...,p]) & :      & Type_{l+1}                                                                                       \\
    \paintingtype[n][]        & \unitpoint                                   & \defeq & \unittype                                                                                        \\
    \paintingtype[n][0,...,p] & (\framep[n][0,...,p])                        & \defeq & \paintingtype[n+1][0,...,p-1](\framep[n+1][0,...,p-1]) \times (\framep[n][p] \rightarrow Type_l) \\
    \layertype[n][p]          & \framep[n][p]                                & :      & Type_{l+1}                                                                                       \\
  \end{array}
\end{equation*}

Formally, this can be described as:
\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \framep[n][0,...,p]           &
    \multicolumn{3}{l}{
      \left(\begin{array}{l}
                \framep[n][0,...,p-1]:\frametype[n][0,...,p-1]                             \\
                \painting[n][0,...,p-1]:\paintingtype[n][0,...,p-1](\framep[n][0,...,p-1]) \\
                \restrf[n][0,...,p-1]:\restrftype[n][0,...,p-1]
                \left(\begin{array}{l}
                    \framep[n][0,...,p-1]   \\
                    \painting[n][0,...,p-1] \\
                  \end{array}\right)                                              \\
              \end{array}\right) : \frametype[n][0,...,p]
    }                                                                  \\
    \framep[n][0]                 &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)        & \defeq & (\unitpoint,unit)       \\
    \framep[n][0,...,p+1]         &
    \left(\begin{array}{l}
              \framep[n][0,...,p]   \\
              \painting[n][0,...,p] \\
              \restrf[n][0,...,p]   \\
            \end{array}\right)      & \defeq &
    \left(\begin{array}{l}
              \framep[n+1][0,...,p]
              \left(\begin{array}{l}
                  \framep[n+1][0,...,p-1]   \\
                  \painting[n+1][0,...,p-1] \\
                  \restrf[n+1][0,...,p-1]   \\
                \end{array}\right), \\
              \Sigma d:\framep[n+1][0,...,p]
              \left(\begin{array}{l}
                  \framep[n+1][0,...,p-1]   \\
                  \painting[n+1][0,...,p-1] \\
                  \restrf[n+1][0,...,p-1]   \\
                \end{array}\right).\, \\
              \quad \layer[n][p]
              \left(\begin{array}{l}
                  \framep[n+1][0,...,p-1]   \\
                  \painting[n+1][0,...,p-1] \\
                  \restrf[n+1][0,...,p-1]   \\
                \end{array}\right) \\
            \end{array}\right)                   \\
    \restrftype[n][0,...,p-1]     &
    \multicolumn{3}{l}{
      \left(\begin{array}{l}
                \framep[n][0,...,p-1]:\frametype[n][0,...,p-1]                             \\
                \painting[n][0,...,p-1]:\paintingtype[n][0,...,p-1](\framep[n][0,...,p-1]) \\
              \end{array}\right) : Type_{l}
    }                                                                  \\
    \restrftype[n][0,...,0-1]     &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)        & \defeq &
    \unittype                                                          \\
    \restrftype[n][0,...,(p+1)-1] &
    \left(\begin{array}{l}
              \framep[n][0,...,p]   \\
              \painting[n][0,...,p] \\
            \end{array}\right)      & \defeq &
    \begin{array}{l}
      \Sigma \restrf[n+1][0,...,p-1]
      :\restrftype[n+1][0,...,p-1]
      \left(\begin{array}{l}
                \framep[n+1][0,...,p-1]   \\
                \painting[n+1][0,...,p-1] \\
              \end{array}\right)                         .  \\
      \Pi q\leq n.\,\Pi \omega.\,\framep[n+1][p]
      \left(\begin{array}{l}
                \framep[n+1][0,...,p-1]   \\
                \painting[n+1][0,...,p-1] \\
                \restrf[n+1][0,...,p-1]   \\
              \end{array}\right) \rightarrow  \framep[n][p] \\
    \end{array} \\
    \layer[n][p]                  &
    \left(\begin{array}{l}
              \framep[n][0,...,p]     \\
              \painting[n][0,...,p]   \\
              \restrf[n+1][0,...,p-1] \\
            \end{array}\right)    & \defeq &
    \Pi\omega.\,\painting[n][p](\restrf[n][p](d))
  \end{array}
\end{equation*}

At this stage, it is convenient to use an abbreviation to combine sequences $\framep[n][0,..,p-1]$, $\painting[n][0,...,p-1]$ and $\restrf[n][0,...,p-1]$ in one block, which we call $\deps[n][0,...p-1]$:

\begin{align*}
  \deps[n][0,..,p-1] \defeq
  \left(\begin{array}{l}
            \framep[n][0,...,p-1] :\frametype[n][0,...,p-1] \\
            \painting[n][0,...,p-1] :\paintingtype[n][0,...,p-1]
            (\framep[n][0,...,p-1])                         \\
            \restrf[n][0,...,p-1]  :\restrftype[n][0,...,p-1]
            \left(\begin{array}{l}
                \framep[n][0,...,p-1]   \\
                \painting[n][0,...,p-1] \\
              \end{array}\right)                   \\
          \end{array}\right)
\end{align*}
so that $\framep[n][0,...,p]$ has type $\deps[n][0,..,p-1] \rightarrow \frametype[n][0,...,p]$. Later, we shall write $\deps.\framep$, $\deps.\painting$, $\deps.\restrf$ for the corresponding projections of a $\deps$.

Defining $\painting[n][p]$, in addition to the type dependency in $\framep[n][p]$, requires the definition of $\painting[n-1][p-1]$, thus also $\framep[n-1][p-1]$ by typing dependency, as well as $\restrf[n][p-1]$. Since $\painting[n][p]$ also depends on $\painting[n][p+1]$ when $p<n$, these dependencies are actually between $\painting[n][p,...,n]$, $\painting[n-1][p,...,n-1]$, $\framep[n][p,...,n]$, $\framep[n-1][p,...,n-1]$ and $\restrf[n][p,...,n]$. Also, for the case $p=n$, this also requires the assumption of an inhabitant $X_{n}$ of $\nu$Set$^{=n}$. Finally, $\framep[n][p,...,n]$, $\framep[n-1][p,...,n-1]$ and $\restrf[n][p,...,n-1]$ respectively depend on the earlier values $\framep[n][0,...,p-1]$, $\framep[n-1][0,...,p-1]$ and $\restrf[n][0,...,p-1]$.  Below, we use dashed underline and dashed arrows for dependencies in subconstructions, here in the construction of $\framep$ at level $n-1$ and $\restrftype$ at level $n$:
\begin{center}
  \fontsize{7.2}{9}\selectfont
  \begin{tikzcd}
    & & \painting[n][p,...,n] \arrow[dd, bend right=70] \arrow[dddr] \arrow[d, dotted]\\
    \udensdash{\framep[n][0,...,p-1]} \arrow[d, dashed] \arrow[ddr, dashed] & &
    \udensdash{\framep[n][p,...,n]} \arrow[ll, dotted] \arrow[d, dashed] \arrow[ddr, dashed, shift right=2mm] \\
    \painting[n-1][0,...,p-1] \arrow[d, dotted] & &
    \painting[n-1][p,...,n-1] \arrow[ll, dotted] \arrow[d, dotted] \\
    \framep[n-1][0,...,p-1] &
    \udensdash{\restrf[n][0,...,p-1]} \arrow[l, dotted] \arrow[uul, dotted, shift right=2mm, hook'] &
    \framep[n-1][p,...,n-1] \arrow[ll, dotted, bend left=15] &
    \udensdash{\restrf[n][p,...,n-1]},X_n \arrow[ll, dotted, bend left=15] \arrow[l, dotted] \arrow[uul, dotted, hook']\\
  \end{tikzcd}
\end{center}

To define $\painting$ formally, we need to define $\framep[n][p,...,n]$, $\painting[n][p,...,n]$ and $\restrf[n][p,...,n]$:

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \frametype[n][p,...,n]         &                                              & :         & Type_{l+1}                                                                                   \\
    \frametype[n][]                &                                              & \defeq    & \unittype                                                                                    \\
    \frametype[n][p,...,n]         &                                              & \defeq    & Type_l \times \frametype[n][p+1,...,n-1]                                                     \\
    \\
    \paintingtype[n][p,...,n]      & (\framep[n][p,...,n]:\frametype[n][p,...,n]) & :         & Type_{l+1}                                                                                   \\
    \paintingtype[n][]             & \unitpoint                                   & \defeq    & \unittype                                                                                    \\
    \paintingtype[n][p,...,n](p<n) & (\framep[n][p,...,n])                        & \defeq    & (\framep[n][p] \rightarrow Type_l) \times \paintingtype[n][p+1,...,n](\framep[n][p+1,...,n]) \\
    \\
    \restrftype[n][p,...,n]        &
    \multicolumn{3}{l}{
      \left(\begin{array}{l}
                \deps[n-1][0,...,p-1]:\depstype[n-1][0,...,p-1]                                  \\
                \framep[n-1][p,...,n-1]:\frametype[n-1][p,...,n-1]                               \\
                \painting[n-1][p,...,n-1]:\paintingtype[n-1][p,...,n-1](\framep[n-1][p,...,n-1]) \\
              \end{array}\right) : Type_{l}
    }                                                                                                                                                                                        \\
    \restrftype[n][]               &
    \left(\begin{array}{l}
              \deps[n-1][0,...,n-1] \\
              \unitpoint            \\
              \unitpoint            \\
            \end{array}\right)       & \defeq                                       & \unittype                                                                                                \\
    \restrftype[n][p,...,n-1]      &
    \left(\begin{array}{l}
              \deps[n-1][0,...,p-1]     \\
              \framep[n-1][p,...,n-1]   \\
              \painting[n-1][p,...,n-1] \\
            \end{array}\right)
                                   & \defeq                                       &
    \begin{array}{c}
      \framep[n][p]
      \left(\begin{array}{l}
                \deps[n-1][0,...,p-1] \\
              \end{array}\right)
      \rightarrow \framep[n-1][p] \\
      \times                      \\
      \restrftype[n][p+1,...,n]
      \left(\begin{array}{l}
                \deps[n-1][0,...,p]         \\
                \framep[n-1][p+1,...,n-1]   \\
                \painting[n-1][p+1,...,n-1] \\
              \end{array}\right)
    \end{array}
  \end{array}
\end{equation*}

At this stage, it is also convenient to use an abbreviation to combine the extra parts of $\framep$, a $\painting$ and a $\restrf$ in one block, which we call $\extradeps[n][p,...,n-1]$:

\begin{align*}
  \extradeps[n][p,..,n-1] (\deps[n][0,...,p-1]) \defeq
  \left(\begin{array}{l}
            \framep[n][p,...,n-1] :\frametype[n][p,...,n-1] \\
            \painting[n][p,...,n-1] :\paintingtype[n][p,...,n-1]
            (\framep[n][p,...,n-1])                         \\
            \restrf[n][p,...,n-1]  :\restrftype[n][p,...,n-1]
            \left(\begin{array}{l}
                \deps[n-1][0,...,p]         \\
                \framep[n-1][p+1,...,n-1]   \\
                \painting[n-1][p+1,...,n-1] \\
              \end{array}\right)               \\
          \end{array}\right)
\end{align*}

This allows to define $\painting[n][p]$ formally:
\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \painting[n][p]               &
    \multicolumn{3}{l}{
      \left(\begin{array}{l}
                \deps[n-1][0,...,p-1]:\depstype[n-1][0,...,p-1]           \\
                \extradeps[n-1][p,...,n-1]:\extradepstype[n-1][p,...,n-1] \\
                E:\framep[n-1][n-1]\rightarrow Type_l                     \\
              \end{array}\right) : \framep[n-1][n-1]\rightarrow Type_l
    }                                                                            \\
    \painting[n][n]               &
    \left(\begin{array}{l}
              \deps[n-1][0,...,n-1] \\
              \unitpoint            \\
              E                     \\
            \end{array}\right)      & \defeq & E                                   \\
    \painting[n][p](p<n)          &
    \left(\begin{array}{l}
              \deps[n-1][0,...,p-1]      \\
              \extradeps[n-1][p,...,n-1] \\
              E                          \\
            \end{array}\right) & \defeq & d \mapsto
    \left(\begin{array}{l}
              \Sigma l:(\Pi q\leq n.\,\Pi \omega.\
              \deps.\painting[n-1][0,...,p](\extradeps.\restrf[n][p](d))). \\
              \painting[n][p+1,...,n-1]
              \left(\begin{array}{l}
                  \deps[n-1][0,...,p]          \\
                  \extradeps[n-1][p+1,...,n-1] \\
                  E                            \\
                \end{array}\right)(d,l)                           \\
            \end{array}\right) \\
  \end{array}
\end{equation*}

From which we can deduce $\painting[n][0,...,p]$ by recursion on $p$.

\section{...}

to do : def of restrptype

Mutual definition of \restrf and cohframetype

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \restrf[n][0,...,p]                                                           &
    \multicolumn{3}{l}{
      \left(\begin{array}{l}
                \deps[n][0,...,p-2]:\depstype[n][0,...,p-2]                                \\
                \extradeps[n][p-1,...,n]:\extradepstype[n][p-1,...,n](\deps[n][0,...,p-1]) \\
                \restrp[n][0,...,p-2]:\restrptype[n][0,...,p-1]
                \left(\begin{array}{l}
                    \deps[n][0,...,p-1]      \\
                    \extradeps[n][p-1,...,n] \\
                  \end{array}\right)                                             \\
                \cohf[n][0,...,p]:\cohftype[n][0,...,p]
              \end{array}\right) : \restrftype[n][0,...,p]
    }                                                                                                                                                         \\
    \restrf[n][0]                                                                 &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)                                                        & \defeq & (\unitpoint,\lambda q. \lambda\epsilon. \lambda \_.\unitpoint) \\
    \restrf[n][0,...,p+1]                                                         &
    \left(\begin{array}{l}
              \deps[n][0,...,p]        \\
              \extradeps[n][p-1,...,n] \\
              \restrp[n][0,...,p]      \\
              \cohf[n][0,...,p]        \\
            \end{array}\right)                                                   & \defeq &
    \begin{array}{l}
      \restrf[n+1][0,...,p]
      \left(\begin{array}{l}
                \deps[n+1][0,...,p-1]    \\
                \extradeps[n][p-1,...,n] \\
                \restrp[n+1][0,...,p-1]  \\
                \cohf[n+1][0,...,p-1]    \\
              \end{array}\right)     ,                                            \\
      \lambda q.\lambda \epsilon.\lambda (\framep[n+1][0,...,p], \layer[n][p]). \\
      \left(\restrf[n][0,...,p]
      \left(\begin{array}{l}
                  \deps[n+1][0,...,p-1]    \\
                  \extradeps[n][p-1,...,n] \\
                  \restrp[n+1][0,...,p-1]  \\
                  \cohf[n+1][0,...,p-1]    \\
                \end{array}\right), \restrl[n][p]
      \left(\begin{array}{l}
                  \deps[n][0,...,p]        \\
                  \extradeps[n][p-1,...,n] \\
                  \layer[n+1][p]           \\
                  \cohf[n][0,...,p]        \\
                \end{array}\right) (l)\right)                                       \\
    \end{array}                                                                  \\
    \cohftype[n][0,...,p-1]                                                       &
    \multicolumn{3}{l}{
      \left(\begin{array}{l}
                \deps[n][0,...,p-1]:\depstype[n][0,...,p-1]                                \\
                \extradeps[n][p-1,...,n]:\extradepstype[n][p-1,...,n](\deps[n][0,...,p-1]) \\
                \restrp[n][0,...,p-1]:\restrptype[n][0,...,p-1](\deps[n][0,...,p-1])       \\
              \end{array}\right) : Type_{l}
    }                                                                                                                                                         \\
    \cohftype[n][0,...,0-1]                                                       &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)                                                        & \defeq &
    \unittype                                                                                                                                                 \\
    \cohftype[n][0,...,(p+1)-1]                                                   &
    \left(\begin{array}{l}
              \deps[n][0,...,p]        \\
              \extradeps[n][p-1,...,n] \\
              \restrp[n][0,...,p]      \\
            \end{array}\right)                                                   & \defeq &
    \begin{array}{l}
      \Sigma \cohf[n+1][0,...,p-1]
      :\cohftype[n+1][0,...,p-1]
      \left(\begin{array}{l}
                \deps[n+1][0,...,p-1]    \\
                \extradeps[n][p-1,...,n] \\
                \restrp[n+1][0,...,p-1]  \\
              \end{array}\right)                         .     \\
      \Pi q\leq n.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega. \\
      \restrf[n][p][q][\epsilon](\restrf[n+1][p][r][\omega]
      \left(\begin{array}{l}
                \deps[n+1][0,...,p-1]    \\
                \extradeps[n][p-1,...,n] \\
                \restrp[n+1][0,...,p-1]  \\
              \end{array}\right)(d)) =                         \\
      \restrf[n][p][r][\omega](\restrf[n+1][p][q+1][\epsilon]
      \left(\begin{array}{l}
                \deps[n+1][0,...,p-1]    \\
                \extradeps[n][p-1,...,n] \\
                \restrp[n+1][0,...,p-1]  \\
              \end{array}\right)(d))                         \\
    \end{array}                                                                                     \\
    \restrl[n][p][q][\epsilon]                                                    &
    \left(\begin{array}{l}
              \deps[n][0,...,p]:\depstype[n][0,...,p]                                    \\
              \extradeps[n][p-1,...,n]:\extradepstype[n][p-1,...,n](\deps[n][0,...,p-1]) \\
              \layer[n+1][p]:\layertype[n+1][p]                                          \\
              \cohf[n][0,...,p]:\cohftype[n][0,...,p]                                    \\
            \end{array}\right) & :      &
    \restrltype[n][p]                                                                                                                                         \\
    \restrl[n][p][q][\epsilon]                                                    &
    \left(\begin{array}{l}
              \deps[n][0,...,p]        \\
              \extradeps[n][p-1,...,n] \\
              \layer[n][p]             \\
              \cohf[n][0,...,p]        \\
            \end{array}\right)                                                   & \defeq &
    \lambda\omega.\,\overrightarrow{\cohf[n][p][q][q][\epsilon][\omega]}{\restrp[n][p](\layer[n][p])}                                                         \\
  \end{array}
\end{equation*}

At this new stage, it is convenient to use an abbreviation to combine sequences $\deps[n][0,..,p-1]$, $\extradeps[n][p,...,n]$, $\restrp[n][0,...,p-1]$ and $\cohf[n][0,...,p-1]$ in one block, which we call $\depscohs[n][0,...p-1]$:

\begin{align*}
  \depscohs[n][0,..,p-1] \defeq
  \left(\begin{array}{l}
            \deps[n][0,...,p-1] :\depstype[n][0,...,p-1]    \\
            \extradeps[n][0,...,p-1] :\extradepstype[n][p-1,...,n]
            (\deps[n][0,...,p-1])                           \\
            \restrp[n][0,...p-1]: \restrptype[n][0,...,p-1] \\
            \cohf[n][0,...,p-1]: \cohftype[n][0,...,p-1]    \\
          \end{array}\right)
\end{align*}
so that $\restrf[n][0,...,p]$ has type $\depscohs[n][0,..,p-1] \rightarrow \restrftype[n][0,...,p]$. Later, we shall write $\depscohs.\deps$, $\depscohs.\extradeps$, $\depscohs.\restrp$, and $\depscohs.\cohf$ for the corresponding projections of a $\depscohs$.

\section{...}

to do : def of cohptype

Definition of \cohf, using $\UIP$ to solve the dependency in $\coht$.

\begin{equation*}
  \fontsize{7.2}{9}\selectfont
  \begin{array}{llcl}
    \cohf[n][0,...,p]                                                                         &
    \multicolumn{3}{l}{
      \left(\begin{array}{l}
                \depscohs[n][0,...,p-2]:\depstype[n][0,...,p-2]                                \\
                \extradepscohs[n][p-1,...,n]:\extradepstype[n][p-1,...,n](\deps[n][0,...,p-1]) \\
                \cohp[n][0,...,p-2]:\restrptype[n][0,...,p-1]
                \left(\begin{array}{l}
                    \depscohs[n][0,...,p-1]      \\
                    \extradepscohs[n][p-1,...,n] \\
                  \end{array}\right)                                             \\
                \coht[n][0,...,p]:\cohttype[n][0,...,p]
              \end{array}\right) : \cohftype[n][0,...,p]
    }                                                                                                                                                                                        \\
    \cohf[n][0]                                                                               &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)                                                                    & \defeq & (\unitpoint,\lambda q.\lambda r. \lambda\epsilon. \lambda\omega.\lambda \_.\refl) \\
    \cohf[n][0,...,p+1]                                                                       &
    \left(\begin{array}{l}
              \depscohs[n][0,...,p]        \\
              \extradepscohs[n][p-1,...,n] \\
              \cohp[n][0,...,p]            \\
              \coht[n][0,...,p]            \\
            \end{array}\right)                                                           & \defeq &
    \begin{array}{l}
      \cohf[n+1][0,...,p]
      \left(\begin{array}{l}
                \depscohs[n+1][0,...,p-1]    \\
                \extradepscohs[n][p-1,...,n] \\
                \cohp[n+1][0,...,p-1]        \\
                \coht[n+1][0,...,p-1]        \\
              \end{array}\right)     ,                                                                            \\
      (\cohf[n+1][0,...,p], \lambda q.\lambda r.\lambda \epsilon.\lambda \omega.\lambda (\cohf[n][p],\cohl[n][p])). \\
      \left(\cohf[n][0,...,p]
      \left(\begin{array}{l}
                  \depscohs[n+1][0,...,p-1]    \\
                  \extradepscohs[n][p-1,...,n] \\
                  \cohp[n+1][0,...,p-1]        \\
                  \coht[n+1][0,...,p-1]        \\
                \end{array}\right), \restrl[n][p]
      \left(\begin{array}{l}
                  \depscohs[n][0,...,p]        \\
                  \extradepscohs[n][p-1,...,n] \\
                  \layer[n+1][p]               \\
                  \cohf[n][0,...,p]            \\
                \end{array}\right) (l)\right)                                                                           \\
    \end{array}                                                                 \\
    \cohttype[n][0,...,p-1]                                                                   &
    \multicolumn{3}{l}{
      \left(\begin{array}{l}
                \depscohs[n][0,...,p-1]:\depscohstype[n][0,...,p-1]                                    \\
                \extradepscohs[n][p-1,...,n]:\extradepscohstype[n][p-1,...,n](\depscohs[n][0,...,p-1]) \\
                \restrp[n][0,...,p-1]:\restrptype[n][0,...,p-1](\depscohs[n][0,...,p-1])               \\
              \end{array}\right) : Type_{l}
    }                                                                                                                                                                                        \\
    \cohttype[n][0,...,0-1]                                                                   &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)                                                                    & \defeq &
    \unittype                                                                                                                                                                                \\
    \cohttype[n][0,...,(p+1)-1]                                                               &
    \left(\begin{array}{l}
              \depscohs[n][0,...,p]        \\
              \extradepscohs[n][p-1,...,n] \\
              \restrp[n][0,...,p]          \\
            \end{array}\right)                                                           & \defeq &
    \begin{array}{l}
      \Sigma \coht[n+1][0,...,p-1]
      :\cohttype[n+1][0,...,p-1]
      \left(\begin{array}{l}
                \depscohs[n+1][0,...,p-1]    \\
                \extradepscohs[n][p-1,...,n] \\
                \restrp[n+1][0,...,p-1]      \\
              \end{array}\right)                         .     \\
      \Pi q\leq n.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega. \\
      \cohf[n][p][q][\epsilon](\cohf[n+1][p][r][\omega]
      \left(\begin{array}{l}
                \depscohs[n+1][0,...,p-1]    \\
                \extradepscohs[n][p-1,...,n] \\
                \restrp[n+1][0,...,p-1]      \\
              \end{array}\right)(d)) =                     \\
      \cohf[n][p][r][\omega](\cohf[n+1][p][q+1][\epsilon]
      \left(\begin{array}{l}
                \depscohs[n+1][0,...,p-1]    \\
                \extradepscohs[n][p-1,...,n] \\
                \restrp[n+1][0,...,p-1]      \\
              \end{array}\right)(d))                     \\
    \end{array}                                                                                                                    \\
    \cohl[n][p][q][\epsilon]                                                                  &
    \left(\begin{array}{l}
              \depscohs[n][0,...,p]:\depscohstype[n][0,...,p]                                        \\
              \extradepscohs[n][p-1,...,n]:\extradepscohstype[n][p-1,...,n](\depscohs[n][0,...,p-1]) \\
              \cohp[n+1][p]:\cohptype[n+1][p]                                                        \\
              \coht[n][0,...,p]:\cohttype[n][0,...,p]                                                \\
            \end{array}\right) & :      &
    \begin{array}{l}
      \Pi d.\Pi l. \overrightarrow{\cohf[n][p][r+1][q+1][\epsilon][\omega]}{\restrl[n][p][q][\epsilon](\restrl[n][p][r][\omega](l))} = \\
      \restrl[n][p][r][\omega](\restrl[n][p][q+1][\epsilon](l))
    \end{array}                                                                                                         \\
    \cohl[n][p][q][\epsilon][r][\omega]                                                       &
    \left(\begin{array}{l}
              \depscohs[n][0,...,p]        \\
              \extradepscohs[n][p-1,...,n] \\
              \cohp[n][p]                  \\
              \cohf[n][0,...,p]            \\
            \end{array}\right)                                                           & \defeq &
    \lambda d. \lambda l. \lambda \theta. (\cohp[n][p][q][\epsilon][r][\omega](l))                                                                                                           \\
  \end{array}
\end{equation*}

\bibliographystyle{msclike}
\bibliography{paper}

\end{document}
