\documentclass[10pt]{art.cls/art}

\usepackage{multirow, float, tabularx, environ, booktabs, setspace, makecell, caption, art.cls/joinargs, colortbl, pdflscape}
\usepackage[prefix=bonak]{art.cls/xkeymask}
\usepackage[skip=0.4em]{parskip}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{filler}{D}{(#1)}
\define@cmdkey[bonak]{filler}{E}{(#1)}
\define@cmdkey[bonak]{filler}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrfiller}{D}{(#1)}
\define@cmdkey[bonak]{restrfiller}{E}{(#1)}
\define@cmdkey[bonak]{restrfiller}{d}{(#1)}
\define@cmdkey[bonak]{restrfiller}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohfiller}{D}{(#1)}
\define@cmdkey[bonak]{cohfiller}{E}{(#1)}
\define@cmdkey[bonak]{cohfiller}{d}{(#1)}
\define@cmdkey[bonak]{cohfiller}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \ensuremath{{\color{carolina}{\nu\textsf{Set}}}_{#1}^{#2}}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and filler: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs{}[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and filler: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4]}^{\joinargs{}[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

% Coherence conditions for frame, layer, and filler: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4][#5][#6]}^{\joinargs{}[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4][#5][#6][#7]}^{\joinargs{}[#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}{\ensuremath{\boldsymbol{\square}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommandx{\U}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HSet}}_{#1}}}

% The unit type
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\unitpoint}{\ensuremath{\ast}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\eqHSet}{\ensuremath{\equiv_{\mathit{HSet}}}}
\newcommand{\reflHSet}{\ensuremath{\mathsf{refl}_{\mathit{HSet}}}}

% Some abbreviations
\newcommand{\tl}{\ensuremath{\mathsf{tl}}}
\newcommand{\hd}{\ensuremath{\mathsf{hd}}}
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\newcommand{\ap}{\mathsf{ap}}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\Dom}{\textsf{Dom}}
\newcommand{\UIP}{\textsf{UIP}}

% These are renewed in tables, but let's define them now for in-document
% typesetting
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\filler}[2][1,2]{\prim{filler}[][#1][#2][][]}
\newcommandx{\restrf}[3][1,2,3]{\restr{frame}[][#3][][#1][#2][][]}
\newcommandx{\fullframe}[1][1]{\prim{fullframe}[][#1][][][]}

% Kerning for star
\newcommand{\kstar}{{\star}}

% The eqntable environment, displaying the various
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{eqntable}[1]{
  \begin{table}[H]
    \small
    \begin{tabularx}{\linewidth}{@{}>{$}l<{$} >{$}c<{$} >{$}c<{$} >{$}Y<{$} @{}}
      \toprule
      \BODY
      \bottomrule
    \end{tabularx}
    \caption{#1}
  \end{table}
}

% The label, since we're including twice
\newcommand*{\lab}{}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

% Table caption set up
\DeclareCaptionFormat{hfillunittypet}{\hfill#1#2#3\par}
\DeclareCaptionFont{mdit}{\mdseries\itshape}
\captionsetup[table]{
  justification=centering,
  font=bf,
  labelfont=mdit,
}

\title{A mechanization of semi-simplicial and semi-cubical sets in the calculus of inductive constructions}
\author{
  \textcolor{gray80}{Ramkumar Ramachandra} \\
  \itshape \textcolor{gray80}{Université Paris-Cité}
  \and
  \textcolor{gray80}{Hugo Herbelin} \\
  \itshape \textcolor{gray80}{IRIF/Inria Paris/Université Paris-Cité}
}
\date{}

\color{gray65}

\begin{document}
\maketitle
\begin{abstract}
  We present a parametricity-based construction of semi-simplicial sets and semi-cubical sets in indexed form, in the calculus of inductive constructions. The accompanying artifact is an axiom-less~\footnote{Technically speaking, we use some axioms related to functional extensionality, but the requirement arises only from our generalization to $\nu$-types; if $\nu$ is finite (say, unit type corresponding to augmented semi-simplicial types), this requirement vanishes.} Coq formalization that uses sophisticated rewriting techniques and pushes the boundaries of proof assistant technology.
\end{abstract}
\tableofcontents
\newpage

\section{Overture}
In the context of typed functional programming, Reynolds' parametricity~\cite{reynolds72} interprets types as relations characterizing the observational equality of programs of this type. Parametricity can be iterated, and it has been noted that iterated Reynolds' parametricity has a cubical flavor~\cite{johann17,altenkirch15,moulin16}. We obtain a \emph{unary} variant of Reynolds' \emph{binary} parametricity by using predicates instead of relations, in which case we obtain a form of (Kreisel) realizability~\cite{bernardy12,moulin16}. It has then been noted that iterated unary parametricity has an augmented simplicial flavor~\footnote{Observation from Hugo Moeneclaey}.

We exploit the connection between iterated unary parametricity and augmented simplicial sets, and between iterated binary parametricity and cubical sets to present a uniform construction of both semi-simplicial semi-cubical sets obtained by applying simple rules iterating parametricity.  In contrast to the presheaf presentation of semi-simplicial and semi-cubical sets, our uniform construction, which we call \emph{$\nu$-sets}, is \emph{indexed}. That is, instead of having the set of semi-simplices or semi-cubes in dimension $n+1$
\emph{fibered} over the set of semi-simplices or semi-cubes in dimension $n$, we consider families of semi-simplices and semi-cubes indexed over their faces.

\begin{table}[H]
  \begin{tabularx}{\linewidth}{p{.3\linewidth}|p{.3\linewidth}|p{.3\linewidth}}
    \toprule
            & Set theory  & Type theory \\
    \graymidrule
    Fibered & \cite{cchm} &             \\
    \graymidrule
    Indexed &             & Our work    \\
    \bottomrule
  \end{tabularx}
\end{table}

The outline of the paper is as follows. First, we briefly describe semi-simplicial and semi-cubical sets, and our generalization to $\nu$-sets. We then proceed to explain our construction, with the help of diagrams. Before spelling out the details of our formalization in type-theoretic language, we have a section on reasoning in sets.

\section{Mathematical treatment of \texorpdfstring{$\nu$}{𝜈}-sets}
It is well-known that simplicial sets exist purely in the imagination of the mathematician, as every simplicial set has an infinite number of degenerate simplices. What we have formalized is \emph{augmented semi-simplicial} sets, and \emph{semi-cubical} sets. We will proceed to explain the mathematical objects we have formalized.

\subsection{Augmented semi-simplicial sets}
Augmented semi-simplicial sets are defined similarly to semi-simplicial sets, except that the connected components are additionally dependent on a ``color''. Conversely, semi-simplicial sets can be seen as augmented semi-simplicial sets over a singleton set of colors.

Let us associate dimension $0$ to colors; then, points are dimension $1$, lines are dimension $2$, and so on. There is hence a shift by one when compared to semi-simplicial sets. We can then draw augmented semi-simplicial sets like semi-simplicial sets, except for this shift by one.

While ordinary semi-simplicial sets are presheaves over the semi-simplex category $\hat{\Delta}$, augmented semi-simplicial sets are presheaves over, what we will define as $\DeltaPlus$. There are different ways to define $\DeltaPlus$, upto equivalence, and we use a combinatorial definition; the reason for our choice is that this definition has a straightforward extension to semi-cubical sets.

\begin{notation}[Sequences of integers]
  We write $\{i_1, \ldots i_n\}$ for sequences of integers. In particular, the empty sequence is written $\{\}$.
\end{notation}

We introduce two additional notations for working with sequences of integers.

\begin{notation}[::]
  We define $i :: \{j_1, \ldots, j_n\}$ to be $\{i, j_1, \ldots, j_n\}$.
\end{notation}

\begin{notation}[$\uparrow$]
  Let us write $\uparrow \{i_1, \ldots, i_n\}$ to denote $\{i_1 + 1, \ldots, i_n + 1\}$.
\end{notation}

\begin{definition}[\DeltaPlus]
  The category of augmented semi-simplices is defined in terms of objects, morphisms, composition, and identity.

  \begin{align*}
    \obj(\DeltaPlus) & := \Nat                                                                    \\
    \hom(p, n)       & := \{\{i_{p + 1}, \ldots, i_n\} \mid 0 < i_{p + 1} < \ldots < i_n \leq n\} \\
    g \circ f        & :=
    \begin{cases}
      g                          & \text{if f = \{\}}                                          \\
      f                          & \text{if g = \{\}}                                          \\
      b :: (g \circ f')          & \text{if $g = (a :: g')$, $f = (b :: f')$, with $b < a$}    \\
      a :: (g' \circ \uparrow f) & \text{if $g = (a :: g')$, $f = (b :: f')$, with $b \geq a$} \\
    \end{cases}      \\
    \id              & := \{\}
  \end{align*}

  Evidently, $\id$ is neutral. Further, composition can be shown to be associative.
\end{definition}

\begin{definition}[Alternative definition of $\DeltaPlus$]
  \begin{align*}
    \obj(\DeltaPlus) & := \Nat                                                                     \\
    \hom(p, n)       & := \{l \in \{0, \kstar\}^n \mid \text{number of $\kstar$ in l = p}\}        \\
    g \circ f        & :=
    \begin{cases}
      f                  & \text{if $g = \{\}$}                                                      \\
      0 :: (g' \circ f)  & \text{if $g = (0 :: g')$}                                                 \\
      a :: (g' \circ f') & \text{if $g = (\star :: g')$, $f = (a :: f')$, where $a = 0$ or $\kstar$} \\
    \end{cases} \\
    \id              & := \{\kstar, \ldots, \kstar\} \text{ $n$ times}
  \end{align*}

  Note that, if $g \circ f$ is well-defined, then the length of $f$ is less than that of $g$. It can be shown that composition is associative and that $\id$ is neutral.
\end{definition}

\begin{definition}[$\Set_{\DeltaPlus}$]
  We define the category of augmented semi-simplicial sets as the functor category:

  \begin{equation*}
    \Set_{\DeltaPlus} := \Set^{\DeltaPlus^{\mathsf{op}}}
  \end{equation*}
\end{definition}

\begin{definition}[$\DeltaPlus^n$]
  The standard augmented $n$-semi-simplex $\DeltaPlus^n$ is defined as:

  \begin{align*}
    \DeltaPlus^n    & : \Set_{\DeltaPlus}      \\
    \DeltaPlus^n(p) & := \Hom(p, n)            \\
    \DeltaPlus^n(f) & := \lambda g . g \circ f
  \end{align*}
\end{definition}

The standard augmented $0$-semi-simplex is a singleton of one color. Standard augmented $n$-semi-simplices have a geometric interpretation, and we illustrate them for dimensions $1$, $2$, and $3$.

\begin{example}[$\DeltaPlus^1$]
  In dimension $1$, the standard augmented semi-simplex can be pictured as a point, colored black, corresponding to the unique morphism in $\Hom(0, 1)$. This point is the identity in $\Hom(1, 1)$; it is hence shown as a singleton $\kstar$:

  \begin{equation*}
    \begin{tikzcd}
      \kstar
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\DeltaPlus^2$]
  In dimension $2$, the standard augmented semi-simplex is drawn as two points, given by $\Hom(1, 2)$, along with a line connecting them, given by $\Hom(2, 2)$. We use the color black to denote the unique morphims in $\Hom(0, 1)$ and $\Hom(0, 2)$.

  \begin{equation*}
    \begin{tikzcd}
      \kstar0 \arrow[r, dash, "\kstar\kstar"] & 0\kstar
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\DeltaPlus^3$]
  $\DeltaPlus^3$ is drawn as three points, given by $\Hom(1, 3)$, three lines connecting them, given by $\Hom(2, 3)$, and a filler given by $\Hom(3, 3)$.

  \begin{equation*}
    \begin{tikzcd}
      & |[alias=F]|00\kstar \arrow[ddr, dash, "0\kstar\kstar"] & \\\\
      \kstar00 \arrow[rr, dash, "\kstar\kstar0"{name=T, below}]\arrow[uur, dash, "\kstar0\kstar"] && 0\kstar0 \\
      \arrow[rightarrow, from=F, to=T, phantom, "\kstar\kstar\kstar" description]
    \end{tikzcd}
  \end{equation*}
\end{example}

\subsection{Semi-cubical sets}
\begin{definition}[\Cube]
  $\Cube$ is defined similarly to $\DeltaPlus$, except that we take sequences of $L$, $R$ and $\star$, instead of sequences of $0$ and $\kstar$. We use $L$ and $R$ to indicate opposite faces of a cube.

  \begin{align*}
    \obj(\Cube) & := \Nat                                                                                \\
    \hom(p, n)  & := \{l \in \{L, R, \kstar\}^n \mid \text{number of $\kstar$ in $l = p$}\}              \\
    g \circ f   & :=
    \begin{cases}
      f                  & \text{if $g = \{\}$}                                                            \\
      a :: (g' \circ f)  & \text{if $g = (a :: g')$}, \text{where $a = L$ or $R$}                          \\
      a :: (g' \circ f') & \text{if $g = (\star :: g')$, $f = (a :: f')$, where $a = L$, $R$, or $\kstar$} \\
    \end{cases} \\
    \id         & := \{\kstar, \ldots, \kstar\} \text{ $n$ times}
  \end{align*}

  Again, if $g \circ f$ is well-defined, then the length of $f$ is less than that of $g$. It can be shown that composition is associative and that $\id$ is neutral.
\end{definition}

\begin{definition}[\CSet]
  We define the category of semi-cubical sets as the functor category:

  \begin{equation*}
    \CSet := \Set^{\op{\Cube}}
  \end{equation*}
\end{definition}

\begin{definition}[$\Cube^n$]
  The standard semi-cube $\Cube^n$ is defined as:

  \begin{align*}
    \Cube^n    & : \CSet                  \\
    \Cube^n(p) & := \Hom(p, n)            \\
    \Cube^n(f) & := \lambda g . g \circ f
  \end{align*}
\end{definition}

Standard $n$-semi-cubes have a geometric interpretion, which we illustrate for dimensions $0$, $1$, and $2$.

\begin{example}[$\Cube^0$]
  $\Cube^0$ is $\Hom(0, 0)$, or the singleton set of the empty sequence:

  \begin{equation*}
    \begin{tikzcd}
      \{\}
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\Cube^1$]
  $\Cube^1$ is two points, given by $\Hom(0, 1)$ and a line, given by $\Hom(1, 1)$:

  \begin{equation*}
    \begin{tikzcd}
      0 \arrow[r, "\kstar", dash] & 1
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\Cube^2$]
  $\Cube^2$ is four points, given by $\Hom(0, 2)$, four lines connecting the four points, given by $\Hom(1, 2)$, and a filler, given by $\Hom(2, 2)$:

  \begin{equation*}
    \begin{tikzcd}
      01 \arrow[r, dash, "\kstar1"{name=F}] \arrow[d, dash, "0\kstar" left] & 11 \arrow[d, dash, "1\kstar"] \\
      00 \arrow[r, dash, "\kstar0"{name=T, below}] & 10 \\
      \arrow[rightarrow, from=F, to=T, phantom, "\kstar\kstar" description]
    \end{tikzcd}
  \end{equation*}
\end{example}

\subsection{Generalization to \texorpdfstring{$\nu$}{ν}-sets}
Let us call $\nu$-sets, the straightforward generalization of augmented semi-simplicial sets and semi-cubical sets to an arbitrary cardinal, where morphisms are sequences of elements of an arbitrary set $\nu$, extended with $\kstar$. Then, we observe:

\begin{table}[H]
  \begin{tabularx}{\linewidth}{p{.2\linewidth}|p{.4\linewidth}|p{.3\linewidth}}
    \toprule
    Value of $\nu$ & 1                               & 2                  \\
    \graymidrule
    Interpretation & Augmented semi-simplicial types & Semi-cubical types \\
    \bottomrule
  \end{tabularx}
\end{table}

\section{Our construction}
In this section, we briefly explain the difference between the fibered and indexed representations, and illustrate our approach to the construction, with the help of some figures.

\subsection{Homotopy type theory}
Homotopy type theory (HoTT) is a logical foundation based on Martin-Löf type theory and the univalence axiom~\cite{hottbook}. HoTT is based on the notion of a basic Type, and the notion of sets can be recovered as \U, where $\U$ is a straightforward packaging of two fields:

\begin{align*}
  \Dom & : \Type                                          \\
  \UIP & : \forall x y : \Dom, \forall p q : x = y, p = q
\end{align*}

In the $\U$ universe, three properties hold:

\begin{enumerate}
  \item[(i)] UIP holds on the unit type.
  \item[(ii)] UIP propagates to $\Sigma$-types.
  \item[(iii)] UIP propagates to $\Pi$-types, with some additional functional extensionality axioms.
\end{enumerate}

$\U$ provides us a form of unicity of identity of proofs (UIP), which is a form of proof irrelevance:

\begin{align*}
  \forall x y, \forall p q : x = y, p = q
\end{align*}

which is to say that any two proofs of \emph{equality} of the same two types are \emph{equal}. In other words, the proofs cannot be distinguished from one another.

An equivalent defintion of UIP is given by \textsf{UIP\_refl}:

\begin{align*}
  \textsf{UIP\_refl} & : \forall x, \forall p : x = x, p = \textsf{eq\_refl } x
\end{align*}

In type theory, UIP can be proved on the unit type and bool type:

\begin{align*}
  \textsf{eq\_refl}        & : \forall x, x = x                                                    \\
  \textsf{UIP\_refl\_unit} & : \forall u : \textsf{unit}, \forall x : u = u, x = \textsf{eq\_refl} \\
  \textsf{UIP\_refl\_bool} & : \forall b : \textsf{bool}, \forall x : b = b, x = \textsf{eq\_refl} \\
\end{align*}


\subsection{Fibered versus indexed representation}
It is well-known in set theory, that families of small sets can be represented in a fibered or indexed way. In the fibered way, a family over $T$ is represented a pair of a set $S$, and a function $S \rightarrow T$. The function classifies the original set into fibers. In contrast, in the indexed way, a family over $T$ is represented as a functional relation with domain $T$, which itself, by replacement axiom, is a set.

In category theory, the correspondence between fibered and indexed way, manifests as the correspondence between Grothendieck fibrations and pseudofunctors, of which a particular instance is the correspondence between discrete fibrations and presheaves, or even between discrete fibrations over sets and families of sets.

The latter correspondence can be expressed in HoTT, for $T: \Type$, as an equivalence between $\Sigma S: \Type\;.\;S \rightarrow T$ and $T \rightarrow \Type$, which can be proved using univalence. This correspondence also holds on \U, for $T: \U$:

\begin{equation*}
  \Sigma S: \U\;.\;S\rightarrow T \simeq T \rightarrow \U
\end{equation*}

Let us now come back to cubical sets. A cubical set can be represented as a sequence of fibrations, together with appropriate coherence conditions.

\begin{equation*}
  \begin{tikzcd}
    X_0 : \U & X_1 : \U \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] & X_2 : \U \arrow[l, "\delta^\epsilon_1" description, shift left=6] \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] \arrow[l, "\delta^\omega_1" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}

We can iteratively apply the above correspondence to obtain an indexed representation of cubical sets.

\begin{align*}
  X_0 & : \U                                                                                                              \\
  X_1 & : X_0 \times X_0 \rightarrow \U                                                                                   \\
  X_2 & : \forall a b c d, X_1 (a, b) \rightarrow X_1 (a, c) \rightarrow X_1 (b, d) \rightarrow X_1 (c, d) \rightarrow \U \\
  \ldots
\end{align*}

The focus of our work has been to formally define such an indexed presentation of not just semi-cubical, but more generally, $\nu$-sets.

\subsection{Intuition for our formal construction}
\begin{notation}[\Sigma]
  In the prose that follows, we assume the existence of $\Sigma$-types with projections $\hd$ and $\tl$.
\end{notation}

To assign $X_0, X_1, X_2, \ldots$ in the above indexed representation types, we need to exhibit a recursive definition over our building blocks, which we will call $\framep$, $\layer$, and $\filler$. A $\framep$ is a boundary of a standard form (simplex, cube, etc.), a $\filler$ is a filled $\framep$.

As a first step, we assign every $X_n$ the type $\fullframe[n] \rightarrow \U$ uniformly, applying the isomorphism between $A \rightarrow B \rightarrow C$ and $A \times B \rightarrow C$, or between $\Pi a : A, (B a \rightarrow C)$ and $(\Sigma a : A, B a) \rightarrow C$. Let us illustrate how we will build $\fullframe[n]$ by refining types of $X_0, X_1, \ldots, X_{n - 1}$ so that they have the form $\fullframe[n] \rightarrow \U$. To begin, let us set $\fullframe[0] = \unittype$, so that the type $\U$ of $X_0$ can be equivalently formulated as $\unittype \rightarrow \U$. The rest of the construction follows.

\begin{equation*}
  \begin{array}{llll}
    X_0                                :                & \underbrace{\unittype}_{\framep[0][0]}                                                   & \rightarrow \U \\
    X_1                                :                & \underbrace{\Sigma \unitpoint: \unittype. \underbrace{\left(
    \begin{array}{c}
        \underbrace{X_0(\unitpoint)}_{\filler[0][0]}
        \\ \times \\
        \underbrace{X_0(\unitpoint)}_{\filler[0][0]}
      \end{array}\right)}_{\layer[1][0]}}_{\framep[1][1]} & \rightarrow \U                                                                                            \\
    X_2                                :                & \underbrace{\Sigma a: \underbrace{\left(\Sigma \unitpoint: \unittype. \underbrace{\left(
        \begin{array}{c}
          \underbrace{\Sigma b: \left(
          \begin{array}{c}
              X_0(\unitpoint)
              \\ \times \\
              X_0(\unitpoint)
            \end{array}
          \right).\; \underbrace{X_1 (\unitpoint, b)}_{\filler[1][1]}}_{\filler[1][0]}
          \\ \times \\
          \underbrace{\Sigma b: \left(
          \begin{array}{c}
              X_0(\unitpoint)
              \\ \times \\
              X_0(\unitpoint)
            \end{array}
          \right).\; \underbrace{X_1 (\unitpoint, b)}_{\filler[1][1]}}_{\filler[1][0]}
        \end{array}
        \right)}_{\layer[2][0]}\right)}_{\framep[2][1]}.\underbrace{\left(
      \begin{array}{c}
        \underbrace{X_1 \underbrace{\left(a.\hd, \left(
          \begin{array}{c}
            a.\tl.L.\hd.L, \\
            a.\tl.R.\hd.L
          \end{array}
          \right)\right)}_{\restrf[2][1][L]}}_{\filler[1][1]}
        \\ \times \\
        \underbrace{X_1 \underbrace{\left(a.\hd, \left(
          \begin{array}{c}
            a.\tl.L.\hd.R, \\
            a.\tl.R.\hd.R
          \end{array}
          \right)\right)}_{\restrf[2][1][R]}}_{\filler[1][1]}
      \end{array}
      \right)}_{\layer[2][1]}}_{\framep[2][2]}
                                                        & \rightarrow \U                                                                                            \\
    \ldots
  \end{array}
\end{equation*}

$\fullframe[n]$ is a nesting of $n$ $\Sigma$-types, of which each component is called a $\layer[n]$.

The question is then to find the recursive recipe defining $\fullframe[n]$. First, $\fullframe[n]$ depends on all $X_i$ upto $n - 1$. So, we need to package up $X_i$, for $i < n$, into a type, which we call $\X[][<n][]$. This allows us to give the type $\X[][<n][] \rightarrow \U$ to $\fullframe[n]$. Then, for $D: \X[][<n][]$, representing an initial prefix of $X_0, X_1, \ldots X_{n - 1}$, the indexed set $X_n$ has type $\fullframe[n](D) \rightarrow \U$. We shall give the full definition of $\fullframe[n]$ shortly, but first, assuming $\fullframe[n]$ is defined, we are able to take the coinductive limit of the $\X[][<n][]$, as shown in \ref{tab:coind}, therefore fully characterizing the indexed definition of $\nu$-sets.

The characterization of $\framep[n]$ and $\filler[n]$ can be obtained by a recursive definition reminiscent from parametricity translation \cite{reynolds72}: a $\filler[n+1]$ is obtained by taking two $\filler[n]$ plus a third $\filler[n]$ connecting the two $\filler[n]$. Since it connects $\filler[n]$, the third $\filler[n]$ is actually a $\filler[n]$ over lines, so it is shifted by one relatively to the underlying relational structure. Let us write $\filler[n][p]$ for a $\filler[n - p]$ over points which are $\filler[p]$. Working informally, we thus have the equation:

\begin{equation*}
  \filler[n+1][p] \defeq (\filler[n][p] \times \filler[n][p]) \times \filler[n+1][p+1]
\end{equation*}

Now, the third filler (of dimension $n - p$) connects the first two $\filler[n-p]$, so it has to depend on them. So, the equation is rather something of the form:

\begin{equation*}
  \filler[n+1][p] \defeq \Sigma a:(\filler[n][p] \times \filler[n][p]).\, \filler[n+1][p+1](a)
\end{equation*}

Then, by iterating, we obtain:

\begin{equation*}
  \filler[n+1][p] \defeq \Sigma a:(\filler[n][p] \times \filler[n][p]).\,
  \Sigma b:(\filler[n][p+1](a) \times \filler[n][p+1](a)). \, \filler[n+1][p+2](a,b)
\end{equation*}

and so on. Thus, we need first to make the definition of $\filler[n][p]$ dependent over the part of the filler built up to this point and secondly to accumulate this information. At the end of the accumulation of the process, i.e. at the time of building $\filler[n+1][n]$, a complete $\framep[n]$ will have been built. So, let us call $\framep[n][p]$ the partial $\framep[n]$ built up to the stage $p$ of the construction. Thus, we refine our definition into something like:

\begin{equation*}
  \begin{array}{lll}
    \framep[n][0]                    & \defeq & \unittype                                                                       \\
    \framep[n][p+1]                  & \defeq & \Sigma d:\framep[n][p] .\,(\filler[n][p](d) \times \filler[n][p](d))            \\
    \\
    \filler[n+1][p](d:\framep[n][p]) & \defeq & $\Sigma$ a:(\filler[n][p](d) \times \filler[n][p](d)) .\,\filler[n+1][p+1](d,a)
  \end{array}
\end{equation*}

where $\unittype$ is a canonical singleton type used to initiate the
construction of a list of pairs of $n$-fillers.

Now, the two fillers $\filler[n][p](d)$ and $\filler[n][p](d)$ cannot be any fillers. They have to represent two opposite fillers, and we need a way to express this. The answer is simple. The partial frame has two faces and these two fillers have to respectively fill the left face and the right face of the partial frame. We thus have to rely on operations $\restrf[n][p][L]$ and $\restrf[n][p][R]$ which extract the sides of a frame, leading to the refined definition:

\begin{equation*}
  \begin{array}{lll}
    \filler[n+1][p](d:\framep[n][p]) & \defeq & \Sigma a:(\filler[n][p](\restrf[n][p][L](d)) \times \filler[n][p](\restrf[n][p][R](d))) .\, \filler[n+1][p+1](d,a)
  \end{array}
\end{equation*}

The full explicit definition shall be given in the next sections but, to give an idea, let us show the structure of a $\filler[n]$ for the first three dimensions.

A $\filler[2]$ is made of two $\filler[1]$ connected by a lifted $\filler[1]$ made of two lines connecting the former points and a square connecting the former lines.

\subsection{Formal construction of \texorpdfstring{$\nu$}{nu}-sets}
% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{filler}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrfiller}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohfiller}[D, d]

% Now, we write the type theory bit, and input the abbreviated tables

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and filler
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and filler
% Drop the unviverse letter
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\newcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\newcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and filler
% Keep only ε, ω; n, p; proposition on n and p
\newcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\newcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\newcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[][#2][#3][][][][][#9]}

The definition in \ref{tab:coind}, the coinductive limit, is dispatched over tables \ref{tab:core}, \ref{tab:frames}, \ref{tab:faces} and \ref{tab:coh}. They describe the structure of the underlying higher-dimensional relations on which fillers are built.

\renewcommand*{\lab}{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

We now describe \emph{bare truncated sets}: \emph{bare} because it can be seen as defining truncated $\nu$-sets without face maps, and \emph{truncated} because it is $n$-truncated.

\renewcommand*{\lab}{tab:core}
\input{tab-core.tex}

% Drop the universe letter in fullframe for all remaining tables
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[][#2][][][#3]}
\renewcommand*{\lab}{tab:frames}
\input{tab-frames.tex}

% Truncated sets, otherwise referred to as X
% Drop the universe letter for the third and fourth tables
\renewcommandx{\Xto}[3][3]{\X[][<#2][#3]}
\renewcommandx{\Xcomp}[3][3]{\X[][=#2][#3]}
\renewcommandx{\Xfrom}[3][3]{\X[][\geq#2][#3]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

In the way we have chosen to formlate these tables, there is, for instance, coherence condition $\cohf$ both sides of the equality in $\restrl$ and $\restrc$, to ensure that they are the same type.

For a given $n$, the coherence conditions evaluate to a reflexivity proof, so that the construction evaluates to an effective sequence of types of iterated relations not mentioning $\restrf$ nor $\cohf$ anymore.

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\renewcommand*{\lab}{tab:faces}
\input{tab-faces-ett.tex}

% Restriction for frame, layer, and filler
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[][#2][#3][#4][#5][#6][#7]}

% Frame, layer, and filler
% Drop all arguments for coh table; they're not present in coind table.
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][][][][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][][][][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[][][][][#5]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

The proof of $\cohf$ require a higher-dimensional coherence condition which we obtain by working in \U. If the proofs of the same equality were not equated, there would be a need for arbitrary many higher-dimensional coherences (see e.g.~\cite{herbelin15} for a discussion on the de facto need for recursive higher-dimensional coherence conditions in formulating higher-dimensional structures in type theory).

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\newcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{tab:coh}
\input{tab-coh-ett.tex}


where $\cohtwo{frame}$ is:

\begin{align*}
  \cohf[m][\omega][\theta][r][p][n][p][][d = {\restrf[m][\epsilon][q+2][n][p][][d = \d, D = \D]}, D = \D]\;\bullet         \\
  \ap (\restrf[m][\omega][r][n][p][][d = {\cohf[m][\epsilon][\theta][q+1][p][n][p][][d = \d, D = \D]}, D = \D]\;\bullet    \\
  \cohf[m][\epsilon][\omega][q][r][n][p][][d = {\restrf[m][\theta][p][n][p][][d = \d, D = \D]}, D = \D] =                  \\
  \ap (\restrf[m][\theta][p][n][p][][d = {\cohf[m][\epsilon][\omega][q+1][r+1][n][p][][d = \d, D = \D]}, D = \D])\;\bullet \\
  \cohf[m][\epsilon][\theta][q][p][n][p][][d = {\restrf[m][\omega][r+1][n][p][][d = \d, D = \D]}, D = \D]\;\bullet         \\
  \ap (\restrf[m][\epsilon][q][n][p][][d = {\cohf[m][\omega][\theta][r][p][n][p][][d = \d, D = \D]}, D = \D])
\end{align*}

\newpage
\section{Future work}

\newpage
\appendix
\section{Tables in full detail}
% Full tables in this section
%
% Clear the mask and label
\clearmask

% Keep all arguments for all macros
% Frame, layer, and filler
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[#1][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[#1][#2][#3][#4][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[#1][#2][#3][#4][#5]}
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

% Restriction for frame, layer, and filler
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[#1][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[#1][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{fulltab:coind}
\input{tab-coind.tex}
\renewcommand*{\lab}{fulltab:core}
\input{tab-core.tex}
\renewcommand*{\lab}{fulltab:frames}
\input{tab-frames.tex}

\begin{landscape}
  \renewcommand*{\lab}{fulltab:faces}
  \input{tab-faces.tex}
  \renewcommand*{\lab}{fulltab:coh}
  \input{tab-coh.tex}
\end{landscape}

\bibliographystyle{alpha}
\bibliography{paper}

\end{document}
