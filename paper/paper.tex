\documentclass{msc}

\usepackage{amsmath, amssymb, mathrsfs, mathtools, wasysym, tikz, tikz-cd, lmodern, mathpazo, anyfontsize, xargs, environ, multirow, tabularx, caption, bookmark, booktabs, makecell, colortbl, minted, art.cls/colorpal, art.cls/ct, art.cls/sset, art.cls/lim, art.cls/joinargs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[prefix=bonak]{art.cls/xkeymask}

% Use the patterns library to draw the cubes figure
\usetikzlibrary{patterns}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{painting}{D}{(#1)}
\define@cmdkey[bonak]{painting}{E}{(#1)}
\define@cmdkey[bonak]{painting}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrpainting}{D}{(#1)}
\define@cmdkey[bonak]{restrpainting}{E}{(#1)}
\define@cmdkey[bonak]{restrpainting}{d}{(#1)}
\define@cmdkey[bonak]{restrpainting}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohpainting}{D}{(#1)}
\define@cmdkey[bonak]{cohpainting}{E}{(#1)}
\define@cmdkey[bonak]{cohpainting}{d}{(#1)}
\define@cmdkey[bonak]{cohpainting}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \ensuremath{{\color{carolina}{\nu\textsf{Set}}}_{#1}^{#2}}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and painting: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and painting: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4]}^{\joinargs[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

\newcommandx{\depsmacro}[5][4,5]{
  \ensuremath{\mathsf{\color{strawberry}{#1}}_{
    \joinargs[\mathsf{\color{#3}{#2}}]}^{\joinargs[#4][#5]}}
}

% Coherence conditions for frame, layer, and painting: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaHat}{\ensuremath{\hat{\boldsymbol{\Delta}}}}
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}{\ensuremath{\boldsymbol{{\square}}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommandx{\U}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HSet}}_{#1}}}
\newcommandx{\HGpd}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HGpd}}_{#1}}}
\newcommand{\Type}{\ensuremath{\mathsf{\color{spanish-blue}{Type}}}}
\newcommand{\SProp}{\ensuremath{\mathsf{\color{spanish-blue}{SProp}}}}

% Examples
\newtheorem{example}[therm]{Example}

% The unit and bool types
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\booltype}{\ensuremath{\mathsf{bool}}}
\newcommand{\unitpoint}{\ensuremath{\ast}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\refl}{\ensuremath{\mathsf{refl}}}

% Some abbreviations
\newcommand{\tl}{\ensuremath{\mathsf{tl}}}
\newcommand{\hd}{\ensuremath{\mathsf{hd}}}
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\newcommand{\ap}{\mathsf{ap}\;}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommand{\Dom}{\textsf{Dom}}
\newcommand{\UIP}{\textsf{UIP}}

\newcommand{\udensdash}[1]{%
    \tikz[baseline=(todotted.base)]{
        \node[inner sep=1pt,outer sep=0pt] (todotted) {$#1$};
        \draw[densely dashed] (todotted.south west) -- (todotted.south east);
    }%
}%

% These are renewed in tables, but let's define them now for in-document
% typesetting
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\newcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\newcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\newcommandx{\restrp}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\newcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\newcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\newcommandx{\cohp}{\coh{painting}[][][][][][][][]}
\newcommandx{\fullframe}[1][1]{\prim{fullframe}[][#1][][][]}

\newcommandx{\frametype}[2][1,2]{\prim{FRAME}[][#1][#2][][]}
\newcommandx{\layertype}[2][1,2]{\prim{LAYER}[][#1][#2][][]}
\newcommandx{\paintingtype}[2][1,2]{\prim{PAINTING}[][#1][#2][][]}
\newcommandx{\restrftype}[2][1,2]{\restr{FRAME}[][][][#1][#2][][]}
\newcommandx{\restrltype}[2][1,2]{\restr{LAYER}[][][][#1][#2][][]}
\newcommandx{\restrptype}[2][1,2]{\restr{PAINTING}[][][][#1][#2][][]}
\newcommandx{\cohftype}[2][1,2]{\coh{FRAME}[][][][][][#1][#2][]}
\newcommandx{\cohltype}[2][1,2]{\coh{LAYER}[][][][][][#1][#2][]}
\newcommandx{\cohptype}[2][1,2]{\coh{PAINTING}[][][][][][#1][#2][]}
\newcommandx{\cohttype}[2][1,2]{\cohtwo{FRAME}[][][][][][#1][#2][]}

\newcommandx{\deps}[2][1,2]{\depsmacro{deps}{restr}{russian-green}[#1][#2]}
\newcommandx{\fulldeps}[1][1]{\depsmacro{deps}{fullrestr}{russian-green}[#1]}
\newcommandx{\depscohs}[2][1,2]{\depsmacro{deps}{coh}{chestnut}[#1][#2]}
\newcommandx{\fulldepscohs}[1][1]{\depsmacro{deps}{fullcoh}{chestnut}[#1]}
\newcommandx{\depscoht}[2][1,2]{\depsmacro{deps}{coh2}{chestnut}[#1][#2]}
\newcommandx{\fulldepscoht}[1][1]{\depsmacro{deps}{fullcoh2}{chestnut}[#1]}
\newcommandx{\depstype}[2][1,2]{\depsmacro{DEPS}{restr}{russian-green}[#1][#2]}
\newcommandx{\fulldepstype}[1][1]{\depsmacro{DEPS}{fullrestr}{russian-green}[#1]}
\newcommandx{\depscohstype}[2][1,2]{\depsmacro{DEPS}{coh}{chestnut}[#1][#2]}
\newcommandx{\fulldepscohstype}[1][1]{\depsmacro{DEPS}{fullcoh}{chestnut}[#1]}
\newcommandx{\depscohttype}[2][1,2]{\depsmacro{DEPS}{coh2}{chestnut}[#1][#2]}
\newcommandx{\fulldepscohttype}[1][1]{\depsmacro{DEPS}{fullcoh2}{chestnut}[#1]}

\newcommandx{\coht}[7][1,2,3,4,5,6,7]{\cohtwo{frame}[#3][#4][#5][#6][#7][#1][#2][]}

% Kerning for star
\newcommand{\kstar}{{\star}}

% Caption setup
\DeclareCaptionFormat{plain}{#1#3}
\captionsetup{font=footnotesize,labelfont=bf}

% The eqntable environment
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{eqntable}[1]{
  \small
  \begin{tabularx}{0.94\linewidth}{
    @{}
    >{$}l<{$}
    >{$}c<{$}
    >{$}c<{$}
    >{$}Y<{$}
    @{}}
    \toprule
    \BODY
    \bottomrule
  \end{tabularx}
  \captionof{table}{#1}
}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

% Double-spacing
% \linespread{2}

\begin{document}
\title{The very dependent recursive structure of iterated parametricity in indexed form}
\begin{authgrp}
  \author{Hugo Herbelin}
  \affiliation{Université Paris Cité, Inria, CNRS, IRIF, Paris
    \email{Hugo.Herbelin@inria.fr}}
  \author{Ramkumar Ramachandra}
  \affiliation{Unaffiliated \email{r@artagnon.com}}
\end{authgrp}
\begin{abstract}
  Reynolds' parametricity originally eequips types with binary propositional relations over the types. Such relations can be taken proof-relevant, or unary, and described either in an indexed or fibered way. Parametricity can be iterated, and when types are sets, this results in an interpretation of sets as augmented semi-simplicial sets (unary case) or semi-cubical sets (binary case).
  In a previous paper, we gave equations describing $n$-ary iterated parametricity in indexed form. The construction was formalised in the Rocq (formerly, Coq) proof assistant using a rather complex induction on a large structure embedding equational reasoning.

  The current paper analyses the very dependent recursive structure of the equations of the former paper leading to a new terse presentation of the construction where all equational reasoning is replaced by definitions. Now reduced to its computational essence, it can be described in full details, closely following the corresponding new machine-checked formalisation.
\end{abstract}
\maketitle
\vspace{-2em} % Remove space after abstract

\section{Introduction}

\paragraph*{Parametricity and its ramifications.}

Introduced by Reynolds in the context of programming language semantics~\cite{reynolds83}, relational parametricity happens to be connected to several similar concepts in logic and mathematics. Associating binary propositional relations to types in its original formulation, it can also associate proof-relevant relations~\cite{GhaniNordvallOrsanigo16} or unary relations, that is predicates (proof-irrelevant case) or families (relevant case). These unary or binary, relevant or proof-irrelevant relations express what it means to belong in a type (unary case) or to be equal in a type (binary case) from an observational point of view. For instance, the canonical predicate associated to $A \rightarrow B$ is the predicate over functions $f$ in $A \rightarrow B$ such that, for all $a$ in the canonical predicate associated to $A$, $f(a)$ is in the canonical predicate associated to $B$. And, similarly, the canonical relation associated to $A \rightarrow B$ is the relations over functions $f$ and $f'$ in $A \rightarrow B$ such that, for all $a$ and $a'$ related through the canonical relation associated to $A$, $f(a)$and $f'(a')$ are related through the canonical relation associated to $B$.

\newcommand{\real}{\textsf{r}}

From the point of view of realisability, unary parametricity over a language is a realisability using the language itself as language of realisers. Like parametricity, realisability can be expressed in a \emph{syntactic} way, that is as an interpretation from one language to another (i.e. mapping an expression $t$ of $\vdash A$ in some formal system to a derivation $t^*$ of $\vdash' |t| \real A$ in some other formal system, for some program $|t|$ extracted from $t$ -- namely $t$ itself in the case of parametricity), or a \emph{semantic} way\footnote{This distinction between syntactic realisability and semantic realisability is itself connected to the difference between relative and absolute consistency. In the relative case, consistency of a formal system is reduced to the consistency of another formal system, and this can be done in a very weak logical system such as Primitive Recursive Arithmetic (PRA). On the other side, in the absolute case, consistency of a formal system is reduced to the consistency of the language of discourse, which, by G\"odel incompleteness theorem, if actually consistent, necessarily has to be as strong as the modelled formal system.}, that is as an interpretation in the language of discourse, which we could call in term the ``metalanguage'' (i.e. interpreting $A$ as a set $\textbf{A}$ or a relation $=_A$ of the language of discourse and interpreting a derivation $t$ of $\vdash A$ as an expression $|t|$ such that, respectively, $|t| \in \textbf{A}$ or $|t| =_A |t|$). Thus, the comparison between parametricity and realisability includes the case of \emph{reducibility}~\cite{Tait}, which is a semantic form of realisability, also known as \emph{glueing} in the context of category theory. In the same vein, binary parametricity over a language can be seen as defining \emph{logical relations}~\cite{Plotkin} over itself, since logical relations are a binary form of reducibility.

Parametricity, like realisability, reducibility, and logical relations, was most commonly handled in an \emph{indexed} form, that is, using a type-theoretic language, considering predicates of type $A \rightarrow \Prop$, or families of type $A \rightarrow \Set$, or relations of type $A \times A \rightarrow \Prop$, or relevant relations -- sometimes called \emph{correspondences} -- of type $A \times A \rightarrow \Set$, where $\Prop$ and $\Set$ are types representing, that is classifying -- in category theory terminology --, propositions or sets, respectively. Along the indexed-fibered correspondence, that is along the equivalence between the types $A \rightarrow \Prop$ and $\Sigma B:\Set. (B \stackrel{inj}{\rightarrow} A)$ (proof-irrelevant case) and $A \rightarrow \Set$ and $\Sigma B:\Set. (B \rightarrow A)$ (proof-relevant case), for $A:\Set$, everything told in the indexed form can morally also be told in \emph{fibered} form. Such fibered approach to parametricity was for instance considered in Ghani \cite{Ghani...}, who also suggested to iterate parametricity.

\paragraph*{Iterated parametricity.}

The internalisation of parametricity in unary indexed form was studied by \cite{bernardy12} directly leading to a type theory of iterated parametricity. Such type theory could be interpreted in a ``unary'' form of cubical set~\citep{bernardy15}, thus implicitly in fibered form since, in a binary cubical set (resp. in a unary cubical set and simplicial set as well), a set of segments over two points, that is a relevant relation, is given by first and second projection rather than as a function to $\Set$ (resp. a family is given as a \emph{total space} projected over a set of points $A:\Set$ rather than a family of type $A \rightarrow \Set$. This connection between iterated binary parametricity in fibered form and cubical sets includes an identification of degeneracies and reflexivity proofs, which can also be found in \cite{johann17}. In particular, it became clear at this point that iterated binary parametricity (without reflexivity) produces semi-cubical sets while it was also observed\footnote{The authors learned it from Hugo Moeneclaey and Thorsten Altenkirch.} that iterated unary parametricity produces augmented semi-simplicial sets.

\begin{tabularx}{0.94\linewidth}{cYcYYl}
  \toprule
  arity                       & formalisation style        & iteration                       & relevance        & logical structure               \\
  \midrule
  \multirow{6}{0.4cm}{unary}  & \multirow{3}{1cm}{indexed} & \multirow{2}{2cm}{non-iterated} & proof-irrelevant & predicate                       \\
                              &                            &                                 & relevant         & family                          \\
                              &                            & iterated                        & relevant         & \emph{this work}                \\
                              & \multirow{3}{1cm}{fibered} & \multirow{2}{2cm}{non-iterated} & proof-irrelevant & subobject                       \\
                              &                            &                                 & relevant         & fibration                       \\
                              &                            & iterated                        & relevant         & augmented semi-simplicial set   \\
  \midrule
  \multirow{6}{0.4cm}{binary} & \multirow{3}{1cm}{indexed} & \multirow{2}{2cm}{non-iterated} & proof-irrelevant & relation                        \\
                              &                            &                                 & relevant         & correspondence                  \\
                              &                            & iterated                        & relevant         & \emph{this work}                \\
                              & \multirow{3}{1cm}{fibered} & \multirow{2}{2cm}{non-iterated} & proof-irrelevant & fibered relation                \\
                              &                            &                                 & relevant         & span                          & \\
                              &                            & iterated                        & relevant         & semi-cubical set                \\
  \bottomrule
\end{tabularx}

In \cite{hr25}, this correspondence was exploited to construct at the same time augmented semi-simplicial and semi-cubical sets in \emph{indexed form} as a special case of iterated parametricity. That is, instead of the following illustration of the semi-cubical case (upto faces identities),

\begin{equation*}
  \begin{tikzcd}
    X_0: \U & X_1: \U \arrow[l, "\partial^L" description, shift left=2] \arrow[l, "\partial^R" description, shift right=2] & X_2: \U \arrow[l, "\partial^{L\kstar}" description, shift left=6] \arrow[l, "\partial^{R\kstar}" description, shift left=2] \arrow[l, "\partial^{\kstar L}" description, shift right=2] \arrow[l, "\partial^{\kstar R}" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}
a family of relevant relations was considered, as shown below:
\begin{equation*}
  \begin{array}{lll}
    E_0 & :               \U                                                                          \\
    E_1 & :               E_0 \times X_0 \rightarrow  \U                                              \\
    E_2 & : \Pi a b c d.\,  E_1(a,b) \times E_1 (c,d) \times E_1(a,c) \times E_1 (b,d) \rightarrow \U \\
    \ldots
  \end{array}
\end{equation*}

% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{painting}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrpainting}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohpainting}[D, d]

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and painting
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and painting
% Drop the universe letter
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrp}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
% Keep only ε, ω; n, p; proposition on n and p
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\renewcommandx{\cohp}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][][][][][#9]}

For $\nu$ an arity, that is $1$ in the case of predicates, families and augmented semi-simplicial sets or $2$ in the case of relations, correspondences and semi-cubical sets, such sequence of was called a $\nu$-set. Equations specifying $\nu$-sets were given in \cite{hr25}. Because of the dependency of $E_{n+1}$ into all $E_p$ for $p \leq n$, the family could not be expressed as a function. Instead, it was expressed as a stream whose $(n+1)$-th element $E_{n+1}$ was dependent on the bundle of all previous elements of the stream. Such a bundle was called $\Xto{m}{n}$ while the residual stream of all $E_{n}$, $E_{n+1}$, ..., all of them precisely dependent on the bundle $E:\Xto{m}{n}$ of previous $E_0$, ..., $E_{n-1}$, was called $\Xfrom{m}{n}{D}$. The type of $E_n$, also dependent on a bundle $D:\Xto{m}{n}$, was denoted $\Xcomp{m}{n}[D=\D]$, as shown on tables~\ref{tab:coind} and~\ref{tab:core}. When $n$ is $0$, $\Xto{m}{0}$ is degenerated, that is reduced to the canonical inhabitant $\kstar$ of $\unittype$. Then, $\Xfrom{m}{0}{\kstar}$ denotes the full stream $E_0, E_1, \ldots$.

The type $\Xcomp{m}{n}[D=E_0,\ldots,E_{n-1}]$ of $E_n$ represents a family whose type can be presented into the form $\fullframe(E_0,\ldots,E_{n-1}) \rightarrow \U$ where $\fullframe$ collects all the components on which $E_n$ is expected to depend. It is recursively defined in table~\ref{tab:frames}, using the auxiliary definitions of $\framep$, $\layer$ and $\painting$. A $\fullframe$ describes a boundary of a standard form (simplex, cube), which we decompose into $\layer$, and a $\painting$ corresponds to a filled frame. Notice that the type $\layer$ relies on an operator of frame restriction $\restrf$ which is defined in table~\ref{tab:faces}, and this restriction operator is in turn defined using auxiliary definitions $\restrl$ and $\restrp$.

Notably, the definition of $\restrl$ relies on an equality expressing the commutation of the composition of two $\restrf$. The proof of this commutation is worth being made explicit, which we do in table~\ref{tab:coh} using proof-term notations. The proof is by recursion on the structure of $\framep$, $\layer$, and $\painting$. This is what $\cohf$ does using auxiliary proofs $\cohl$ and $\cohp$. Note that for a fixed constant $n$, relying on the evaluation rules of type theory, the coherence conditions degenerate to a reflexivity proof, so that the construction builds an effective sequence of types not mentioning coherences anymore.

TODO: say that the table are relative to ETT and that many type coercions are implicit.

Due to the intricate dependencies, the reason the whole construction is recursively well-defined is not simple. The formalisation in \cite{hr25} was recursively building a complex structure involving $3$ levels of the construction at once. In the present paper, we untangle the previous construction, making the dependencies explicit, and the new construction lends itself to a simple and complete explanation.

\def\lab{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

\def\lab{tab:core}
\input{tab-core.tex}

\def\lab{tab:frames}
\input{tab-frames.tex}

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\def\lab{tab:faces}
\input{tab-faces-ett.tex}

% Restriction for frame, layer, and painting
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrp}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohp}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][#4][#5][#6,#7][#8][#9]}

\def\lab{tab:coh}
\input{tab-coh-ett.tex}

\renewcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\renewcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\renewcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\renewcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrp}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\renewcommandx{\cohf}[6][1,2,3,4,5,6]{\coh{frame}[][#3][#4][#5][#6][#1][#2][]}
\renewcommandx{\cohl}[6][1,2,3,4,5,6]{\coh{layer}[][#3][#4][#5][#6][#1][#2][]}
\renewcommandx{\cohp}[6][1,2,3,4,5,6]{\coh{painting}[][#3][#4][#5][#6][#1][#2][]}

\section{Outline of the recursive structure of iterated parametricity construction}

In \citep{hr25}, the well-foundedness was justified by induction on $n$ and subinductions, one on $p$ to mutually build $\framep[n][p]$, $\restrf[n][p]$ and $\cohf[n][p]$, and three others to build each of $\painting[n][p]$, $\restrp[n][p]$ and $\cohp[n][p]$ by induction on $n-p$.

In the current paper and associated formalisation, we take $\framep[n-2][p]$ $\painting[n-2][p]$, $\restrf[n-1][p]$ and $\restrp[n-1][p]$ as references and rename them respectively as $\framep[n][p]$, $\painting[n][p]$, $\restrf[n][p]$ and $\restrp[n][p]$. We replace the equational properties of $\framep[n][p]$, $\framep[n-1][p]$, $\restrf[n][p]$, $\painting[n][p]$, $\painting[n-1][p]$ and $\restrp[n][p]$ with definitions, renaming them respectively to $\framep[n+2][p]$, $\framep[n+1][p]$, $\restrf[n+1][p]$, $\painting[n+2][p]$, $\painting[n+1][p]$ and $\restrp[n+1][p]$. This means that we build instead by induction a block of the form:

\begin{equation*}
  \begin{array}{lclr}
    \framep[n][p]   & : & \U                                                                                                  & \mbox{for all $p\leq n$} \\
    \painting[n][p] & : & \framep[n][p] \rightarrow \U                                                                        & \mbox{for all $p\leq n$} \\
    \restrf[n][p]   & : & \Pi q \leq n-p.\, \Pi \epsilon.\, \framep[n+1][p] \rightarrow \framep[n][p]                         & \mbox{for all $p\leq n$} \\
    \restrp[n][p]   & : & \Pi q \leq n-p.\, \Pi \epsilon.\, \Pi d:\framep[n+1][p].\,                                                                     \\
                    &   & \painting[n+1][p](d) \rightarrow \painting[n][p](\restrf[n][p](d))                                  & \mbox{for all $p\leq n$} \\
    \cohf[n][p]     & : & \Pi qr\epsilon\omega.\, \restrf[n][p][q][\epsilon] \circ \restrf[n+1][p][\omega][r] =                                          \\
                    &   & \restrf[n][p][\omega][r] \circ \restrf[n+1][p][q+1][\epsilon]                                       & \mbox{for all $p\leq n$} \\
    \cohp[n][p]     & : & \Pi qr\epsilon\omega.\,\Pi d:\framep[n+2][p].\,                                                                                \\
                    &   & \restrp[n][p][q][\epsilon](\restrf[n+1][p][r][\omega](d)) \circ \restrp[n+1][p][r][\omega](d) =                                \\
                    &   & \restrp[n][p][r][\omega](\restrf[n+1][p][q+1][\epsilon](d)) \circ \restrp[n+1][p][q+1][\epsilon](d) & \mbox{for all $p\leq n$} \\
  \end{array}
\end{equation*}

Turning $\framep[n+2][p]$, $\framep[n+1][p]$ and $\restrf[n+1][p]$ into definitions involves however circularities. To start with, the definition of $\framep[n+1][p]$, which is by induction on $p$, depends on $\restrf[n][p-1]$ whose type depends in turn on $\framep[n+1][p-1]$. This means that $\framep[n+1][p]$ and the type of $\restrf[n][p]$ have to be mutually defined.

The definition of $\framep[n+1][p]$ also depends, via $\layer[n][p-1]$, on $\painting[n][p-1]$. Both via $\painting[n][p-1]$ and $\restrf[n][p-1]$, it depends also on $\framep[n][p-1]$ by typing dependency. This requires to assume $\framep[n][p-1]$ and $\painting[n][p-1]$ known in advance.
Moreover, the definition of $\framep[n+1][p]$ depends on $\framep[n+1][p-1]$, so all of $\framep[n][k]$, $\painting[n][k]$ and $\restrf[n][k]$ for $k< p$ need to be known, which we respectively abbreviate as $\framep[n][\lbrack 0,p-1 \rbrack]$, $\painting[n][\lbrack 0,p-1 \rbrack]$ and $\restrf[n][p-1]$.
Schematically, using dotted arrows for dependencies in the type and plain arrows for dependencies in the definition, this gives the following dependencies for $p\leq n+1$ fixed:
\begin{center}
  \begin{tikzcd}
    \framep[n+1][\lbrack 0,p \rbrack] \arrow[d] \arrow[ddr]\\
    \painting[n][\lbrack 0,p-1 \rbrack] \arrow[d, dotted] \\
    \framep[n][\lbrack 0,p-1 \rbrack] &
    \restrf[n][\lbrack 0,p-1 \rbrack] \arrow[l, dotted] \arrow[uul, dotted, "\mbox{$[0,p-1]$}"', near start, shift right=2mm, hook']\\
  \end{tikzcd}
\end{center}

In particular, the mutual dependency on one side of $\framep[n][\lbrack 0,p-1 \rbrack]$ within the type of $\restrf[n][\lbrack 0,p-1 \rbrack]$ and on the other side of $\restrf[n][\lbrack 0,p-1 \rbrack]$ within the definition of $\framep[n][\lbrack 0,p \rbrack]$ requires to mutually define the type of $\restrf[n][\lbrack 0,p-1 \rbrack]$ together with $\framep[n][p]$ (or $\framep[n][\lbrack 0,p \rbrack]$) as a \emph{function} from $\restrf[n][\lbrack 0,p-1 \rbrack]$.

So far, using this recursive definition of  $\framep[n][\lbrack 0,p-1 \rbrack]$ and $\restrf[n][\lbrack 0,p-1 \rbrack]$, we are able to specify the three first component of the exected dependent structure:
\begin{equation*}
  \begin{array}{lclr}
    \framep[n][p]             & :                        & \U                                                & \mbox{for all $p\leq n$} \\
    \painting[n][p]           & :                        & \framep[n][p] \rightarrow \U                      & \mbox{for all $p\leq n$} \\
    \restrf[n][p]             & :                        & \Pi q \leq n-p.\, \Pi \epsilon.\, \framep[n+1][p]
    \left(\begin{array}{l}
              \framep[n][\lbrack 0,p-1 \rbrack]   \\
              \painting[n][\lbrack 0,p-1 \rbrack] \\
              \restrf[n][\lbrack 0,p-1 \rbrack]   \\
            \end{array}\right)
    \rightarrow \framep[n][p] & \mbox{for all $p\leq n$}                                                                                \\
  \end{array}
\end{equation*}
which can appropriately be reformulated using sequences for appropriate definitions of $\frametype[n][\lbrack 0,p \rbrack]$, $\paintingtype[n][\lbrack 0,p \rbrack]$ and $\restrftype[n][\lbrack 0,p \rbrack]$, since the dependencies of $\restrf[n][p]$ into $\restrf[n][\lbrack 0,p-1 \rbrack]$ makes it a very dependent function~\citep{Hickey96}:
\begin{equation*}
  \begin{array}{lcl}
    \framep[n][\lbrack 0,p \rbrack]   & : & \frametype[n][\lbrack 0,p \rbrack]                                     \\
    \painting[n][\lbrack 0,p \rbrack] & : & \paintingtype[n][\lbrack 0,p \rbrack](\framep[n][\lbrack 0,p \rbrack]) \\
    \restrf[n][\lbrack 0,p \rbrack]   & : & \restrftype[n][\lbrack 0,p \rbrack]
    \left(\begin{array}{l}
              \framep[n][\lbrack 0,p-1 \rbrack]   \\
              \painting[n][\lbrack 0,p-1 \rbrack] \\
              \restrf[n][\lbrack 0,p-1 \rbrack]   \\
            \end{array}\right)                                                                      \\
  \end{array}
\end{equation*}

The type of sequences such as $\restrf[n][\lbrack 0,p \rbrack]$ will be represented by iterated $\Sigma$-types since each $\restrf[n][p]$ may depend on the previous components of the sequence. In the case of $\framep$ and $\painting$, there will be however no dependency, so an ordinary product can be used to represent $\framep[n][\lbrack 0,p \rbrack]$ and $\painting[n][\lbrack 0,p \rbrack]$. Later on, we will write $\framep[n][\lbrack 0,p-1 \rbrack]$ for the immediate subsequence of length $p$ of $\framep[n][\lbrack 0,p \rbrack]$ and $\framep[n][p]$ for its last component, and similarly for $\painting[n][\lbrack 0,p \rbrack]$, $\restrf[n][\lbrack 0,p \rbrack]$, etc.

\section{The construction}

\subsection{Specifying frames}

Assuming $\framep[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$ only requires to define the type of frames, which are just finite products of $\U$:

\begin{equation*}
  \begin{array}{llcl}
    \frametype[n][\lbrack 0,p-1 \rbrack] &  & :      & \U                                               \\
    \frametype[n]                        &  & \defeq & \unittype                                        \\
    \frametype[n][\lbrack 0,p \rbrack]   &  & \defeq & \frametype[n+1][\lbrack 0,p-1 \rbrack] \times \U \\
  \end{array}
\end{equation*}

\subsection{Specifying paintings}

The types $\paintingtype[n][\lbrack 0,p-1 \rbrack]$ of $\painting[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$ are type families over frames, so $\framep[n][\lbrack 0,p-1 \rbrack]$ needs to be assumed beforehand:

\begin{equation*}
  \begin{array}{llcl}
    \paintingtype[n][\lbrack 0,p-1 \rbrack] & \framep[n][\lbrack 0,p \rbrack] & :      & \U                                                                                                                   \\
    \paintingtype[n]                        & \unitpoint                      & \defeq & \unittype                                                                                                            \\
    \paintingtype[n][\lbrack 0,p \rbrack]   & \framep[n][\lbrack 0,p \rbrack] & \defeq & \paintingtype[n+1][\lbrack 0,p-1 \rbrack](\framep[n+1][\lbrack 0,p-1 \rbrack]) \times (\framep[n][p] \rightarrow \U) \\
  \end{array}
\end{equation*}

\subsection{Defining frames and specifying frame restrictions}

Assuming $\framep[n][\lbrack 0,p-1 \rbrack]$ and $\painting[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$, we can mutually define the types $\restrftype[n][\lbrack 0,p-1 \rbrack]$ of frame restrictions together with $\framep[n+1][\lbrack 0,p-1 \rbrack]$ as a function from $\restrf[n][\lbrack 0,p-1 \rbrack]$, introducing also abbreviations for the types and definitions of layers, as well as for the combination of sequences of $\framep[n][\lbrack 0,p-1 \rbrack]$, $\painting[n][\lbrack 0,p-1 \rbrack]$ and $\restrf[n][\lbrack 0,p-1 \rbrack]$ in one block, which we call $\depstype[n][\lbrack 0,p-1 \rbrack]$:

\begin{equation*}
  \begin{array}{llcl}
    \depstype[n][\lbrack 0,p-1 \rbrack]    &        & \defeq                               &
    \left(\begin{array}{lll}
              \framep[n][\lbrack 0,p-1 \rbrack]   & : & \frametype[n][\lbrack 0,p-1 \rbrack]    \\
              \painting[n][\lbrack 0,p-1 \rbrack] & : & \paintingtype[n][\lbrack 0,p-1 \rbrack]
              (\framep[n][\lbrack 0,p-1 \rbrack])                                               \\
              \restrf[n][\lbrack 0,p-1 \rbrack]   & : & \restrftype[n][\lbrack 0,p-1 \rbrack]
              \left(\begin{array}{l}
                  \framep[n][\lbrack 0,p-1 \rbrack]   \\
                  \painting[n][\lbrack 0,p-1 \rbrack] \\
                \end{array}\right)                                         \\
            \end{array}\right)  \\
    \framep[n+1][\lbrack 0,p \rbrack]      &
    \deps[n][\lbrack 0,p-1 \rbrack]        & :      & \frametype[n+1][\lbrack 0,p \rbrack]   \\
    \framep[n+1][\lbrack 0,0 \rbrack]      &
    \unitpoint                             & \defeq & (\unitpoint,\unittype)                 \\
    \framep[n+1][\lbrack 0,p+1 \rbrack]    &
    \deps[n][\lbrack 0,p \rbrack]          & \defeq &
    \left(\begin{array}{l}
              \framep[n+1][\lbrack 0,p \rbrack]
              (\deps[n][\lbrack 0,p-1 \rbrack]), \\
              \Sigma d:\framep[n+1][p]
              (\deps[n][\lbrack 0,p-1 \rbrack]).
              \, \layer[n][p]
              (\deps[n][\lbrack 0,p \rbrack])
              (d)                                \\
            \end{array}\right)                                                 \\
    \restrftype[n][\lbrack 0,p-1 \rbrack]  &
    \left(\begin{array}{l}
              \framep[n][\lbrack 0,p-1 \rbrack]   \\
              \painting[n][\lbrack 0,p-1 \rbrack] \\
            \end{array}\right) & :      & \U                                                \\
    \restrftype[n]                         &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)                 & \defeq &
    \unittype                                                                                \\
    \restrftype[n][\lbrack 0,p \rbrack]    &
    \left(\begin{array}{l}
              \framep[n][\lbrack 0,p \rbrack]   \\
              \painting[n][\lbrack 0,p \rbrack] \\
            \end{array}\right)   & \defeq &
    \begin{array}{l}
      \Sigma \restrf[n][\lbrack 0,p-1 \rbrack]
      :\restrftype[n][\lbrack 0,p-1 \rbrack]
      \left(\begin{array}{l}
                \framep[n+1][\lbrack 0,p-1 \rbrack]   \\
                \painting[n+1][\lbrack 0,p-1 \rbrack] \\
              \end{array}\right).         \\
      \Pi q \leq n-p.\,\Pi \epsilon.\,\framep[n+1][p]
      \left(\begin{array}{l}
                \framep[n][\lbrack 0,p-1 \rbrack]   \\
                \painting[n][\lbrack 0,p-1 \rbrack] \\
                \restrf[n+1][\lbrack 0,p-1 \rbrack] \\
              \end{array}\right) \rightarrow  \framep[n][p] \\
    \end{array}                       \\
    \layertype[n][p]                       &
    \deps[n][\lbrack 0,p \rbrack]
                                           & :      & \U                                     \\
    \layertype[n][p]                       &
    \deps[n][\lbrack 0,p \rbrack]
                                           & \defeq & \framep[n+1][p]
    (\deps[n][\lbrack 0,p-1 \rbrack])
    \rightarrow \U                                                                           \\
    \layer[n][p]                           &
    \deps[n][\lbrack 0,p \rbrack]
                                           & :      & \layertype[n][p]
    (\deps[n][\lbrack 0,p \rbrack])
    \\
    \layer[n][p]                           &
    \deps[n][\lbrack 0,p \rbrack]
                                           & \defeq &
    d \mapsto \Pi\epsilon.\,\painting[n][p](\restrf[n][p][0][\epsilon](d))                   \\
  \end{array}
\end{equation*}

Note that we write $\framep$, $\painting$, $\restrf$ for the
projections of a $\deps$. Also, by abuse of notation, we write $\unitpoint$ for
the only inhabitant of $\depstype[n]$.

\subsection{Defining paintings}

Defining $\painting[n+1][p]$ for $p \leq n+1$, in addition to the type dependency in $\framep[n+1][p]$, requires the definition of $\painting[n][p-1]$, thus also $\framep[n][p-1]$ by typing dependency, as well as $\restrf[n][p-1]$. Since $\painting[n+1][p]$ also depends on $\painting[n+1][p+1]$ when $p<n+1$, these dependencies are actually between $\painting[n+1][\lbrack p,n+1 \rbrack]$, $\painting[n][\lbrack p,n \rbrack]$, $\framep[n+1][\lbrack p,n+1 \rbrack]$, $\framep[n][\lbrack p,n \rbrack]$ and $\restrf[n][\lbrack p,n \rbrack]$. Also, for the case $p=n$, this requires the assumption of an inhabitant $X_{n}$ of $\nu$Set$^{=n}$. Finally, $\framep[n+1][\lbrack p,n+1 \rbrack]$, $\framep[n+1][\lbrack p,n \rbrack]$ and $\restrf[n][\lbrack p,n \rbrack]$ respectively depend on the earlier values $\framep[n+1][\lbrack 0,p-1 \rbrack]$, $\framep[n][\lbrack 0,p-1 \rbrack]$ and $\restrf[n][\lbrack 0,p-1 \rbrack]$.  Below, we use dashed underline and dashed arrows for dependencies in subconstructions, here in the construction of $\framep$ at level $n$ and $\restrftype$ at level $n$:
\begin{center}
  \begin{tikzcd}
    & & \painting[n+1][\lbrack p,n+1 \rbrack] \arrow[dd, bend right=70] \arrow[dddr] \arrow[d, dotted]\\
    \udensdash{\framep[n+1][\lbrack 0,p-1 \rbrack]} \arrow[d, dashed] \arrow[ddr, dashed] & &
    \udensdash{\framep[n+1][\lbrack p,n+1 \rbrack]} \arrow[ll, dotted] \arrow[d, dashed] \arrow[ddr, dashed, shift right=2mm] \\
    \painting[n][\lbrack 0,p-1 \rbrack] \arrow[d, dotted] & &
    \painting[n][\lbrack p,n-1 \rbrack] \arrow[ll, dotted] \arrow[d, dotted] \\
    \framep[n][\lbrack 0,p-1 \rbrack] &
    \udensdash{\restrf[n][\lbrack 0,p-1 \rbrack]} \arrow[l, dotted] \arrow[uul, dotted, shift right=2mm, hook'] &
    \framep[n][\lbrack p,n \rbrack] \arrow[ll, dotted, bend left=15] &
    \udensdash{\restrf[n+1][\lbrack p,n \rbrack]},X_n \arrow[ll, dotted, bend left=15] \arrow[l, dotted] \arrow[uul, dotted, hook']\\
  \end{tikzcd}
\end{center}

Let us introduce another abbreviation to combine a full $\deps[n][\lbrack 0,n \rbrack]:\depstype[n][\lbrack 0,n \rbrack]$ with a family $E:\framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack])\rightarrow \U$:
\begin{equation*}
  \fulldepstype[n] \defeq
  \left(\begin{array}{lcl}
      \deps[n][\lbrack 0,n \rbrack] & : & \depstype[n][\lbrack 0,n \rbrack]                               \\
      E                             & : & \framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack]) \rightarrow \U \\
    \end{array}\right)
\end{equation*}

TODO: say the convention on projection in the Introduction

Also, when $n$ is 0, we write $E$ to denote an element $(\unitpoint, E)$ of $\fulldepstype[0]$.

We can now formally define $\painting[n+1][p]$ for $p \leq n+1$ by recursion on $n-p$:
\begin{equation*}
  \begin{array}{llcl}
    \painting[n+1][p]        &
    \fulldeps[n]             & :      & \paintingtype[n+1][p]   \\
    \painting[n+1][n+1]      &
    \fulldeps[n]             & \defeq & E                       \\
    \painting[n+1][p \leq n] &
    \fulldeps[n]             & \defeq & d \mapsto
    \left(\begin{array}{l}
              \Sigma l:\layer[n][p](\deps[n][\lbrack 0,p \rbrack]). \\
              \painting[n+1][p+1]
              (\fulldeps[n])(d,l)                                   \\
            \end{array}\right) \\
  \end{array}
\end{equation*}

From which we can deduce $\painting[n+1][\lbrack 0,p-1 \rbrack]$ for $p \leq n+2$ by a second recursion, this time on $p$:

\begin{equation*}
  \begin{array}{llcl}
    \painting[n+1][\lbrack 0,p-1 \rbrack] &
    \fulldeps[n]                          & :      & \paintingtype[n+1][\lbrack 0,p-1 \rbrack](\framep[n+1][\lbrack 0,p-1 \rbrack](\deps[n][\lbrack 0,p-1 \rbrack])) \\
    \painting[n+1]                        &
    \fulldeps[n]                          & \defeq & \unittype                                                                                                       \\
    \painting[n+1][\lbrack 0,p \rbrack]   &
    \fulldeps[n]
                                          & \defeq &
    (\painting[n+1][\lbrack 0,p-1 \rbrack](\fulldeps[n-1]),\painting[n+1][p](\fulldeps[n]))                                                                          \\
  \end{array}
\end{equation*}

\subsection{Specifying painting restrictions}

At this stage, we are able to define $\framep[n+1][\lbrack 0,n+1 \rbrack]$, $\painting[n+1][\lbrack 0,n+1 \rbrack]$ and $\restrftype[n][\lbrack 0,n \rbrack]$ from $\framep[n][\lbrack 0,n \rbrack]$, $\painting[n][\lbrack 0,n \rbrack]$ and $\restrf[n][\lbrack 0,n \rbrack]$, that is from $\deps[n][\lbrack 0,n \rbrack]$. To go further, we need to define the sequence $\restrptype[n][\lbrack 0,p-1 \rbrack]$ of types of painting restrictions, for $p \leq n+1$:

\begin{equation*}
  \begin{array}{llcl}
    \restrptype[n][\lbrack 0,p-1 \rbrack] &
    \fulldeps[n]                          & :      & \U                                                         \\
    \restrptype[n]                        & E      & \defeq                                         & \unittype \\
    \restrptype[n][\lbrack 0,p \rbrack]   &
    \fulldeps[n]
                                          & \defeq & \restrptype[n+1][\lbrack 0,p-1 \rbrack] \times             \\
                                          &        &                                                & \left(
    \begin{array}{l}
        \Pi q \leq n-p.\Pi \epsilon.\Pi d:\framep[n+1][p](\deps[n][\lbrack 0,p-1 \rbrack]). \\
        \painting[n+1][p]
        (\fulldeps[n])(d) \rightarrow                                                       \\ \painting[n][p](\restrf[n][p][q][\epsilon](d))\end{array}
    \right)                                                                                                     \\
  \end{array}
\end{equation*}

\subsection{Defining frame restrictions and specifying frame coherence laws}

Thanks to $\restrptype[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$, we can mutually define $\restrf[n+1][\lbrack 0,p \rbrack]$ and $\cohftype[n][\lbrack 0,p-1 \rbrack]$ from $\framep[n][\lbrack 0,n \rbrack]$, $\painting[n][\lbrack 0,n \rbrack]$, $\restrf[n][\lbrack 0,n \rbrack]$, $\restrptype[n][\lbrack 0,p-1 \rbrack]$ and some $E:\framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack]) \rightarrow \U$, abbreviating these dependencies and the dependency in a $\cohf[n][\lbrack 0,p-1 \rbrack]$ as $\depscohstype[n][\lbrack 0,p-1 \rbrack]$, and using also abbreviations in passing for $\restrl$ and $\restrltype$. It is also convenient to build $\deps[n+1][\lbrack 0,p \rbrack]$ from $\depscohs[n][\lbrack 0,p-1 \rbrack]$, so that we can now build $\framep[n+2][p]$ one step further. Thus, we also include this abbreviation in the definition:
\begin{equation*}
  \begin{array}{llcl}
    \depscohstype[n][\lbrack 0,p-1 \rbrack] &                                     & \defeq                                                         &
    \left(\begin{array}{lcl}
              \fulldeps[n]                      & : & \fulldepstype[n]                                    \\
              \restrp[n][\lbrack 0,p-1 \rbrack] & : & \restrptype[n][\lbrack 0,p-1 \rbrack](\fulldeps[n]) \\
              \cohf[n][\lbrack 0,p-1 \rbrack]   & : & \cohftype[n][\lbrack 0,p-1 \rbrack]
              \left(\begin{array}{l}
                  \fulldeps[n]                      \\
                  \restrp[n][\lbrack 0,p-1 \rbrack] \\
                \end{array}\right)                                                     \\
            \end{array}\right)                                                \\
    \overline{\deps}                        &
    \depscohs[n][\lbrack 0,p-1 \rbrack]     & :                                   & \depstype[n+1][\lbrack 0,p \rbrack]                              \\
    \overline{\deps}                        & \depscohs[n][\lbrack 0,p-1 \rbrack] & \defeq                                                         &
    \left(\begin{array}{l}
              \framep[n+1][\lbrack 0,p \rbrack](\deps[n][\lbrack 0,p-1 \rbrack])     \\
              \painting[n+1][\lbrack 0,p \rbrack](\fulldeps[n])                      \\
              \restrf[n+1][\lbrack 0,p \rbrack](\depscohs[n][\lbrack 0,p-1 \rbrack]) \\
            \end{array}\right)                                                                     \\
    \restrf[n+1][\lbrack 0,p \rbrack]       &
    \depscohs[n][\lbrack 0,p-1 \rbrack]     & :                                   &
    \restrftype[n+1][\lbrack 0,p \rbrack]
    \left(\begin{array}{l}
              \framep[n+1][\lbrack 0,p \rbrack](\deps[n][\lbrack 0,p \rbrack]) \\
              \painting[n+1][\lbrack 0,p \rbrack](\fulldeps[n])                \\
            \end{array}\right)                                                                           \\
    \restrf[n+1][\lbrack 0,0 \rbrack]       &
    E
                                            & \defeq                              & (\unitpoint,\lambda q. \lambda\epsilon. \lambda \_.\unitpoint)   \\
    \restrf[n+1][\lbrack 0,p+1 \rbrack]     &
    \depscohs[n][\lbrack 0,p \rbrack]       & \defeq                              &
    \left(\begin{array}{l}
              \restrf[n+1][\lbrack 0,p \rbrack][q][\epsilon]
              (\depscohs[n][\lbrack 0,p-1 \rbrack]),
              \lambda q.\lambda \epsilon.\lambda (d,l).        \\
              \left(\restrf[n][p][q][\epsilon]
                (\depscohs[n][\lbrack 0,p-1 \rbrack])(d), \restrl[n][p][q][\epsilon]
              (\depscohs[n][\lbrack 0,p \rbrack])(d)(l)\right) \\
            \end{array} \right)                                                                              \\
    \cohftype[n][\lbrack 0,p-1 \rbrack]     &
    \left(\begin{array}{l}
              \fulldeps[n]                      \\
              \restrp[n][\lbrack 0,p-1 \rbrack] \\
            \end{array}\right)    & :                                   & \U                                                                           \\
    \cohftype[n]                            &
    \left(\begin{array}{l}
              E          \\
              \unitpoint \\
            \end{array}\right)                  & \defeq                              &
    \unittype                                                                                                                                        \\
    \cohftype[n][\lbrack 0,p \rbrack]       &
    \left(\begin{array}{l}
              \fulldeps[n]                    \\
              \restrp[n][\lbrack 0,p \rbrack] \\
            \end{array}\right)      & \defeq                              &
    \left\{\begin{array}{l}
             \Sigma \cohf[n][\lbrack 0,p-1 \rbrack][q][r][\epsilon][\omega]
             :\cohftype[n][\lbrack 0,p-1 \rbrack]
             \left(\begin{array}{l}
                \fulldeps[n]                      \\
                \restrp[n][\lbrack 0,p-1 \rbrack] \\
              \end{array}\right).                          \\
             \Pi d:\framep[n+2][p]
             \left(\overline{\deps}\left(\begin{array}{l}
                                        \fulldeps[n]                      \\
                                        \restrp[n][\lbrack 0,p-1 \rbrack] \\
                                        \cohf[n][\lbrack 0,p \rbrack]
                                      \end{array}\right)\right)          . \\
             \\
             \restrf[n][p][q][\epsilon](\restrf[n+1][p][r][\omega]
             \left(\begin{array}{l}
                \fulldeps[n]                      \\
                \restrp[n][\lbrack 0,p-1 \rbrack] \\
                \cohf[n][\lbrack 0,p \rbrack]
              \end{array}\right)(d)) =                          \\
             \restrf[n][p][r][\omega](\restrf[n+1][p][q+1][\epsilon]
             \left(\begin{array}{l}
                \fulldeps[n]                      \\
                \restrp[n][\lbrack 0,p-1 \rbrack] \\
                \cohf[n][\lbrack 0,p \rbrack]
              \end{array}\right)(d))                          \\
           \end{array}\right.                                                                    \\
    \restrltype[n][p]                       &
    \depscohs[n][\lbrack 0,p-1 \rbrack]
                                            & :                                   & \U                                                               \\
    \restrltype[n][p]                       &
    \depscohs[n][\lbrack 0,p-1 \rbrack]
                                            & \defeq                              &
    \left\{\begin{array}{l}
             \Pi q \leq n-p. \Pi \epsilon. \Pi d: \framep[n+2][p](\overline{\deps}(\depscohs[n][\lbrack 0,p-1 \rbrack])).\, \\
             \layer[n+1][p](\overline{\deps}(\depscohs[n][\lbrack 0,p-1 \rbrack])(d) \rightarrow                            \\
             \layer[n][p](\deps[n][\lbrack 0,p \rbrack])(\restrf[n][p]
             (\depscohs[n][\lbrack 0,p-1 \rbrack])(d))
           \end{array}\right.                            \\
    \restrl[n][p]                           &
    \depscohs[n][\lbrack 0,p \rbrack]       & :                                   &
    \restrltype[n][p] (\depscohs[n][\lbrack 0,p \rbrack])                                                                                            \\
    \restrl[n][p][q][\epsilon]              &
    \depscohs[n][\lbrack 0,p \rbrack]       & \defeq                              &
    \begin{array}{l}
      \lambda d.\lambda l.\lambda \omega.\overrightarrow{\cohf[n][p][q][0][\epsilon][\omega](d)}               \\
      \restrp[n][p][q][\epsilon](\restrf[n][p][q][\epsilon](\depscohs[n][\lbrack 0,p-1 \rbrack])(d))(l_\omega) \\
    \end{array}
  \end{array}
\end{equation*}

By abuse of notation, we also write $E$ for an inhabitant of $\depscohstype[n]$ (standing for a non trivial inhabitant of $\fulldeps[n]$).

We need also the notion of full dependencies at the level of coherence conditions, that combines a full $\depscohs[n][\lbrack 0,n \rbrack]$ with a set $E:\framep[n+2][n+2](\overline{\deps}(\depscohs[n][\lbrack 0,n \rbrack])) \rightarrow \U$:
\begin{equation*}
  \fulldepscohstype[n] \defeq
  \left(\begin{array}{lcl}
      \depscohs[n][\lbrack 0,n-1 \rbrack] & : & \depscohstype[n][\lbrack 0,n \rbrack]                                                \\
      E                                   & : & \framep[n+2][n+2](\overline{\deps}(\depscohs[n][\lbrack 0,n \rbrack]))\rightarrow \U \\
    \end{array}\right)
\end{equation*}
TODO: say the convention on projection in the Introduction

We can then extend $\overline{\deps}$ to build $\fulldeps$ from $\fulldepscohs$:
\begin{equation*}
  \begin{array}{lcl}
    \overline{\fulldeps}(\fulldepscohs[n]) & :      & \fulldepstype[n+1]                                        \\
    \overline{\fulldeps}(\fulldepscohs[n]) & \defeq & \left(\begin{array}{l}
                                                                \overline{\deps}(\depscohs[n][\lbrack 0,n \rbrack]) \\
                                                                E                                                   \\
                                                              \end{array}\right) \\
  \end{array}
\end{equation*}

Also, when $n$ is 0, we write $(E,E')$ to denote an element $(E, E')$ of $\fulldepscohstype[0]$.

\subsection{Defining painting restrictions}

Armed with $\restrf$, $\cohftype$ and these abbreviations, it is now possible to define $\restrp[n+1][p]$ for $p \leq n+1$ by recursion on $n-p$:

\begin{equation*}
  \begin{array}{llcl}
    \restrp[n+1][p][q][\epsilon]        &
    \fulldepscohs[n]                    & :      &
    \left(
    \begin{array}{l}
        \Pi d:\framep[n+2][p]
        (\overline{\deps}(\depscohs[n][\lbrack 0,p-1 \rbrack])). \\
        \painting[n+2][p]
        (\overline{\fulldeps}(\fulldepscohs[n]))(d) \rightarrow  \\
        \painting[n+1][p](\fulldeps[n])
        (\restrf[n+1][p](\depscohs[n][\lbrack 0,p-1 \rbrack])(d))\end{array}\right)                                         \\
    \restrp[n+1][n+1][q][\epsilon]      &
    \fulldepscohs[n]                    & \defeq & \lambda d. \lambda (l,c). l_\epsilon \\
    \restrp[n+1][p \leq n][q][\epsilon] &
    \fulldepscohs[n]                    & \defeq & \lambda d. \lambda (l,c).
    \left(\begin{array}{l}
              \restrl[n][p][q][\epsilon](\depscohs[n][\lbrack 0,p \rbrack])(d)(l), \\
              \restrp[n+1][p+1][q][\epsilon](\fulldepscohs[n])(d,l)(c)             \\
            \end{array}\right)          \\
  \end{array}
\end{equation*}

From which we can deduce $\restrp[n+1][\lbrack 0,p-1 \rbrack]$ for $p \leq n+2$ again by a second recursion, this time on $p$:

\begin{equation*}
  \begin{array}{llcl}
    \restrp[n+1][\lbrack 0,p-1 \rbrack] &
    \fulldepscohs[n]                    & :      & \restrptype[n+1][\lbrack 0,p-1 \rbrack](\fulldeps[n]) \\
    \restrp[n+1]                        &
    \fulldepscohs[n]                    & \defeq & \unittype                                             \\
    \restrp[n+1][\lbrack 0,p \rbrack]   &
    \fulldepscohs[n]
                                        & \defeq &
    (\restrp[n+1][\lbrack 0,p-1 \rbrack](\fulldepscohs[n]),\restrp[n+1][p](\fulldepscohs[n]))            \\
  \end{array}
\end{equation*}

\subsection{Specifying painting coherence laws}

At this stage, we are then able to define $\restrf[n+1][\lbrack 0,p \rbrack]$, $\restrp[n+1][\lbrack 0,p \rbrack]$ and $\cohftype[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$
from $\depscohs[n][\lbrack 0,p-1 \rbrack]$ at the previous level. To go further, we need to define the
sequence $\cohptype[n][\lbrack 0,p-1 \rbrack]$ of types of painting coherence laws:

\begin{equation*}
  \begin{array}{llcl}
    \cohptype[n][\lbrack 0,p-1 \rbrack] & \fulldepscohs[n] & :      & \U                                                           \\
    \cohptype[n]                        & \unitpoint       & \defeq & \unittype                                                    \\
    \cohptype[n][\lbrack 0,p \rbrack]   & \fulldepscohs[n] & \defeq & \cohptype[n][\lbrack 0,p-1 \rbrack](\fulldepscohs[n]) \times \\
                                        &                  &        & \left\{
    \begin{array}{l}
      \Pi q \leq n-p.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega.                                                                                       \\
      \Pi d:\framep[n+2][p](\overline{\deps}(\depscohs[n][\lbrack 0,p-1 \rbrack])).\,\Pi c:\painting[n+2][p](\overline{\fulldeps}(\fulldepscohs[n])). \\
      \restrp[n][p][q][\epsilon](\restrf[n+1][p](\depscohs[n][\lbrack 0,p-1 \rbrack])(d))(\restrp[n+1][p][r][\omega]
      (\fulldepscohs[n])(d)(c)) =_{\cohf[n][p][q][r][\epsilon][\omega]}                                                                               \\
      \restrp[n][p][r][\omega](\restrf[n+1][p](\depscohs[n][\lbrack 0,p-1 \rbrack])(d))(\restrp[n+1][p][q+1][\epsilon]
      (\fulldepscohs[n])(d)(c))
    \end{array}
    \right.                                                                                                                        \\
  \end{array}
\end{equation*}
where we use the ``equality over'' notation $t =_e u$ to mean $\overrightarrow{e}(t) = u$ whenever $t$ is of some type $P(a)$, $u$ of type $P(b)$ and $e$ a proof of $a = b$.
\subsection{Defining frame coherence laws and specifying frame 2-dimensional coherence laws}

Thanks to $\cohptype[n][\lbrack 0,p-1 \rbrack]$, we can mutually define $\cohf[n+1][\lbrack 0,p \rbrack]$ and $\cohttype[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$ from $\fulldepscohs[n]$, abbreviating this and the dependency in a $\coht[n][\lbrack 0,p-1 \rbrack]$ as $\depscohttype[n][\lbrack 0,p-1 \rbrack]$, and using also abbreviations in passing for $\cohl$ and $\cohltype$. It is also convenient to build $\depscohs[n+1][\lbrack 0,p \rbrack]$ from $\depscoht[n][\lbrack 0,p-1 \rbrack]$, so that we can now build $\framep[n+3][p]$. Thus, we also include this abbreviation in the definition. Implicitly using in $\cohf[n+1][\lbrack 0,p \rbrack]$ that equalities in a $\Sigma$-type are equivalent to a $\Sigma$-type of the underlying equalities, we altogether have:

\begin{equation*}
  \begin{array}{llcl}
    \depscohttype[n][\lbrack 0,p-1 \rbrack]     &                                     & \defeq                                                                            &
    \left(\begin{array}{lll}
              \fulldepscohs[n]                & : & \fulldepscohstype[n]                                  \\
              \cohp[n][\lbrack 0,p-1 \rbrack] & : & \cohptype[n][\lbrack 0,p-1 \rbrack](\fulldepscohs[n]) \\
            \end{array}
    \right)                                                                                                                                                                                                         \\
    \overline{\depscohs}                        & \depscoht[n][\lbrack 0,p-1 \rbrack] & :                                                                                 & \depscohstype[n+1][\lbrack 0,p \rbrack] \\
    \overline{\depscohs}                        & \depscoht[n][\lbrack 0,p-1 \rbrack] & \defeq                                                                            &
    \left(\begin{array}{l}
              \overline{\deps}(\depscohs[n][\lbrack 0,p-1 \rbrack]) \\
              \restrp[n+1][p](\fulldepscohs[n])                     \\
              \cohf[n+1][p](\depscoht[n][\lbrack 0,p-1 \rbrack])    \\
            \end{array}\right)                                                                                                                                                     \\
    \cohf[n+1][\lbrack 0,p \rbrack]             &
    \depscoht[n][\lbrack 0,p-1 \rbrack]         & :                                   & \cohftype[n+1][\lbrack 0,p \rbrack]
    \left(\begin{array}{l}
              \overline{\fulldeps}(\fulldepscohs[n])              \\
              \restrp[n+1][\lbrack 0,p \rbrack](\fulldepscohs[n]) \\
            \end{array}\right)                                                                                                                                                       \\
    \\
    \cohf[n][\lbrack 0,0 \rbrack]               &
    \unitpoint                                  & \defeq                              & (\unitpoint,\lambda q.\lambda r. \lambda\epsilon. \lambda\omega.\lambda \_.\refl)                                           \\
    \cohf[n][\lbrack 0,p+1 \rbrack]             &
    \depscoht[n][\lbrack 0,p-1 \rbrack]         & \defeq                              &
    \left(\begin{array}{l}
              \cohf[n+1][\lbrack 0,p \rbrack]
              (\depscoht[n]),                                                    \\
              \lambda q.\lambda r.\lambda \epsilon.\lambda \omega.\lambda (d,l). \\
              (\cohf[n][\lbrack 0,p \rbrack][q][r][\epsilon][\omega]
              (\depscoht[n])(d), \cohl[n][p][q][r][\epsilon][\omega]
              (\depscoht[n])(d)(l))                                              \\
            \end{array}\right)                                                                                                                                        \\
    \coht[n][p]                                 &
    \fulldepscohs[n]                            & :                                   & \cohttype[n][p](\fulldepscohs[n])                                                                                           \\
    \coht[n][p][q][r][\epsilon][\omega][\theta] &
    \fulldepscohs[n]                            & \defeq                              & \lambda d.\,\UIP                                                                                                            \\

    \cohl[n][p]                                 &
    \depscoht[n][\lbrack 0,p-1 \rbrack]         & :                                   &
    \begin{array}{l}
      \Pi q \leq n-p.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega.\,\Pi d.\,\Pi l.                                                                                 \\
      \restrl[n][p][q][\epsilon](\depscohs[n][\lbrack 0,p-1 \rbrack])(\restrl[n+1][p][r][\omega](\overline{\depscohs}(\depscoht[n][\lbrack 0,p-1 \rbrack]))(l)) \\ =_{\cohf[n+1][p][r+1][q+1][\epsilon][\omega](\depscoht[n][\lbrack 0,p-1 \rbrack])(d)} \\
      \restrl[n][p][r][\omega](\depscohs[n][\lbrack 0,p-1 \rbrack])(\restrl[n+1][p][q+1][\epsilon](\overline{\depscohs}(\depscoht[n][\lbrack 0,p-1 \rbrack]))(l))
    \end{array}                                           \\
    \cohl[n][p][q][r][\epsilon][\omega]         &
    \depscoht[n][\lbrack 0,p-1 \rbrack]         & \defeq                              &
    \begin{array}{l}
      \lambda d. \lambda l. \lambda \theta. \overrightarrow{\coht[n][p][q][r][\epsilon][\omega][\theta](\fulldepscohs[n])(d)}                             \\
      (\ap \overrightarrow{\cohf[n][p][r][0][\omega][\theta](\restrf[n+2][p][q+2][\epsilon](\overline{\depscohs}(\depscoht[n][\lbrack 0,p \rbrack]))(d))} \\ (\ap \overrightarrow{\cohf[n+1][p][q+1][0][\epsilon][\theta](\depscoht[n][\lbrack 0,p-1 \rbrack])(d)} \\(\cohp[n][p][q][r][\epsilon][\omega](l_\theta)))) \\
    \end{array}
  \end{array}
\end{equation*}
where $\cohttype$ is:
\begin{equation*}
  \cohttype[n][p](\depscoht[n][\lbrack 0,p \rbrack]) \defeq
  \left(
  \begin{array}{l}
      \Pi q \leq n-p.\,\Pi r \leq q.\,\Pi \epsilon.\,\Pi \omega.\,\Pi \theta.\,\Pi d.                                                     \\
      \cohf[n][p][r][0][\omega][\theta](\restrf[n+2][p][q+2][\epsilon](\overline{\depscohs}(\depscoht[n][\lbrack 0,p \rbrack]))(d)) \circ \\
      \ap\restrf[n][p][r][\omega](\cohf[n+1][p][q+1][0][\epsilon][\theta]
      (\depscoht[n][p])(d))
      \circ                                                                                                                               \\
      \cohf[n][p][q][r][\epsilon][\omega](\restrf[n+2][p][0][\theta](\overline{\depscohs}(\depscoht[n][\lbrack 0,p \rbrack]))(d)) =       \\
      \ap\restrf[n][p][0][\theta](\cohf[n+1][p][q+1][r+1][\epsilon][\omega]
      (\depscoht[n][p])(d))
      \circ                                                                                                                               \\
      \cohf[n][p][q][0][\epsilon][\theta](\restrf[n+2][p][r+1][\omega](\overline{\depscohs}(\depscoht[n][\lbrack 0,p \rbrack]))(d))
      \circ                                                                                                                               \\
      \ap\restrf[n][p][q][\epsilon](\cohf[n+1][p][r][0][\omega][\theta]
      (\depscoht[n][p])(d))
    \end{array}
  \right)
\end{equation*}
and where the functoriality of equality and transport was used to go from (omitting the $\framep$ argument and the deps argument of $\restrp$ and $\cohf$):
\begin{equation*}
  \Pi \theta.\left(
  \begin{array}{lcl}
    \begin{array}{l}
      \overrightarrow{\cohf[n][p][q][0][\epsilon][\theta]}
      \overrightarrow{\cohf[n+1][p][r][0][\omega][\theta]} \\
      (\restrp[n][p][q][\epsilon](\restrp[n+1][p][r][\omega](l_\theta)))
    \end{array} & =_{\cohf[n+1][p][q+1][r+1][\epsilon][\omega]} &
    \begin{array}{l}
      \overrightarrow{\cohf[n][p][r][0][\omega][\theta]}\overrightarrow{\cohf[n+1][p][q+1][0][\epsilon][\theta]} \\
      (\restrp[n][p][r][\omega](\restrp[n+1][p][q+1][\epsilon](l_\theta)))
    \end{array}
  \end{array}
  \right)
\end{equation*}
to:
\begin{equation*}
  \Pi \theta.\left(
  \begin{array}{lcl}
    \begin{array}{l}
      \overrightarrow{\cohf[n][p][q][0][\epsilon][\theta]}(\restrp[n][p][q][\epsilon] \\
      (\overrightarrow{\cohf[n+1][p][r][0][\omega][\theta]}(\restrp[n+1][p][r][\omega](l_\theta))))
    \end{array} & =_{\cohf[n+1][p][q+1][r+1][\epsilon][\omega]} &
    \begin{array}{l}
      \overrightarrow{\cohf[n][p][r][0][\omega][\theta]}(\restrp[n][p][r][\omega] \\
      (\overrightarrow{\cohf[n+1][p][q+1][0][\epsilon][\theta]}(\restrp[n+1][p][q+1][\epsilon](l_\theta))))
    \end{array}
  \end{array}
  \right)
\end{equation*}
which is exactly the type of $\cohl[n][p][q][r][\epsilon][\omega]$, up to functional extensionality relative to $\theta$.

It is also convenient to introduce a notion of full dependencies at the level of the coherence conditions of dimension 2, that combines a full $\depscoht[n][\lbrack 0,n \rbrack]$ with a set $E:\framep[n+3][n+3](\overline{\deps}(\overline{\depscohs}(\depscoht[n][\lbrack 0,n \rbrack]))) \rightarrow \U$:
\begin{equation*}
  \fulldepscohttype[n] \defeq
  \left(\begin{array}{lll}
      \depscoht[n][\lbrack 0,n \rbrack] & : & \depscohttype[n][\lbrack 0,n \rbrack]                                                                      \\
      E                                 & : & \framep[n+3][n+3](\overline{\deps}(\overline{\depscohs}(\depscoht[n][\lbrack 0,n \rbrack])))\rightarrow \U \\
    \end{array}\right)
\end{equation*}

We can then extend $\overline{\depscohs}$ to build $\fulldepscohs$ from $\fulldepscoht$:

\begin{equation*}
  \begin{array}{lcl}
    \overline{\fulldepscohs}(\fulldepscoht[n]) & :      & \fulldepscohstype[n+1]                                        \\
    \overline{\fulldepscohs}(\fulldepscoht[n]) & \defeq & \left(\begin{array}{l}
                                                                    \overline{\depscohs}(\depscoht[n][\lbrack 0,n \rbrack]) \\
                                                                    E                                                       \\
                                                                  \end{array}\right) \\
  \end{array}
\end{equation*}

\subsection{Defining painting coherence laws}

The last key construction we need is $\cohp[n+1][p]$ for $p \leq n+1$, which is by recursion on $n-p$:

\begin{equation*}
  \begin{array}{llcl}
    \cohp[n+1][p]                                &
    \fulldepscoht[n]                             & :      &
    \cohptype[n+1][p](\overline{\fulldepscohs}(\fulldepscoht[n]))                                \\
    \cohp[n+1][n+1][q][r][\epsilon][\omega]      &
    \fulldepscoht[n]
                                                 & \defeq & \lambda d. \lambda (l,c). l_\epsilon \\
    \cohp[n+1][p \leq n][q][r][\epsilon][\omega] &
    \fulldepscoht[n]
                                                 & \defeq & \lambda d. \lambda (l,c).
    \left(\begin{array}{l}
              \cohl[n][p][q][r][\epsilon][\omega](\depscoht[n][\lbrack 0,p-1 \rbrack])(d)(l), \\
              \cohp[n+1][p+1][q][r][\epsilon][\omega](\fulldepscoht[n])(d,l))(c)              \\
            \end{array}\right)        \\
  \end{array}
\end{equation*}
where we again implicitly used that equalities in a $\Sigma$-type are equivalent to a $\Sigma$-type of the underlying equalities, componentwise.

From the latter we can deduce $\cohp[n+1][\lbrack 0,p-1 \rbrack]$ for $p \leq n+2$, again by a second recursion, this time on $p$:

\begin{equation*}
  \begin{array}{llcl}
    \cohp[n+1][\lbrack 0,p-1 \rbrack] &
    \fulldepscoht[n]                  & :      & \cohptype[n+1][\lbrack 0,p-1 \rbrack](\fulldepscohs[n]) \\
    \cohp[n+1]                        &
    \fulldepscohs[n]                  & \defeq & \unittype                                               \\
    \cohp[n+1][\lbrack 0,p \rbrack]   &
    \fulldepscoht[n]
                                      & \defeq &
    (\cohp[n+1][\lbrack 0,p-1 \rbrack](\fulldepscoht[n]),\cohp[n+1][p](\fulldepscoht[n]))                \\
  \end{array}
\end{equation*}

\subsection{Completing the construction by induction}

Armed with all the constructions, we are now able to specify the whole
structure on which we can reason by induction, for $D:\Xto{m}{n}$
given:

\begin{equation*}
  \begin{array}{lcl}
    \framep[n][\lbrack 0,n \rbrack]      & :      & \frametype[n][\lbrack 0,n \rbrack]                                     \\
    \painting[n][\lbrack 0,n \rbrack]    & :      & \paintingtype[n][\lbrack 0,n \rbrack](\framep[n][\lbrack 0,n \rbrack]) \\
    \restrf[n][\lbrack 0,n \rbrack]      & :      & \restrftype[n][\lbrack 0,n \rbrack]
    \left(
    \begin{array}{l}
        \framep[n][\lbrack 0,n \rbrack]   \\
        \painting[n][\lbrack 0,n \rbrack] \\
      \end{array}\right)                                                                                      \\
    \deps[n][\lbrack 0,n \rbrack]        & \defeq &
    \left(
    \begin{array}{l}
        \framep[n][\lbrack 0,n \rbrack]   \\
        \painting[n][\lbrack 0,n \rbrack] \\
        \restrf[n][\lbrack 0,n \rbrack]   \\
      \end{array}\right)                                                                                      \\
    \fulldeps[n](E)                      & \defeq &
    \left(
    \begin{array}{l}
        \deps[n][\lbrack 0,n \rbrack] \\
        E                             \\
      \end{array}\right)                                                                                          \\
    \restrp[n][\lbrack 0,n \rbrack](E)   & :      & \restrptype[n][\lbrack 0,n \rbrack]
    (\fulldeps[n](E))                                                                                                      \\
    \cohf[n][\lbrack 0,n \rbrack](E)     & :      & \cohftype[n][\lbrack 0,n \rbrack]
    \left(
    \begin{array}{l}
        \fulldeps[n](E)                    \\
        \restrp[n][\lbrack 0,n \rbrack](E) \\
      \end{array}\right)                                                                                     \\
    \depscohs[n][\lbrack 0,n \rbrack](E) & \defeq &
    \left(
    \begin{array}{l}
        \fulldeps[n](E)                    \\
        \restrp[n][\lbrack 0,n \rbrack](E) \\
        \cohf[n][\lbrack 0,n \rbrack](E)   \\
      \end{array}\right)                                                                                     \\
    \fulldepscohs[n](E)(E')              & \defeq &
    \left(
    \begin{array}{l}
        \depscohs[n][\lbrack 0,n \rbrack](E) \\
        E'                                   \\
      \end{array}\right)                                                                                   \\
    \cohp[n][\lbrack 0,n \rbrack](E)(E') & :      & \cohptype[n][\lbrack 0,n \rbrack]
    (\fulldepscohs[n](E)(E'))                                                                                              \\
  \end{array}
\end{equation*}
where
\begin{align*}
  E: \framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack])\rightarrow \U \\
  E': \framep[n+2][n+2](\overline{\deps}(\depscohs[n][\lbrack 0,n \rbrack](E)))\rightarrow \U
\end{align*}

Indeed, to build this structure at level $n+1$, from level $n$, it is
enough to assume $E:\framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack]) \rightarrow \U$ (where $\deps[n][\lbrack 0,n \rbrack]$ come from the assumptions at level $n$) and to build the following:
\begin{itemize}
  \item $\framep[n+1][\lbrack 0,n+1 \rbrack]$ comes from $\deps[n][\lbrack 0,n \rbrack]$.
  \item $\painting[n+1][\lbrack 0,n+1 \rbrack]$ comes from $\fulldeps[n](E)$.
  \item $\restrf[n+1][\lbrack 0,n+1 \rbrack]$ comes from $\depscohs[n][\lbrack 0,n \rbrack](E)$.
  \item $\restrp[n+1][\lbrack 0,n+1 \rbrack](E')$, for $E':\framep[n+2][n+2](\overline{\deps}(\depscohs[n][\lbrack 0,n \rbrack])) \rightarrow \U$, comes from $\fulldepscohs[n](E)(E')$.
  \item we define $\depscoht[n][\lbrack 0,n \rbrack](E)(E')$ from $\fulldepscohs[n](E)(E')$ and $\cohp[n][\lbrack 0,n \rbrack](E)(E')$.
  \item $\cohf[n+1][\lbrack 0,n+1 \rbrack](E')$ comes from $\depscoht[n][\lbrack 0,n \rbrack](E)(E')$.
  \item we define $\fulldepscoht[n](E)(E')(E'')$, for $E'': \framep[n+3][n+3](\overline{\deps}(\overline{\depscohs}(\depscoht[n][\lbrack 0,n \rbrack]))) \rightarrow \U$, from $\depscoht[n][\lbrack 0,n \rbrack](E)(E')$ and $E''$.
  \item $\cohp[n+1][\lbrack 0,n+1 \rbrack](E')(E'')$ comes from $\fulldepscoht[n](E)(E')(E'')$.
\end{itemize}

Therefore, assuming a construction of $\framep[n][n]$ from $D:\Xto{m}{n}$, we are able to build a $\framep[n+1][n+1]$ from $D$ extended with some $E:\framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack]) \rightarrow \U$. This is enough to build $\Xcomp{m}{n}(D)$, for $D:\Xto{m}{n}$, and thus $\Xp{m}$, by starting with an empty $D$.

\bibliographystyle{msclike}
\bibliography{paper}

\end{document}
