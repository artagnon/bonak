\documentclass{lipics-v2021}

\usepackage{amsmath, amssymb, mathrsfs, mathtools, wasysym, tikz, tikz-cd, lmodern, mathpazo, anyfontsize, xargs, environ, multirow, tabularx, caption, bookmark, booktabs, makecell, colortbl, minted, art.cls/colorpal, art.cls/ct, art.cls/sset, art.cls/lim, art.cls/joinargs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[prefix=bonak]{art.cls/xkeymask}

% Use the patterns library to draw the cubes figure
\usetikzlibrary{patterns}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{painting}{D}{(#1)}
\define@cmdkey[bonak]{painting}{E}{(#1)}
\define@cmdkey[bonak]{painting}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrpainting}{D}{(#1)}
\define@cmdkey[bonak]{restrpainting}{E}{(#1)}
\define@cmdkey[bonak]{restrpainting}{d}{(#1)}
\define@cmdkey[bonak]{restrpainting}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohpainting}{D}{(#1)}
\define@cmdkey[bonak]{cohpainting}{E}{(#1)}
\define@cmdkey[bonak]{cohpainting}{d}{(#1)}
\define@cmdkey[bonak]{cohpainting}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \ensuremath{{\color{carolina}{\nu\textsf{Set}}}_{#1}^{#2}}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and painting: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and painting: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4]}^{\joinargs[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

\newcommandx{\depsmacro}[5][4,5]{
  \ensuremath{\mathsf{\color{strawberry}{#1}}_{
    \joinargs[\mathsf{\color{#3}{#2}}]}^{\joinargs[#4][#5]}}
}

% Coherence conditions for frame, layer, and painting: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaHat}{\ensuremath{\hat{\boldsymbol{\Delta}}}}
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}{\ensuremath{\boldsymbol{{\square}}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommandx{\U}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HSet}}_{#1}}}
\newcommandx{\HGpd}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HGpd}}_{#1}}}
\newcommand{\Type}{\ensuremath{\mathsf{\color{spanish-blue}{Type}}}}
\newcommand{\SProp}{\ensuremath{\mathsf{\color{spanish-blue}{SProp}}}}

% The unit and bool types
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\booltype}{\ensuremath{\mathsf{bool}}}
\newcommand{\unitpoint}{\ensuremath{\ast}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\refl}{\ensuremath{\mathsf{refl}}}

% Some abbreviations
\newcommand{\tl}{\ensuremath{\mathsf{tl}}}
\newcommand{\hd}{\ensuremath{\mathsf{hd}}}
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\newcommand{\ap}{\mathsf{ap}\;}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommand{\Dom}{\textsf{Dom}}
\newcommand{\UIP}{\textsf{UIP}}
\newcommand{\HProp}{\ensuremath{\mathsf{HProp}}}

\newcommand{\udensdash}[1]{%
    \tikz[baseline=(todotted.base)]{
        \node[inner sep=1pt,outer sep=0pt] (todotted) {$#1$};
        \draw[densely dashed] (todotted.south west) -- (todotted.south east);
    }%
}%

% These are renewed in tables, but let's define them now for in-document
% typesetting
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\newcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\newcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\newcommandx{\restrp}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\newcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\newcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\newcommandx{\cohp}{\coh{painting}[][][][][][][][]}
\newcommandx{\fullframe}[1][1]{\prim{fullframe}[][#1][][][]}

\newcommandx{\frametype}[2][1,2]{\prim{FRAME}[][#1][#2][][]}
\newcommandx{\layertype}[2][1,2]{\prim{LAYER}[][#1][#2][][]}
\newcommandx{\paintingtype}[2][1,2]{\prim{PAINTING}[][#1][#2][][]}
\newcommandx{\restrftype}[2][1,2]{\restr{FRAME}[][][][#1][#2][][]}
\newcommandx{\restrltype}[2][1,2]{\restr{LAYER}[][][][#1][#2][][]}
\newcommandx{\restrptype}[2][1,2]{\restr{PAINTING}[][][][#1][#2][][]}
\newcommandx{\cohftype}[2][1,2]{\coh{FRAME}[][][][][][#1][#2][]}
\newcommandx{\cohltype}[2][1,2]{\coh{LAYER}[][][][][][#1][#2][]}
\newcommandx{\cohptype}[2][1,2]{\coh{PAINTING}[][][][][][#1][#2][]}
\newcommandx{\cohttype}[2][1,2]{\cohtwo{FRAME}[][][][][][#1][#2][]}

\newcommandx{\deps}[2][1,2]{\depsmacro{deps}{restr}{russian-green}[#1][#2]}
\newcommandx{\fulldeps}[1][1]{\depsmacro{deps}{fullrestr}{russian-green}[#1]}
\newcommandx{\depscohs}[2][1,2]{\depsmacro{deps}{coh}{chestnut}[#1][#2]}
\newcommandx{\fulldepscohs}[1][1]{\depsmacro{deps}{fullcoh}{chestnut}[#1]}
\newcommandx{\depscoht}[2][1,2]{\depsmacro{deps}{coh2}{chestnut}[#1][#2]}
\newcommandx{\fulldepscoht}[1][1]{\depsmacro{deps}{fullcoh2}{chestnut}[#1]}
\newcommandx{\depstype}[2][1,2]{\depsmacro{DEPS}{restr}{russian-green}[#1][#2]}
\newcommandx{\fulldepstype}[1][1]{\depsmacro{DEPS}{fullrestr}{russian-green}[#1]}
\newcommandx{\depscohstype}[2][1,2]{\depsmacro{DEPS}{coh}{chestnut}[#1][#2]}
\newcommandx{\fulldepscohstype}[1][1]{\depsmacro{DEPS}{fullcoh}{chestnut}[#1]}
\newcommandx{\depscohttype}[2][1,2]{\depsmacro{DEPS}{coh2}{chestnut}[#1][#2]}
\newcommandx{\fulldepscohttype}[1][1]{\depsmacro{DEPS}{fullcoh2}{chestnut}[#1]}

\newcommandx{\coht}[7][1,2,3,4,5,6,7]{\cohtwo{frame}[#3][#4][#5][#6][#7][#1][#2][]}

% Kerning for star
\newcommand{\kstar}{{\star}}

% Caption setup
\DeclareCaptionFormat{plain}{#1#3}
\captionsetup{font=footnotesize,labelfont=bf}

% The eqntable environment
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{eqntable}[1]{
  \small
  \begin{tabularx}{0.94\linewidth}{
    @{}
    >{$}l<{$}
    >{$}c<{$}
    >{$}c<{$}
    >{$}Y<{$}
    @{}}
    \toprule
    \BODY
    \bottomrule
  \end{tabularx}
  \captionof{table}{#1}
}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

\title{The very dependent recursive structure of iterated parametricity in indexed form}
\author{Hugo Herbelin}{Université Paris Cité, Inria, CNRS, IRIF, Paris}{Hugo.Herbelin@inria.fr}{}{}
\author{Ramkumar Ramachandra}{Unaffiliated}{r@artagnon.com}{}{}
\authorrunning{H. Herbelin and R. Ramachandra}

\begin{document}
\maketitle
\begin{abstract}
  Reynolds' parametricity equips types with binary propositional relations over the types. Such relations can be proof-relevant, unary, and described either in an indexed or fibred way. Parametricity can be iterated, and when types are sets, this results in an interpretation of sets as augmented semi-simplicial sets in the unary case, or semi-cubical sets in the binary case.

  In a previous paper, we gave equations describing $n$-ary iterated parametricity in indexed form. The construction was formalised in Rocq using a complex induction on a large structure embedding equational reasoning.

  This paper analyses the very dependent recursive structure of the equations in the earlier paper leading to terser presentation of the construction without equational reasoning. The construction has been reduced to its computational essence, and can be described in full detail, closely following a new machine-checked formalisation.
\end{abstract}

\section{Introduction}

\paragraph*{Parametricity and its ramifications.}

Introduced by Reynolds in the context of programming language semantics~\cite{reynolds83}, relational parametricity is connected to several similar concepts in logic and mathematics. In its original formulation, it associates binary propositional relations to types. The variant in \cite{GhaniNordvallOrsanigo16} associates proof-relevant binary relations to types, and the variant in \cite{bernardy10} associates relations of arbitrary arity to types. This includes, in particular, the case of unary relations which assigns predicates to types in the proof-irrelevant case, and families to types in the proof-relevant case. The unary relation case expresses what it means to belong in a type, and the binary relation case expresses what it means to be equal in a type. For instance, the canonical predicate associated to $A \rightarrow B$ is the predicate over functions $f$ in $A \rightarrow B$ such that, for all $a$ in the canonical predicate associated to $A$, $f(a)$ is in the canonical predicate associated to $B$. Similarly, the canonical relation associated to $A \rightarrow B$ is the relation over functions $f$ and $f'$ in $A \rightarrow B$ such that, for all $a$ and $a'$ related through the canonical relation associated to $A$, $f(a)$and $f'(a')$ are related through the canonical relation associated to $B$.

From the point of view of realisability, unary parametricity over a language is a realisability using the language itself as language of realisers. The comparison between parametricity and realisability includes the case of \emph{reducibility}, also known as \emph{Tait computability}~\cite{Tait67}, which is a semantic form of realisability, also known as \emph{glueing} in the context of category theory. In the same vein, binary parametricity over a language can be seen as defining \emph{logical relations}~\cite{Plotkin73} over itself, since logical relations are a binary form of reducibility.

Parametricity, like realisability, reducibility, and logical relations, is most commonly expressed in \emph{indexed} form. Let us use a type-theoretic language featuring a type of subsingleton types called $\HProp$, a type of sets $\U$, as well, as the standard $\Sigma$ and $\Pi$ constructions. In such language, predicates have type $A \rightarrow \HProp$, families have type $A \rightarrow \U$, relations have type $A \times A \rightarrow \HProp$, and relevant relations, sometimes called \emph{correspondences}, have type $A \times A \rightarrow \U$. All constructions in indexed form can also be expressed in the \emph{fibred} form, by the indexed-fibred correspondence: there is an equivalence between $A \rightarrow \HProp$ and $\Sigma B:\U. (B \stackrel{inj}{\rightarrow} A)$ in the proof-irrelevant case, and $A \rightarrow \U$ and $\Sigma B:\U. (B \rightarrow A)$, in the proof-relevant case, for $A:\U$. A fibred approach to parametricity was considered in~\cite{atkey14}, who also suggested to iterate parametricity.

\paragraph*{Iterated parametricity.}

The internalisation of parametricity in unary indexed form was studied by \cite{bernardy12} directly leading to a type theory of iterated parametricity. Such a type theory could be interpreted in a ``unary'' form of cubical set~\cite{bernardy15}, which is implicitly in fibred form since, in a binary cubical set, a set of segments over two points (or a relevant relation) is given by first and second projection rather than as a function to $\U$. This connection between iterated binary parametricity in fibred form and cubical sets includes an identification of degeneracies and reflexivity proofs, which can also be found in \cite{johann17}. While iterated binary parametricity without reflexivity produces semi-cubical sets, it was also observed\footnote{The authors learned it from Hugo Moeneclaey and Thorsten Altenkirch.} that iterated unary parametricity produces augmented semi-simplicial sets.

\begin{tabularx}{0.94\linewidth}{cYcYYl}
  \toprule
  arity                       & formalisation style        & iteration                       & relevance        & logical structure               \\
  \midrule
  \multirow{6}{0.4cm}{unary}  & \multirow{3}{1cm}{indexed} & \multirow{2}{2cm}{non-iterated} & proof-irrelevant & predicate                       \\
                              &                            &                                 & relevant         & family                          \\
                              &                            & iterated                        & relevant         & \emph{this work}                \\
                              & \multirow{3}{1cm}{fibred}  & \multirow{2}{2cm}{non-iterated} & proof-irrelevant & subobject                       \\
                              &                            &                                 & relevant         & fibration                       \\
                              &                            & iterated                        & relevant         & augmented semi-simplicial set   \\
  \midrule
  \multirow{6}{0.4cm}{binary} & \multirow{3}{1cm}{indexed} & \multirow{2}{2cm}{non-iterated} & proof-irrelevant & relation                        \\
                              &                            &                                 & relevant         & correspondence                  \\
                              &                            & iterated                        & relevant         & \emph{this work}                \\
                              & \multirow{3}{1cm}{fibred}  & \multirow{2}{2cm}{non-iterated} & proof-irrelevant & fibred relation                 \\
                              &                            &                                 & relevant         & span                          & \\
                              &                            & iterated                        & relevant         & semi-cubical set                \\
  \bottomrule
\end{tabularx}

\paragraph*{Iterated parametricity in indexed form.}
In \cite{hr25}, the fibred-indexeed correspondence was exploited to simultaneously construct augmented semi-simplicial and semi-cubical sets in \emph{indexed form}, as a special case of iterated parametricity. Instead of the following illustration of semi-cubical sets,

\begin{equation*}
  \begin{tikzcd}
    X_0: \U & X_1: \U \arrow[l, "\partial^L" description, shift left=2] \arrow[l, "\partial^R" description, shift right=2] & X_2: \U \arrow[l, "\partial^{L\kstar}" description, shift left=6] \arrow[l, "\partial^{R\kstar}" description, shift left=2] \arrow[l, "\partial^{\kstar L}" description, shift right=2] \arrow[l, "\partial^{\kstar R}" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}
a family of relevant relations was used:
\begin{equation*}
  \begin{array}{lll}
    E_0 & :               \U                                                                          \\
    E_1 & :               E_0 \times X_0 \rightarrow  \U                                              \\
    E_2 & : \Pi a b c d.\,  E_1(a,b) \times E_1 (c,d) \times E_1(a,c) \times E_1 (b,d) \rightarrow \U \\
    \ldots
  \end{array}
\end{equation*}

% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{painting}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrpainting}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohpainting}[D, d]

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and painting
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and painting
% Drop the universe letter
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrp}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
% Keep only ε, ω; n, p; proposition on n and p
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\renewcommandx{\cohp}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][][][][][#9]}

For $\nu$ an arity, that is $1$ in the case of predicates, families and augmented semi-simplicial sets, or $2$ in the case of relations, correspondences and semi-cubical sets, such sequence of was called a $\nu$-set. Equations specifying $\nu$-sets were given in the work with an accompanying formalisation in Rocq. The argument used to justify the well-foundedness of the construction was however heavy. This work presents a refined well-foundedness argument which reflects the recursive essence of the construction.

\section{High-level description of iterated parametricity in indexed form\label{sec:reminder}}

Because of the dependency of $E_{n+1}$ into all $E_p$ for $p \leq n$, the family could not be expressed as a function. Instead, it was expressed as a stream whose $(n+1)$-th element $E_{n+1}$ was dependent on the bundle of all previous elements of the stream. Such a bundle was called $\Xto{m}{n}$ while the residual stream of all $E_{n}$, $E_{n+1}$, ..., all of them precisely dependent on the bundle $E:\Xto{m}{n}$ of previous $E_0$, ..., $E_{n-1}$, was called $\Xfrom{m}{n}{D}$. The type of $E_n$, also dependent on a bundle $D:\Xto{m}{n}$, was denoted $\Xcomp{m}{n}[D=\D]$, as shown on tables~\ref{tab:coind} and~\ref{tab:core}, using an type theory as language of discourse. When $n$ is $0$, $\Xto{m}{0}$ is degenerated, that is reduced to the canonical inhabitant $\kstar$ of $\unittype$. Then, $\Xfrom{m}{0}{\kstar}$ denotes the full stream $E_0, E_1, \ldots$.

The type $\Xcomp{m}{n}[D=E_0,\ldots,E_{n-1}]$ of $E_n$ represents a family whose type can be presented into the form $\fullframe(E_0,\ldots,E_{n-1}) \rightarrow \U$ where $\fullframe$ collects all the dependencies of $E_n$. It is recursively defined in table~\ref{tab:frames}, using the auxiliary definitions of $\framep$, $\layer$ and $\painting$. A $\fullframe$ describes a boundary of a standard form (simplex, cube), which we decompose into $\layer$ themselves made of $\nu$ $\painting$ ($\nu=1$, $\nu=2$, ...), where a $\painting$ corresponds to a filled frame. Notice that the type $\layer$ relies on an operator of frame restriction $\restrf$ which is defined in table~\ref{tab:faces}, and this restriction operator is in turn defined using auxiliary definitions $\restrl$ and $\restrp$ (see \cite{hr25} for details).

Notably, the definition of $\restrl$ relies on an equality expressing the commutation of the composition of two $\restrf$. The proof of this commutation is worth being made explicit, which we do in table~\ref{tab:coh} using proof-term notations\footnote{We however omit type conversions, as if working in extensional type theory. E.g. the definition of $\restrl$ implicitly use $\cohf$ so that the type of $\restrp$ gets its expected type.}. The proof is by recursion on the structure of $\framep$, $\layer$, and $\painting$. This is what $\cohf$ does using auxiliary proofs $\cohl$ and $\cohp$. Note that for a fixed constant $n$, relying on the evaluation rules of type theory, the coherence conditions degenerate to a reflexivity proof, so that the construction builds an effective sequence of types not mentioning coherences anymore.

\def\lab{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

\def\lab{tab:core}
\input{tab-core.tex}

\def\lab{tab:frames}
\input{tab-frames.tex}

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\def\lab{tab:faces}
\input{tab-faces-ett.tex}

% Restriction for frame, layer, and painting
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrp}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohp}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][#4][#5][#6,#7][#8][#9]}

\def\lab{tab:coh}
\input{tab-coh-ett.tex}

\renewcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\renewcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\renewcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\renewcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrp}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\renewcommandx{\cohf}[6][1,2,3,4,5,6]{\coh{frame}[][#3][#4][#5][#6][#1][#2][]}
\renewcommandx{\cohl}[6][1,2,3,4,5,6]{\coh{layer}[][#3][#4][#5][#6][#1][#2][]}
\renewcommandx{\cohp}[6][1,2,3,4,5,6]{\coh{painting}[][#3][#4][#5][#6][#1][#2][]}

\section{Analysis of the recursive structure of iterated parametricity in indexed form}

To build $\framep[n+1]$ from $\framep[n]$, it happens to be enough to assume the following built at level $n$, for all $p \leq n$:

\begin{equation*}
  \begin{array}{lcl}
    \framep[n][p]   & : & \U                                                                                                  \\
    \painting[n][p] & : & \framep[n][p] \rightarrow \U                                                                        \\
    \restrf[n][p]   & : & \Pi q \leq n-p.\, \Pi \epsilon.\, \framep[n+1][p] \rightarrow \framep[n][p]                         \\
    \restrp[n][p]   & : & \Pi q \leq n-p.\, \Pi \epsilon.\, \Pi d:\framep[n+1][p].\,                                          \\
                    &   & \painting[n+1][p](d) \rightarrow \painting[n][p](\restrf[n][p](d))                                  \\
    \cohf[n][p]     & : & \Pi qr\epsilon\omega.\, \restrf[n][p][q][\epsilon] \circ \restrf[n+1][p][\omega][r] =               \\
                    &   & \restrf[n][p][\omega][r] \circ \restrf[n+1][p][q+1][\epsilon]                                       \\
    \cohp[n][p]     & : & \Pi qr\epsilon\omega.\,\Pi d:\framep[n+2][p].\,                                                     \\
                    &   & \restrp[n][p][q][\epsilon](\restrf[n+1][p][r][\omega](d)) \circ \restrp[n+1][p][r][\omega](d) =     \\
                    &   & \restrp[n][p][r][\omega](\restrf[n+1][p][q+1][\epsilon](d)) \circ \restrp[n+1][p][q+1][\epsilon](d) \\
  \end{array}
\end{equation*}
and to build it at level $n+1$. This is however not so easy because some components of this structure, e.g. $\restrf$ and further fields, depend on $\framep[n+1]$, that is already depend on the ability of building the $\framep$ component of the structure at level $n+1$. We are thus facing an interdependency between specifying the structure assumed at level $n$ and defining from it the structure at level $n+1$. So, we have to proceed in order: specifying $\framep[n]$, from which $\painting[n]$ can be specified, from which $\framep[n+1]$ can be built and thus $\restrf[n+1]$ be specified. Now, the definition of $\framep[n+1][p]$, which is by induction on $p$, itself depends on $\restrf[n][p-1]$ whose type depends in turn on $\framep[n+1][p-1]$. This means that $\framep[n+1][p]$ and the type of $\restrf[n][p]$ actually have to be mutually defined.

The definition of $\framep[n+1][p]$ also depends, via $\layer[n][p-1]$, on $\painting[n][p-1]$. Both via $\painting[n][p-1]$ and $\restrf[n][p-1]$, it depends also on $\framep[n][p-1]$ by typing dependency. This requires to assume $\framep[n][p-1]$ and $\painting[n][p-1]$ known in advance. Moreover, the definition of $\framep[n+1][p]$ depends on $\framep[n+1][p-1]$, so all of $\framep[n][k]$, $\painting[n][k]$ and $\restrf[n][k]$ for $k< p$ need to be known, which we respectively abbreviate as $\framep[n][\lbrack 0,p-1 \rbrack]$, $\painting[n][\lbrack 0,p-1 \rbrack]$ and $\restrf[n][\lbrack 0,p-1 \rbrack]$. Schematically, using dotted arrows for dependencies in the type and plain arrows for dependencies in the definition, this gives the following graph of dependencies for $p\leq n+1$ fixed:

\begin{center}
  \begin{tikzcd}
    \framep[n+1][\lbrack 0,p \rbrack] \arrow[d] \arrow[ddr]\\
    \painting[n][\lbrack 0,p-1 \rbrack] \arrow[d, dotted] \\
    \framep[n][\lbrack 0,p-1 \rbrack] &
    \restrf[n][\lbrack 0,p-1 \rbrack] \arrow[l, dotted] \arrow[uul, dotted, "\mbox{$[0,p-1]$}"', near start, shift right=2mm, hook']\\
  \end{tikzcd}
\end{center}

In particular, the mutual dependency on one side of $\framep[n][\lbrack 0,p-1 \rbrack]$ within the type of $\restrf[n][\lbrack 0,p-1 \rbrack]$ and on the other side of $\restrf[n][\lbrack 0,p-1 \rbrack]$ within the definition of $\framep[n][\lbrack 0,p \rbrack]$ requires to mutually define the type of $\restrf[n][\lbrack 0,p-1 \rbrack]$ together with $\framep[n][p]$ (or $\framep[n][\lbrack 0,p \rbrack]$) as a \emph{function} from $\restrf[n][\lbrack 0,p-1 \rbrack]$.

So far, using this recursive definition of  $\framep[n][\lbrack 0,p-1 \rbrack]$ and $\restrf[n][\lbrack 0,p-1 \rbrack]$, we are able to specify the three first component of the expected dependent structure, for $p \leq n$:
\begin{equation*}
  \begin{array}{lcl}
    \framep[n][p]   & : & \U                                                \\
    \painting[n][p] & : & \framep[n][p] \rightarrow \U                      \\
    \restrf[n][p]   & : & \Pi q \leq n-p.\, \Pi \epsilon.\, \framep[n+1][p]
    \left(\begin{array}{l}
              \framep[n][\lbrack 0,p-1 \rbrack]   \\
              \painting[n][\lbrack 0,p-1 \rbrack] \\
              \restrf[n][\lbrack 0,p-1 \rbrack]   \\
            \end{array}\right)
    \rightarrow \framep[n][p]                                               \\
  \end{array}
\end{equation*}
which can appropriately be reformulated using sequences for appropriate definitions of $\frametype[n][\lbrack 0,p \rbrack]$, $\paintingtype[n][\lbrack 0,p \rbrack]$ and $\restrftype[n][\lbrack 0,p \rbrack]$, since the dependencies of $\restrf[n][p]$ into $\restrf[n][\lbrack 0,p-1 \rbrack]$ makes it a very dependent function~\cite{Hickey96}:
\begin{equation*}
  \begin{array}{lcl}
    \framep[n][\lbrack 0,p \rbrack]   & : & \frametype[n][\lbrack 0,p \rbrack]                                     \\
    \painting[n][\lbrack 0,p \rbrack] & : & \paintingtype[n][\lbrack 0,p \rbrack](\framep[n][\lbrack 0,p \rbrack]) \\
    \restrf[n][\lbrack 0,p \rbrack]   & : & \restrftype[n][\lbrack 0,p \rbrack]
    \left(\begin{array}{l}
              \framep[n][\lbrack 0,p-1 \rbrack]   \\
              \painting[n][\lbrack 0,p-1 \rbrack] \\
              \restrf[n][\lbrack 0,p-1 \rbrack]   \\
            \end{array}\right)                                                                      \\
  \end{array}
\end{equation*}

The type of sequences such as $\restrf[n][\lbrack 0,p \rbrack]$ will be represented by iterated $\Sigma$-types since each $\restrf[n][p]$ may depend on the previous components of the sequence. In the case of $\framep$ and $\painting$, there will be however no dependency, so an ordinary product can be used to represent $\framep[n][\lbrack 0,p \rbrack]$ and $\painting[n][\lbrack 0,p \rbrack]$. Later on, we will write $\framep[n][\lbrack 0,p-1 \rbrack]$ for the immediate subsequence of length $p$ of $\framep[n][\lbrack 0,p \rbrack]$ and $\framep[n][p]$ for its last component, and similarly for $\painting[n][\lbrack 0,p \rbrack]$, $\restrf[n][\lbrack 0,p \rbrack]$, etc.

\section{Detailed construction}

\subsection{Specifying frames}

Assuming $\framep[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$ only requires to define the type of frames, which are just finite products of $\U$:

\begin{equation*}
  \begin{array}{llcl}
    \frametype[n][\lbrack 0,p-1 \rbrack] &  & :      & \U                                               \\
    \frametype[n]                        &  & \defeq & \unittype                                        \\
    \frametype[n][\lbrack 0,p \rbrack]   &  & \defeq & \frametype[n+1][\lbrack 0,p-1 \rbrack] \times \U \\
  \end{array}
\end{equation*}

\subsection{Specifying paintings}

The types $\paintingtype[n][\lbrack 0,p-1 \rbrack]$ of $\painting[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$ are type families over frames, so $\framep[n][\lbrack 0,p-1 \rbrack]$ needs to be assumed beforehand:

\begin{equation*}
  \begin{array}{llcl}
    \paintingtype[n][\lbrack 0,p-1 \rbrack] & \framep[n][\lbrack 0,p-1 \rbrack] & :      & \U                                                                                                                   \\
    \paintingtype[n]                        & \unitpoint                        & \defeq & \unittype                                                                                                            \\
    \paintingtype[n][\lbrack 0,p \rbrack]   & \framep[n][\lbrack 0,p \rbrack]   & \defeq & \paintingtype[n+1][\lbrack 0,p-1 \rbrack](\framep[n+1][\lbrack 0,p-1 \rbrack]) \times (\framep[n][p] \rightarrow \U) \\
  \end{array}
\end{equation*}

\subsection{Defining frames and specifying frame restrictions\label{sec:mkframe}}

Assuming $\framep[n][\lbrack 0,p-1 \rbrack]$ and $\painting[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$, we can mutually define the types $\restrftype[n][\lbrack 0,p-1 \rbrack]$ of frame restrictions together with $\framep[n+1][\lbrack 0,p \rbrack]$ as a function from $\restrf[n][\lbrack 0,p-1 \rbrack]$, introducing also abbreviations for the types and definitions of layers, as well as for the combination of sequences of $\framep[n][\lbrack 0,p-1 \rbrack]$, $\painting[n][\lbrack 0,p-1 \rbrack]$ and $\restrf[n][\lbrack 0,p-1 \rbrack]$ in one block, which we call $\depstype[n][\lbrack 0,p-1 \rbrack]$:

\begin{equation*}
  \begin{array}{llcl}
    \depstype[n][\lbrack 0,p-1 \rbrack]    &        & \defeq                               &
    \left(\begin{array}{lll}
              \framep[n][\lbrack 0,p-1 \rbrack]   & : & \frametype[n][\lbrack 0,p-1 \rbrack]    \\
              \painting[n][\lbrack 0,p-1 \rbrack] & : & \paintingtype[n][\lbrack 0,p-1 \rbrack]
              (\framep[n][\lbrack 0,p-1 \rbrack])                                               \\
              \restrf[n][\lbrack 0,p-1 \rbrack]   & : & \restrftype[n][\lbrack 0,p-1 \rbrack]
              \left(\begin{array}{l}
                  \framep[n][\lbrack 0,p-1 \rbrack]   \\
                  \painting[n][\lbrack 0,p-1 \rbrack] \\
                \end{array}\right)                                         \\
            \end{array}\right)  \\
    \framep[n+1][\lbrack 0,p \rbrack]      &
    \deps[n][\lbrack 0,p-1 \rbrack]        & :      & \frametype[n+1][\lbrack 0,p \rbrack]   \\
    \framep[n+1][\lbrack 0,0 \rbrack]      &
    \unitpoint                             & \defeq & (\unitpoint,\unittype)                 \\
    \framep[n+1][\lbrack 0,p+1 \rbrack]    &
    \deps[n][\lbrack 0,p \rbrack]          & \defeq &
    \left(\begin{array}{l}
              \framep[n+1][\lbrack 0,p \rbrack]
              (\deps[n][\lbrack 0,p-1 \rbrack]), \\
              \Sigma d:\framep[n+1][p]
              (\deps[n][\lbrack 0,p-1 \rbrack]).
              \, \layer[n][p]
              (\deps[n][\lbrack 0,p \rbrack])
              (d)                                \\
            \end{array}\right)                                                 \\
    \restrftype[n][\lbrack 0,p-1 \rbrack]  &
    \left(\begin{array}{l}
              \framep[n][\lbrack 0,p-1 \rbrack]   \\
              \painting[n][\lbrack 0,p-1 \rbrack] \\
            \end{array}\right) & :      & \U                                                \\
    \restrftype[n]                         &
    \left(\begin{array}{l}
              \unitpoint \\
              \unitpoint \\
            \end{array}\right)                 & \defeq &
    \unittype                                                                                \\
    \restrftype[n][\lbrack 0,p \rbrack]    &
    \left(\begin{array}{l}
              \framep[n][\lbrack 0,p \rbrack]   \\
              \painting[n][\lbrack 0,p \rbrack] \\
            \end{array}\right)   & \defeq &
    \left\{\begin{array}{l}
             \Sigma \restrf[n][\lbrack 0,p-1 \rbrack]
             :\restrftype[n][\lbrack 0,p-1 \rbrack]
             \left(\begin{array}{l}
                \framep[n+1][\lbrack 0,p-1 \rbrack]   \\
                \painting[n+1][\lbrack 0,p-1 \rbrack] \\
              \end{array}\right).         \\
             \Pi q \leq n-p.\,\Pi \epsilon.\,\framep[n+1][p]
             \left(\begin{array}{l}
                \framep[n][\lbrack 0,p-1 \rbrack]   \\
                \painting[n][\lbrack 0,p-1 \rbrack] \\
                \restrf[n+1][\lbrack 0,p-1 \rbrack] \\
              \end{array}\right) \rightarrow  \framep[n][p] \\
           \end{array}\right.                \\
    \layertype[n][p]                       &
    \deps[n][\lbrack 0,p \rbrack]
                                           & :      & \U                                     \\
    \layertype[n][p]                       &
    \deps[n][\lbrack 0,p \rbrack]
                                           & \defeq & \framep[n+1][p]
    (\deps[n][\lbrack 0,p-1 \rbrack])
    \rightarrow \U                                                                           \\
    \layer[n][p]                           &
    \deps[n][\lbrack 0,p \rbrack]
                                           & :      & \layertype[n][p]
    (\deps[n][\lbrack 0,p \rbrack])
    \\
    \layer[n][p]                           &
    \deps[n][\lbrack 0,p \rbrack]
                                           & \defeq &
    \lambda d.\, \Pi\epsilon.\,\painting[n][p](\restrf[n][p][0][\epsilon](d))                \\
  \end{array}
\end{equation*}

Note that $\deps$ behaves here as an abbreviation for a sequence of assumptions. In particular, once a $\deps:\depstype$ is assumed, we can freely refer to $\framep$, $\painting$, $\restrf$. Also, by abuse of notation, we write $\unitpoint$ for the only inhabitant of $\depstype[n][0]$.

\subsection{Defining paintings\label{sec:mkpainting}}

Defining $\painting[n+1][p]$ for $p \leq n+1$, in addition to the type dependency in $\framep[n+1][p]$, requires the definition of $\painting[n][p-1]$, thus also $\framep[n][p-1]$ by typing dependency, as well as $\restrf[n][p-1]$. Since $\painting[n+1][p]$ also depends on $\painting[n+1][p+1]$ when $p<n+1$, these dependencies are actually between $\painting[n+1][\lbrack p,n+1 \rbrack]$, $\painting[n][\lbrack p,n \rbrack]$, $\framep[n+1][\lbrack p,n+1 \rbrack]$, $\framep[n][\lbrack p,n \rbrack]$ and $\restrf[n][\lbrack p,n \rbrack]$. Also, for the case $p=n$, this requires the assumption of an inhabitant $E_n$ of $\nu$Set$^{=n}$. Finally, $\framep[n+1][\lbrack p,n+1 \rbrack]$, $\framep[n+1][\lbrack p,n \rbrack]$ and $\restrf[n][\lbrack p,n \rbrack]$ respectively depend on the earlier values $\framep[n+1][\lbrack 0,p-1 \rbrack]$, $\framep[n][\lbrack 0,p-1 \rbrack]$ and $\restrf[n][\lbrack 0,p-1 \rbrack]$.  Below, we use dashed underline and dashed arrows for dependencies in subconstructions, here in the construction of $\framep$ at level $n$ and $\restrftype$ at level $n$:
\begin{center}
  \begin{tikzcd}
    & & \painting[n+1][\lbrack p,n+1 \rbrack] \arrow[dd, bend right=70] \arrow[dddr] \arrow[d, dotted]\\
    \udensdash{\framep[n+1][\lbrack 0,p-1 \rbrack]} \arrow[d, dashed] \arrow[ddr, dashed] & &
    \udensdash{\framep[n+1][\lbrack p,n+1 \rbrack]} \arrow[ll, dotted] \arrow[d, dashed] \arrow[ddr, dashed, shift right=2mm] \\
    \painting[n][\lbrack 0,p-1 \rbrack] \arrow[d, dotted] & &
    \painting[n][\lbrack p,n-1 \rbrack] \arrow[ll, dotted] \arrow[d, dotted] \\
    \framep[n][\lbrack 0,p-1 \rbrack] &
    \udensdash{\restrf[n][\lbrack 0,p-1 \rbrack]} \arrow[l, dotted] \arrow[uul, dotted, shift right=2mm, hook'] &
    \framep[n][\lbrack p,n \rbrack] \arrow[ll, dotted, bend left=15] &
    \udensdash{\restrf[n+1][\lbrack p,n \rbrack]},X_n \arrow[ll, dotted, bend left=15] \arrow[l, dotted] \arrow[uul, dotted, hook']\\
  \end{tikzcd}
\end{center}

Let us introduce another abbreviation to combine a full $\deps[n][\lbrack 0,n \rbrack]:\depstype[n][\lbrack 0,n \rbrack]$ with a family $E:\framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack])\rightarrow \U$:
\begin{equation*}
  \fulldepstype[n] \defeq
  \left(\begin{array}{lcl}
      \deps[n][\lbrack 0,n \rbrack] & : & \depstype[n][\lbrack 0,n \rbrack]                               \\
      E                             & : & \framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack]) \rightarrow \U \\
    \end{array}\right)
\end{equation*}

Also, when $n$ is $0$, we write $E$ to denote an element of $\fulldepstype[0]$ where all other components are degenerate.

We can now formally define $\painting[n+1][p]$ for $p \leq n+1$ by recursion from the base case $n+1$ and down to $p$:
\begin{equation*}
  \begin{array}{llcl}
    \painting[n+1][p]        &
    \fulldeps[n]             & :      & \paintingtype[n+1][p] \\
    \painting[n+1][n+1]      &
    \fulldeps[n]             & \defeq & E                     \\
    \painting[n+1][p \leq n] &
    \fulldeps[n]             & \defeq & \lambda d.\,
    \Sigma l:\layer[n][p](\deps[n][\lbrack 0,p \rbrack]).
    \painting[n+1][p+1]
    (\fulldeps[n])(d,l)                                       \\
  \end{array}
\end{equation*}

From which we can deduce $\painting[n+1][\lbrack 0,p-1 \rbrack]$ for $p \leq n+2$ by a second recursion, this time on $p$:

\begin{equation*}
  \begin{array}{llcl}
    \painting[n+1][\lbrack 0,p-1 \rbrack] &
    \fulldeps[n]                          & :      & \paintingtype[n+1][\lbrack 0,p-1 \rbrack](\framep[n+1][\lbrack 0,p-1 \rbrack](\deps[n][\lbrack 0,p-1 \rbrack])) \\
    \painting[n+1]                        &
    \fulldeps[n]                          & \defeq & \unittype                                                                                                       \\
    \painting[n+1][\lbrack 0,p \rbrack]   &
    \fulldeps[n]
                                          & \defeq &
    (\painting[n+1][\lbrack 0,p-1 \rbrack](\fulldeps[n]),\painting[n+1][p](\fulldeps[n]))                                                                            \\
  \end{array}
\end{equation*}

\subsection{Specifying painting restrictions}

At this stage, we are able to define $\framep[n+1][\lbrack 0,n+1 \rbrack]$, $\painting[n+1][\lbrack 0,n+1 \rbrack]$ and $\restrftype[n][\lbrack 0,n \rbrack]$ from $\framep[n][\lbrack 0,n \rbrack]$, $\painting[n][\lbrack 0,n \rbrack]$ and $\restrf[n][\lbrack 0,n \rbrack]$, that is from $\deps[n][\lbrack 0,n \rbrack]$. To go further, we need to specify the sequence $\restrptype[n][\lbrack 0,p-1 \rbrack]$ of types of painting restrictions, for $p \leq n+1$:

\begin{equation*}
  \begin{array}{llcl}
    \restrptype[n][\lbrack 0,p-1 \rbrack] &
    \fulldeps[n]                          & :      & \U                                                       \\
    \restrptype[n]                        & E      & \defeq                                       & \unittype \\
    \restrptype[n][\lbrack 0,p \rbrack]   &
    \fulldeps[n]
                                          & \defeq & \restrptype[n][\lbrack 0,p-1 \rbrack] \times             \\
                                          &        &                                              & \left(
    \begin{array}{l}
        \Pi q \leq n-p.\Pi \epsilon.\Pi d:\framep[n+1][p](\deps[n][\lbrack 0,p-1 \rbrack]). \\
        \painting[n+1][p]
        (\fulldeps[n])(d) \rightarrow                                                       \\ \painting[n][p](\restrf[n][p][q][\epsilon](d))\end{array}
    \right)                                                                                                   \\
  \end{array}
\end{equation*}

\subsection{Defining frame restrictions and specifying frame coherence laws\label{sec:mkrestrf}}

Thanks to $\restrptype[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$, we can mutually define $\restrf[n+1][\lbrack 0,p \rbrack]$ and specify $\cohftype[n][\lbrack 0,p-1 \rbrack]$ from $\framep[n][\lbrack 0,n \rbrack]$, $\painting[n][\lbrack 0,n \rbrack]$, $\restrf[n][\lbrack 0,n \rbrack]$, $\restrptype[n][\lbrack 0,p-1 \rbrack]$ and some $E:\framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack]) \rightarrow \U$, abbreviating these dependencies and the dependency in a $\cohf[n][\lbrack 0,p-1 \rbrack]$ as $\depscohstype[n][\lbrack 0,p-1 \rbrack]$, and using also abbreviations in passing for $\restrl$ and $\restrltype$. It is also convenient to build $\deps[n+1][\lbrack 0,p \rbrack]$ from $\depscohs[n][\lbrack 0,p-1 \rbrack]$, so that we can now build $\framep[n+2][p]$ one step further. Thus, we also include this abbreviation in the definition:
\begin{equation*}
  \begin{array}{llcl}
    \depscohstype[n][\lbrack 0,p-1 \rbrack] &                                     & \defeq                                                         &
    \left(\begin{array}{lcl}
              \fulldeps[n]                      & : & \fulldepstype[n]                                    \\
              \restrp[n][\lbrack 0,p-1 \rbrack] & : & \restrptype[n][\lbrack 0,p-1 \rbrack](\fulldeps[n]) \\
              \cohf[n][\lbrack 0,p-1 \rbrack]   & : & \cohftype[n][\lbrack 0,p-1 \rbrack]
              \left(\begin{array}{l}
                  \fulldeps[n]                      \\
                  \restrp[n][\lbrack 0,p-1 \rbrack] \\
                \end{array}\right)                                                     \\
            \end{array}\right)                                                \\
    \overline{\deps}                        &
    \depscohs[n][\lbrack 0,p-1 \rbrack]     & :                                   & \depstype[n+1][\lbrack 0,p \rbrack]                              \\
    \overline{\deps}                        & \depscohs[n][\lbrack 0,p-1 \rbrack] & \defeq                                                         &
    \left(\begin{array}{l}
              \framep[n+1][\lbrack 0,p \rbrack](\deps[n][\lbrack 0,p-1 \rbrack])     \\
              \painting[n+1][\lbrack 0,p \rbrack](\fulldeps[n])                      \\
              \restrf[n+1][\lbrack 0,p \rbrack](\depscohs[n][\lbrack 0,p-1 \rbrack]) \\
            \end{array}\right)                                                                     \\
    \restrf[n+1][\lbrack 0,p \rbrack]       &
    \depscohs[n][\lbrack 0,p-1 \rbrack]     & :                                   &
    \restrftype[n+1][\lbrack 0,p \rbrack]
    \left(\begin{array}{l}
              \framep[n+1][\lbrack 0,p \rbrack](\deps[n][\lbrack 0,p \rbrack]) \\
              \painting[n+1][\lbrack 0,p \rbrack](\fulldeps[n])                \\
            \end{array}\right)                                                                           \\
    \restrf[n+1][\lbrack 0,0 \rbrack]       &
    E
                                            & \defeq                              & (\unitpoint,\lambda q. \lambda\epsilon. \lambda \_.\unitpoint)   \\
    \restrf[n+1][\lbrack 0,p+1 \rbrack]     &
    \depscohs[n][\lbrack 0,p \rbrack]       & \defeq                              &
    \left(\begin{array}{l}
              \restrf[n+1][\lbrack 0,p \rbrack][q][\epsilon]
              (\depscohs[n][\lbrack 0,p-1 \rbrack]),
              \lambda q.\lambda \epsilon.\lambda (d,l).        \\
              \left(\restrf[n+1][p][q][\epsilon]
                (\depscohs[n][\lbrack 0,p-1 \rbrack])(d), \restrl[n][p][q][\epsilon]
              (\depscohs[n][\lbrack 0,p \rbrack])(d)(l)\right) \\
            \end{array} \right)                                                                              \\
    \cohftype[n][\lbrack 0,p-1 \rbrack]     &
    \left(\begin{array}{l}
              \fulldeps[n]                      \\
              \restrp[n][\lbrack 0,p-1 \rbrack] \\
            \end{array}\right)    & :                                   & \U                                                                           \\
    \cohftype[n]                            &
    \left(\begin{array}{l}
              E          \\
              \unitpoint \\
            \end{array}\right)                  & \defeq                              &
    \unittype                                                                                                                                        \\
    \cohftype[n][\lbrack 0,p \rbrack]       &
    \left(\begin{array}{l}
              \fulldeps[n]                    \\
              \restrp[n][\lbrack 0,p \rbrack] \\
            \end{array}\right)      & \defeq                              &
    \left\{\begin{array}{l}
             \Sigma \cohf[n][\lbrack 0,p-1 \rbrack][q][r][\epsilon][\omega]
             :\cohftype[n][\lbrack 0,p-1 \rbrack]
             \left(\begin{array}{l}
                \fulldeps[n]                      \\
                \restrp[n][\lbrack 0,p-1 \rbrack] \\
              \end{array}\right).                          \\
             \Pi d:\framep[n+2][p]
             \left(\overline{\deps}\left(\begin{array}{l}
                                        \fulldeps[n]                      \\
                                        \restrp[n][\lbrack 0,p-1 \rbrack] \\
                                        \cohf[n][\lbrack 0,p \rbrack]
                                      \end{array}\right)\right)          . \\
             \\
             \restrf[n][p][q][\epsilon](\restrf[n+1][p][r][\omega]
             \left(\begin{array}{l}
                \fulldeps[n]                      \\
                \restrp[n][\lbrack 0,p-1 \rbrack] \\
                \cohf[n][\lbrack 0,p \rbrack]
              \end{array}\right)(d)) =                          \\
             \restrf[n][p][r][\omega](\restrf[n+1][p][q+1][\epsilon]
             \left(\begin{array}{l}
                \fulldeps[n]                      \\
                \restrp[n][\lbrack 0,p-1 \rbrack] \\
                \cohf[n][\lbrack 0,p \rbrack]
              \end{array}\right)(d))                          \\
           \end{array}\right.                                                                    \\
    \restrltype[n][p]                       &
    \depscohs[n][\lbrack 0,p \rbrack]
                                            & :                                   & \U                                                               \\
    \restrltype[n][p]                       &
    \depscohs[n][\lbrack 0,p \rbrack]
                                            & \defeq                              &
    \left\{\begin{array}{l}
             \Pi q \leq n-p. \Pi \epsilon. \Pi d: \framep[n+2][p](\overline{\deps}(\depscohs[n][\lbrack 0,p-1 \rbrack])).\, \\
             \layer[n+1][p](\overline{\deps}(\depscohs[n][\lbrack 0,p-2 \rbrack])(d) \rightarrow                            \\
             \layer[n][p](\deps[n][\lbrack 0,p \rbrack])(\restrf[n][p]
             (\depscohs[n][\lbrack 0,p-1 \rbrack])(d))
           \end{array}\right.                            \\
    \restrl[n][p]                           &
    \depscohs[n][\lbrack 0,p \rbrack]       & :                                   &
    \restrltype[n][p] (\depscohs[n][\lbrack 0,p \rbrack])                                                                                            \\
    \restrl[n][p][q][\epsilon]              &
    \depscohs[n][\lbrack 0,p \rbrack]       & \defeq                              &
    \begin{array}{l}
      \lambda d.\lambda l.\lambda \omega.\overrightarrow{\cohf[n][p][q][0][\epsilon][\omega](d)}               \\
      \restrp[n][p][q][\epsilon](\restrf[n][p][q][\epsilon](\depscohs[n][\lbrack 0,p-1 \rbrack])(d))(l_\omega) \\
    \end{array}
  \end{array}
\end{equation*}

We need also the notion of full dependencies at the level of coherence conditions, that combines a full $\depscohs[n][\lbrack 0,n \rbrack]$ with a set $E:\framep[n+2][n+2](\overline{\deps}(\depscohs[n][\lbrack 0,n \rbrack])) \rightarrow \U$:
\begin{equation*}
  \fulldepscohstype[n] \defeq
  \left(\begin{array}{lcl}
      \depscohs[n][\lbrack 0,n \rbrack] & : & \depscohstype[n][\lbrack 0,n \rbrack]                                                \\
      E                                 & : & \framep[n+2][n+2](\overline{\deps}(\depscohs[n][\lbrack 0,n \rbrack]))\rightarrow \U \\
    \end{array}\right)
\end{equation*}

We can then extend $\overline{\deps}$ to build $\fulldeps$ from $\fulldepscohs$:
\begin{equation*}
  \begin{array}{lcl}
    \overline{\fulldeps}(\fulldepscohs[n]) & :      & \fulldepstype[n+1] \\
    \overline{\fulldeps}(\fulldepscohs[n]) & \defeq & \left(
    \begin{array}{l}
        \overline{\deps}(\depscohs[n][\lbrack 0,n \rbrack]) \\
        E                                                   \\
      \end{array}\right)                  \\
  \end{array}
\end{equation*}

Also, when $n$ is 0, we write $(E,E')$ to denote an element $(E, E')$ of $\fulldepscohstype[0]$.

\subsection{Defining painting restrictions\label{sec:mkrestrp}}

Armed with $\restrf$, $\cohftype$ and these abbreviations, it is now possible to define $\restrp[n+1][p]$ for $p \leq n+1$ by recursion on $n-p$:

\begin{equation*}
  \begin{array}{llcl}
    \restrp[n+1][p][q][\epsilon]        &
    \fulldepscohs[n]                    & :      &
    \left(
    \begin{array}{l}
        \Pi d:\framep[n+2][p]
        (\overline{\deps}(\depscohs[n][\lbrack 0,p-2 \rbrack])). \\
        \painting[n+2][p]
        (\overline{\fulldeps}(\fulldepscohs[n]))(d) \rightarrow  \\
        \painting[n+1][p](\fulldeps[n])
        (\restrf[n+1][p](\depscohs[n][\lbrack 0,p-1 \rbrack])(d))\end{array}\right)                                         \\
    \restrp[n+1][n+1][q][\epsilon]      &
    \fulldepscohs[n]                    & \defeq & \lambda d. \lambda (l,c). l_\epsilon \\
    \restrp[n+1][p \leq n][q][\epsilon] &
    \fulldepscohs[n]                    & \defeq & \lambda d. \lambda (l,c).
    \left(\begin{array}{l}
              \restrl[n][p][q][\epsilon](\depscohs[n][\lbrack 0,p \rbrack])(d)(l), \\
              \restrp[n+1][p+1][q][\epsilon](\fulldepscohs[n])(d,l)(c)             \\
            \end{array}\right)          \\
  \end{array}
\end{equation*}

From which we can deduce $\restrp[n+1][\lbrack 0,p-1 \rbrack]$ for $p \leq n+2$ again by a second recursion, this time on $p$:

\begin{equation*}
  \begin{array}{llcl}
    \restrp[n+1][\lbrack 0,p-1 \rbrack] &
    \fulldepscohs[n]                    & :      & \restrptype[n+1][\lbrack 0,p-1 \rbrack](\fulldeps[n]) \\
    \restrp[n+1]                        &
    \fulldepscohs[n]                    & \defeq & \unittype                                             \\
    \restrp[n+1][\lbrack 0,p \rbrack]   &
    \fulldepscohs[n]
                                        & \defeq &
    (\restrp[n+1][\lbrack 0,p-1 \rbrack](\fulldepscohs[n]),\restrp[n+1][p](\fulldepscohs[n]))            \\
  \end{array}
\end{equation*}

\subsection{Specifying painting coherence laws}

At this stage, we are then able to define $\restrf[n+1][\lbrack 0,p \rbrack]$, $\restrp[n+1][\lbrack 0,p \rbrack]$ and $\cohftype[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$
from $\depscohs[n][\lbrack 0,p-1 \rbrack]$ at the previous level. To go further, we need to define the
sequence $\cohptype[n][\lbrack 0,p-1 \rbrack]$ of types of painting coherence laws:

\begin{equation*}
  \begin{array}{llcl}
    \cohptype[n][\lbrack 0,p-1 \rbrack] & \fulldepscohs[n] & :      & \U                                                           \\
    \cohptype[n]                        & \unitpoint       & \defeq & \unittype                                                    \\
    \cohptype[n][\lbrack 0,p \rbrack]   & \fulldepscohs[n] & \defeq & \cohptype[n][\lbrack 0,p-1 \rbrack](\fulldepscohs[n]) \times \\
                                        &                  &        & \left\{
    \begin{array}{l}
      \Pi q \leq n-p.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega.                                                                                       \\
      \Pi d:\framep[n+2][p](\overline{\deps}(\depscohs[n][\lbrack 0,p-2 \rbrack])).\,\Pi c:\painting[n+2][p](\overline{\fulldeps}(\fulldepscohs[n])). \\
      \restrp[n][p][q][\epsilon](\restrf[n+1][p](\depscohs[n][\lbrack 0,p-1 \rbrack])(d))(\restrp[n+1][p][r][\omega]
      (\fulldepscohs[n])(d)(c)) =_{\cohf[n][p][q][r][\epsilon][\omega]}                                                                               \\
      \restrp[n][p][r][\omega](\restrf[n+1][p](\depscohs[n][\lbrack 0,p-1 \rbrack])(d))(\restrp[n+1][p][q+1][\epsilon]
      (\fulldepscohs[n])(d)(c))
    \end{array}
    \right.                                                                                                                        \\
  \end{array}
\end{equation*}
where we use the ``equality over'' notation $t =_e u$ to mean $\overrightarrow{e}(t) = u$ whenever $t$ is of some type $P(a)$, $u$ of type $P(b)$ and $e$ a proof of $a = b$.

\subsection{Defining frame coherence laws and specifying frame 2-dimensional coherence laws\label{sec:mkcohf}}

Thanks to $\cohptype[n][\lbrack 0,p-1 \rbrack]$, we can mutually define $\cohf[n+1][\lbrack 0,p \rbrack]$ and $\cohttype[n][\lbrack 0,p-1 \rbrack]$ for $p \leq n+1$ from $\fulldepscohs[n]$. In practice, we now prove coherence conditions at dimension 2 by uniqueness of identity proofs, so, we do not need a mutual definition as it was the case in sections~\ref{sec:mkframe} and~\ref{sec:mkrestrf}. Thus, $\cohttype[n][\lbrack 0,p-1 \rbrack]$ is used here as an abbreviation which we actually need to define only for $p$, that is $\cohttype[n][p]$. rabbreviating the dependency as $\depscohttype[n][\lbrack 0,p-1 \rbrack]$, and using also abbreviations in passing for $\cohl$ and $\cohltype$. Note however that, due to reasoning with $\U$, we do not need to have $\cohf[n+1][\lbrack 0,p \rbrack]$ depending on a proof of $\cohttype[n][\lbrack 0,p-1 \rbrack]$ as the latter can be proved at once by uniqueness of identity proofs.

It is also convenient to build $\depscohs[n+1][\lbrack 0,p \rbrack]$ from $\depscoht[n][\lbrack 0,p-1 \rbrack]$, so that we can now build $\framep[n+3][p]$. Thus, we also include this abbreviation in the definition. Implicitly using in $\cohf[n+1][\lbrack 0,p \rbrack]$ that equalities in a $\Sigma$-type are equivalent to the $\Sigma$-type of the underlying equalities, we altogether have:

\begin{equation*}
  \begin{array}{llcl}
    \depscohttype[n][\lbrack 0,p-1 \rbrack]     &                                     & \defeq                                                                            &
    \left(\begin{array}{lll}
              \fulldepscohs[n]                & : & \fulldepscohstype[n]                                  \\
              \cohp[n][\lbrack 0,p-1 \rbrack] & : & \cohptype[n][\lbrack 0,p-1 \rbrack](\fulldepscohs[n]) \\
            \end{array}
    \right)                                                                                                                                                                                                         \\
    \overline{\depscohs}                        & \depscoht[n][\lbrack 0,p-1 \rbrack] & :                                                                                 & \depscohstype[n+1][\lbrack 0,p \rbrack] \\
    \overline{\depscohs}                        & \depscoht[n][\lbrack 0,p-1 \rbrack] & \defeq                                                                            &
    \left(\begin{array}{l}
              \overline{\deps}(\depscohs[n][\lbrack 0,p-1 \rbrack]) \\
              \restrp[n+1][p](\fulldepscohs[n])                     \\
              \cohf[n+1][p](\depscoht[n][\lbrack 0,p-1 \rbrack])    \\
            \end{array}\right)                                                                                                                                                     \\
    \cohf[n+1][\lbrack 0,p \rbrack]             &
    \depscoht[n][\lbrack 0,p-1 \rbrack]         & :                                   & \cohftype[n+1][\lbrack 0,p \rbrack]
    \left(\begin{array}{l}
              \overline{\fulldeps}(\fulldepscohs[n])              \\
              \restrp[n+1][\lbrack 0,p \rbrack](\fulldepscohs[n]) \\
            \end{array}\right)                                                                                                                                                       \\
    \\
    \cohf[n+1][\lbrack 0,0 \rbrack]             &
    \unitpoint                                  & \defeq                              & (\unitpoint,\lambda q.\lambda r. \lambda\epsilon. \lambda\omega.\lambda \_.\refl)                                           \\
    \cohf[n+1][\lbrack 0,p+1 \rbrack]           &
    \depscoht[n][\lbrack 0,p \rbrack]           & \defeq                              &
    \left(\begin{array}{l}
              \cohf[n+1][\lbrack 0,p \rbrack]
              (\depscoht[n][\lbrack 0,p-1 \rbrack]),                             \\
              \lambda q.\lambda r.\lambda \epsilon.\lambda \omega.\lambda (d,l). \\
              (\cohf[n+1][p][q][r][\epsilon][\omega]
              (\depscoht[n][\lbrack 0,p \rbrack])(d), \cohl[n][p][q][r][\epsilon][\omega]
              (\depscoht[n][\lbrack 0,p \rbrack])(d)(l))                         \\
            \end{array}\right)                                                                                                                                \\
    \coht[n][p]                                 &
    \fulldepscohs[n]                            & :                                   & \cohttype[n][p](\fulldepscohs[n])                                                                                           \\
    \coht[n][p][q][r][\epsilon][\omega][\theta] &
    \fulldepscohs[n]                            & \defeq                              & \lambda d.\,\UIP                                                                                                            \\

    \cohl[n][p]                                 &
    \depscoht[n][\lbrack 0,p \rbrack]           & :                                   &
    \left\{\begin{array}{l}
             \Pi q \leq n-p.\,\Pi r\leq q.\,\Pi \epsilon.\,\Pi \omega.\,\Pi d.\,\Pi l.                                                                               \\
             \restrl[n][p][q][\epsilon](\depscohs[n][\lbrack 0,p \rbrack])(\restrl[n+1][p][r][\omega](\overline{\depscohs}(\depscoht[n][\lbrack 0,p-2 \rbrack]))(l)) \\ =_{\cohf[n+1][p][r+1][q+1][\epsilon][\omega](\depscoht[n][\lbrack 0,p-1 \rbrack])(d)} \\
             \restrl[n][p][r][\omega](\depscohs[n][\lbrack 0,p \rbrack])(\restrl[n+1][p][q+1][\epsilon](\overline{\depscohs}(\depscoht[n][\lbrack 0,p-2 \rbrack]))(l))
           \end{array}\right.                                    \\
    \cohl[n][p][q][r][\epsilon][\omega]         &
    \depscoht[n][\lbrack 0,p \rbrack]           & \defeq                              &
    \left\{\begin{array}{l}
             \lambda d. \lambda l. \lambda \theta. \overrightarrow{\coht[n][p][q][r][\epsilon][\omega][\theta](\fulldepscohs[n])(d)}                             \\
             (\ap \overrightarrow{\cohf[n][p][r][0][\omega][\theta](\restrf[n+2][p][q+2][\epsilon](\overline{\depscohs}(\depscoht[n][\lbrack 0,p \rbrack]))(d))} \\ (\ap \overrightarrow{\cohf[n+1][p][q+1][0][\epsilon][\theta](\depscoht[n][\lbrack 0,p-1 \rbrack])(d)} \\(\cohp[n][p][q][r][\epsilon][\omega](l_\theta)))) \\
           \end{array}\right.
  \end{array}
\end{equation*}
where $\cohttype$ is:
\begin{equation*}
  \cohttype[n][p](\depscoht[n][\lbrack 0,p \rbrack]) \defeq
  \left\{
  \begin{array}{l}
    \Pi q \leq n-p.\,\Pi r \leq q.\,\Pi \epsilon.\,\Pi \omega.\,\Pi \theta.\,\Pi d.                                                     \\
    \cohf[n][p][r][0][\omega][\theta](\restrf[n+2][p][q+2][\epsilon](\overline{\depscohs}(\depscoht[n][\lbrack 0,p \rbrack]))(d)) \circ \\
    \ap\restrf[n][p][r][\omega](\cohf[n+1][p][q+1][0][\epsilon][\theta]
    (\depscoht[n][p])(d))
    \circ                                                                                                                               \\
    \cohf[n][p][q][r][\epsilon][\omega](\restrf[n+2][p][0][\theta](\overline{\depscohs}(\depscoht[n][\lbrack 0,p \rbrack]))(d)) =       \\
    \ap\restrf[n][p][0][\theta](\cohf[n+1][p][q+1][r+1][\epsilon][\omega]
    (\depscoht[n][p])(d))
    \circ                                                                                                                               \\
    \cohf[n][p][q][0][\epsilon][\theta](\restrf[n+2][p][r+1][\omega](\overline{\depscohs}(\depscoht[n][\lbrack 0,p \rbrack]))(d))
    \circ                                                                                                                               \\
    \ap\restrf[n][p][q][\epsilon](\cohf[n+1][p][r][0][\omega][\theta]
    (\depscoht[n][p])(d))
  \end{array}
  \right.
\end{equation*}
and where the functoriality of equality and transport was used to go from (omitting the $\framep$ argument):
\begin{equation*}
  \Pi \theta.\left(
  \begin{array}{lcl}
    \begin{array}{l}
      \overrightarrow{\cohf[n][p][q][0][\epsilon][\theta]}
      \overrightarrow{\cohf[n+1][p][r][0][\omega][\theta]} \\
      (\restrp[n][p][q][\epsilon](\restrp[n+1][p][r][\omega](l_\theta)))
    \end{array} & =_{\cohf[n+1][p][q+1][r+1][\epsilon][\omega]} &
    \begin{array}{l}
      \overrightarrow{\cohf[n][p][r][0][\omega][\theta]}\overrightarrow{\cohf[n+1][p][q+1][0][\epsilon][\theta]} \\
      (\restrp[n][p][r][\omega](\restrp[n+1][p][q+1][\epsilon](l_\theta)))
    \end{array}
  \end{array}
  \right)
\end{equation*}
to:
\begin{equation*}
  \Pi \theta.\left(
  \begin{array}{lcl}
    \begin{array}{l}
      \overrightarrow{\cohf[n][p][q][0][\epsilon][\theta]}(\restrp[n][p][q][\epsilon] \\
      (\overrightarrow{\cohf[n+1][p][r][0][\omega][\theta]}(\restrp[n+1][p][r][\omega](l_\theta))))
    \end{array} & =_{\cohf[n+1][p][q+1][r+1][\epsilon][\omega]} &
    \begin{array}{l}
      \overrightarrow{\cohf[n][p][r][0][\omega][\theta]}(\restrp[n][p][r][\omega] \\
      (\overrightarrow{\cohf[n+1][p][q+1][0][\epsilon][\theta]}(\restrp[n+1][p][q+1][\epsilon](l_\theta))))
    \end{array}
  \end{array}
  \right)
\end{equation*}
which is exactly the type of $\cohl[n][p][q][r][\epsilon][\omega]$, up to functional extensionality relative to $\theta$.

It is also convenient to introduce a notion of full dependencies at the level of the coherence conditions of dimension 2, that combines a full $\depscoht[n][\lbrack 0,n \rbrack]$ with a set $E:\framep[n+3][n+3](\overline{\deps}(\overline{\depscohs}(\depscoht[n][\lbrack 0,n \rbrack]))) \rightarrow \U$:
\begin{equation*}
  \fulldepscohttype[n] \defeq
  \left(\begin{array}{lll}
      \depscoht[n][\lbrack 0,n \rbrack] & : & \depscohttype[n][\lbrack 0,n \rbrack]                                                                      \\
      E                                 & : & \framep[n+3][n+3](\overline{\deps}(\overline{\depscohs}(\depscoht[n][\lbrack 0,n \rbrack])))\rightarrow \U \\
    \end{array}\right)
\end{equation*}

We can then extend $\overline{\depscohs}$ to build $\fulldepscohs$ from $\fulldepscoht$:

\begin{equation*}
  \begin{array}{lcl}
    \overline{\fulldepscohs}(\fulldepscoht[n]) & :      & \fulldepscohstype[n+1] \\
    \overline{\fulldepscohs}(\fulldepscoht[n]) & \defeq & \left(
    \begin{array}{l}
        \overline{\depscohs}(\depscoht[n][\lbrack 0,n \rbrack]) \\
        E                                                       \\
      \end{array}\right)                      \\
  \end{array}
\end{equation*}

\subsection{Defining painting coherence laws\label{sec:mkcohp}}

The last key construction we need is $\cohp[n+1][p]$ for $p \leq n+1$, which is by recursion on $n-p$:

\begin{equation*}
  \begin{array}{llcl}
    \cohp[n+1][p]                                &
    \fulldepscoht[n]                             & :      &
    \cohptype[n+1][p](\overline{\fulldepscohs}(\fulldepscoht[n]))                                \\
    \cohp[n+1][n+1][q][r][\epsilon][\omega]      &
    \fulldepscoht[n]
                                                 & \defeq & \lambda d. \lambda (l,c). l_\epsilon \\
    \cohp[n+1][p \leq n][q][r][\epsilon][\omega] &
    \fulldepscoht[n]
                                                 & \defeq & \lambda d. \lambda (l,c).
    \left(\begin{array}{l}
              \cohl[n][p][q][r][\epsilon][\omega](\depscoht[n][\lbrack 0,p-1 \rbrack])(d)(l), \\
              \cohp[n+1][p+1][q][r][\epsilon][\omega](\fulldepscoht[n])(d,l))(c)              \\
            \end{array}\right)        \\
  \end{array}
\end{equation*}
where we again implicitly used that equalities in a $\Sigma$-type are equivalent to a $\Sigma$-type of the underlying equalities, componentwise.

From the latter we can deduce $\cohp[n+1][\lbrack 0,p-1 \rbrack]$ for $p \leq n+2$, again by a second recursion, this time on $p$:

\begin{equation*}
  \begin{array}{llcl}
    \cohp[n+1][\lbrack 0,p-1 \rbrack] &
    \fulldepscoht[n]                  & :      & \cohptype[n+1][\lbrack 0,p-1 \rbrack](\fulldepscohs[n]) \\
    \cohp[n+1]                        &
    \fulldepscohs[n]                  & \defeq & \unittype                                               \\
    \cohp[n+1][\lbrack 0,p \rbrack]   &
    \fulldepscoht[n]
                                      & \defeq &
    (\cohp[n+1][\lbrack 0,p-1 \rbrack](\fulldepscoht[n]),\cohp[n+1][p](\fulldepscoht[n]))                \\
  \end{array}
\end{equation*}

\subsection{Completing the construction by induction}

Armed with all the constructions, we are now able to specify the whole
structure on which we can reason by induction, for $D:\Xto{m}{n}$
given:

\begin{equation*}
  \begin{array}{lcl}
    \framep[n][\lbrack 0,n \rbrack]      & :      & \frametype[n][\lbrack 0,n \rbrack]                                     \\
    \painting[n][\lbrack 0,n \rbrack]    & :      & \paintingtype[n][\lbrack 0,n \rbrack](\framep[n][\lbrack 0,n \rbrack]) \\
    \restrf[n][\lbrack 0,n \rbrack]      & :      & \restrftype[n][\lbrack 0,n \rbrack]
    \left(
    \begin{array}{l}
        \framep[n][\lbrack 0,n \rbrack]   \\
        \painting[n][\lbrack 0,n \rbrack] \\
      \end{array}\right)                                                                                      \\
    \deps[n][\lbrack 0,n \rbrack]        & \defeq &
    \left(
    \begin{array}{l}
        \framep[n][\lbrack 0,n \rbrack]   \\
        \painting[n][\lbrack 0,n \rbrack] \\
        \restrf[n][\lbrack 0,n \rbrack]   \\
      \end{array}\right)                                                                                      \\
    \fulldeps[n](E)                      & \defeq &
    \left(
    \begin{array}{l}
        \deps[n][\lbrack 0,n \rbrack] \\
        E                             \\
      \end{array}\right)                                                                                          \\
    \restrp[n][\lbrack 0,n \rbrack](E)   & :      & \restrptype[n][\lbrack 0,n \rbrack]
    (\fulldeps[n](E))                                                                                                      \\
    \cohf[n][\lbrack 0,n \rbrack](E)     & :      & \cohftype[n][\lbrack 0,n \rbrack]
    \left(
    \begin{array}{l}
        \fulldeps[n](E)                    \\
        \restrp[n][\lbrack 0,n \rbrack](E) \\
      \end{array}\right)                                                                                     \\
    \depscohs[n][\lbrack 0,n \rbrack](E) & \defeq &
    \left(
    \begin{array}{l}
        \fulldeps[n](E)                    \\
        \restrp[n][\lbrack 0,n \rbrack](E) \\
        \cohf[n][\lbrack 0,n \rbrack](E)   \\
      \end{array}\right)                                                                                     \\
    \fulldepscohs[n](E)(E')              & \defeq &
    \left(
    \begin{array}{l}
        \depscohs[n][\lbrack 0,n \rbrack](E) \\
        E'                                   \\
      \end{array}\right)                                                                                   \\
    \cohp[n][\lbrack 0,n \rbrack](E)(E') & :      & \cohptype[n][\lbrack 0,n \rbrack]
    (\fulldepscohs[n](E)(E'))                                                                                              \\
  \end{array}
\end{equation*}
where
\begin{align*}
  E: \framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack])\rightarrow \U \\
  E': \framep[n+2][n+2](\overline{\deps}(\depscohs[n][\lbrack 0,n \rbrack](E)))\rightarrow \U
\end{align*}

Indeed, to build this structure at level $n+1$, from level $n$, it is
enough to assume $E:\framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack]) \rightarrow \U$ (where $\deps[n][\lbrack 0,n \rbrack]$ come from the assumptions at level $n$) and to build the following:
\begin{itemize}
  \item $\framep[n+1][\lbrack 0,n+1 \rbrack]$ comes from $\deps[n][\lbrack 0,n \rbrack]$ (section~\ref{sec:mkframe}).
  \item $\painting[n+1][\lbrack 0,n+1 \rbrack]$ comes from $\fulldeps[n](E)$ (section~\ref{sec:mkpainting}).
  \item $\restrf[n+1][\lbrack 0,n+1 \rbrack]$ comes from $\depscohs[n][\lbrack 0,n \rbrack](E)$ (section~\ref{sec:mkrestrf}).
  \item $\restrp[n+1][\lbrack 0,n+1 \rbrack](E')$, for $E':\framep[n+2][n+2](\overline{\deps}(\depscohs[n][\lbrack 0,n \rbrack])) \rightarrow \U$, comes from $\fulldepscohs[n](E)(E')$ (section~\ref{sec:mkrestrp}).
  \item we define $\depscoht[n][\lbrack 0,n \rbrack](E)(E')$ from $\fulldepscohs[n](E)(E')$ and $\cohp[n][\lbrack 0,n \rbrack](E)(E')$.
  \item $\cohf[n+1][\lbrack 0,n+1 \rbrack](E')$ comes from $\depscoht[n][\lbrack 0,n \rbrack](E)(E')$ (section~\ref{sec:mkcohf}).
  \item we define $\fulldepscoht[n](E)(E')(E'')$, for $E'': \framep[n+3][n+3](\overline{\deps}(\overline{\depscohs}(\depscoht[n][\lbrack 0,n \rbrack]))) \rightarrow \U$, from $\depscoht[n][\lbrack 0,n \rbrack](E)(E')$ and $E''$.
  \item $\cohp[n+1][\lbrack 0,n+1 \rbrack](E')(E'')$ comes from $\fulldepscoht[n](E)(E')(E'')$ (section~\ref{sec:mkcohp}).
\end{itemize}

Therefore, assuming a construction of $\framep[n][n]$ from $D:\Xto{m}{n}$, we are able to build a $\framep[n+1][n+1]$ from $D$ extended with some $E:\framep[n+1][n+1](\deps[n][\lbrack 0,n \rbrack]) \rightarrow \U$. This is enough to build $\Xcomp{m}{n}(D)$, for $D:\Xto{m}{n}$, and thus $\Xp{m}$, by starting with an empty $D$, since, obviously, all fields of the structure are trivially inhabited by $\kstar$ when $n$ is $0$.

\section{Notes on formalization}
The construction we have presented differs from the Rocq formalisation in \href{https://github.com/artagnon/bonak}{bonak} in the following ways:
\begin{itemize}
  \item The main difference between the informal presentation and the Rocq formalisation is that the formalisation is not parameterised by $n$ but instead by $k \defeq n = p$. This is a bit less intuitive since the dimension has to be mentally recomputed by adding $p$ and $k$, but technically, it happens to provide a smoother formalisation, that is, the interesting information when building some component up to $p$ is not, computationally speaking, the dimension but the distance from to the expected dimension.
  \item The second main difference is that structures $\fulldeps$, $\fulldepscohs$ and $\fulldepscoht$ from the informal presentation are implemented by using a ``zipper'' structure~\cite{Huet}: we split $\framep[n][\lbrack 0,n \rbrack]$ at $p$, into two lists: $\framep[n][\lbrack 0,p-1 \rbrack]$ and $\framep[n][\lbrack p,n \rbrack]$, which aids in proofs of induction on $p$.
  \item Otherwise, Rocq does not support mutual fixpoints for which one component depends on another component in its type (also termed as a recursive-recursive definition~\cite{}), nor mutual fixpoints including abbreviations, as we expect in sections~\ref{sec:mkframe}, \ref{sec:mkrestrf}, and \ref{sec:mkcohf}. We address the absence of abbreviations by defining abbreviations in advance and address the absence of recursive-recursive definitions by instead recursively defining a $\Sigma$-type of the components of the recursive-recursive definition, and recovering the individual components using projections.

\end{itemize}

\section{Comparison with previous formalisation}

\section{Perspectives}

\bibliographystyle{plainurl}
\bibliography{paper}

\end{document}
