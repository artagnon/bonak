\documentclass{msc}

\usepackage{amsmath, amssymb, mathrsfs, wasysym, tikz, tikz-cd, lmodern, mathpazo, anyfontsize, xargs, environ, multirow, tabularx, caption, bookmark, booktabs, makecell, colortbl, minted, art.cls/colorpal, art.cls/ct, art.cls/sset, art.cls/lim, art.cls/joinargs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[prefix=bonak]{art.cls/xkeymask}

% Use the patterns library to draw the cubes figure
\usetikzlibrary{patterns}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{painting}{D}{(#1)}
\define@cmdkey[bonak]{painting}{E}{(#1)}
\define@cmdkey[bonak]{painting}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrpainting}{D}{(#1)}
\define@cmdkey[bonak]{restrpainting}{E}{(#1)}
\define@cmdkey[bonak]{restrpainting}{d}{(#1)}
\define@cmdkey[bonak]{restrpainting}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohpainting}{D}{(#1)}
\define@cmdkey[bonak]{cohpainting}{E}{(#1)}
\define@cmdkey[bonak]{cohpainting}{d}{(#1)}
\define@cmdkey[bonak]{cohpainting}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \ensuremath{{\color{carolina}{\nu\textsf{Set}}}_{#1}^{#2}}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and painting: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and painting: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4]}^{\joinargs[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

% Coherence conditions for frame, layer, and painting: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6][#7]}^{\joinargs[#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaHat}{\ensuremath{\hat{\boldsymbol{\Delta}}}}
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}{\ensuremath{\boldsymbol{{\square}}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommandx{\U}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HSet}}_{#1}}}
\newcommandx{\HGpd}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HGpd}}_{#1}}}
\newcommand{\Type}{\ensuremath{\mathsf{\color{spanish-blue}{Type}}}}
\newcommand{\SProp}{\ensuremath{\mathsf{\color{spanish-blue}{SProp}}}}

% Examples
\newtheorem{example}[therm]{Example}

% The unit and bool types
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\booltype}{\ensuremath{\mathsf{bool}}}
\newcommand{\unitpoint}{\ensuremath{\ast}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\refl}{\ensuremath{\mathsf{refl}}}

% Some abbreviations
\newcommand{\tl}{\ensuremath{\mathsf{tl}}}
\newcommand{\hd}{\ensuremath{\mathsf{hd}}}
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\newcommand{\ap}{\mathsf{ap}\;}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommand{\Dom}{\textsf{Dom}}
\newcommand{\UIP}{\textsf{UIP}}

\newcommand{\udensdash}[1]{%
    \tikz[baseline=(todotted.base)]{
        \node[inner sep=1pt,outer sep=0pt] (todotted) {$#1$};
        \draw[densely dashed] (todotted.south west) -- (todotted.south east);
    }%
}%

% These are renewed in tables, but let's define them now for in-document
% typesetting
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\frametype}[2][1,2]{\prim{frametype}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\newcommandx{\paintingtype}[2][1,2]{\prim{paintingtype}[][#1][#2][][]}
\newcommandx{\restrftype}[2][1,2]{\prim{restrftype}[][#1][#2][][]}
\newcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\newcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\newcommandx{\restrp}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\newcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\newcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\newcommandx{\cohc}{\coh{painting}[][][][][][][][]}
\newcommandx{\coht}{\cohtwo{frame}[][][][][][][][]}
\newcommandx{\fullframe}[1][1]{\prim{fullframe}[][#1][][][]}

% For typesetting type theory rules
\newcommand \seqr[3]
  {\shortstack{$#2$ \\ \mbox{}\\
                   \mbox{}\hrulefill\mbox{}\\ \mbox{}\\ $#3$} \raisebox{2ex}{$\;\;\mbox{$#1$}$}}

% Kerning for star
\newcommand{\kstar}{{\star}}

% Caption setup
\DeclareCaptionFormat{plain}{#1#3}
\captionsetup{font=footnotesize,labelfont=bf}

% The eqntable environment
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{eqntable}[1]{
  \fontsize{7.2}{9}\selectfont
  \begin{tabularx}{0.94\linewidth}{
    @{}
    >{$}l<{$}
    >{$}c<{$}
    >{$}c<{$}
    >{$}Y<{$}
    @{}}
    \toprule
    \BODY
    \bottomrule
  \end{tabularx}
  \captionof{table}{#1}
}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

% Double-spacing
% \linespread{2}

\begin{document}
\title{On the specific recursive structure of iterated parametricity}
\begin{authgrp}
  \author{Hugo Herbelin}
  \affiliation{Université Paris Cité, Inria, CNRS, IRIF, Paris
    \email{Hugo.Herbelin@inria.fr}}
  \author{Ramkumar Ramachandra}
  \affiliation{Unaffiliated \email{r@artagnon.com}}
\end{authgrp}
\begin{abstract}
  In a previous paper, we gave equations describing the construction of semi-simplicial and semi-cubical sets via iterated parametricity. The construction was formalised in the Rocq (formerly known as Coq) proof assistant building $n$-truncated sets using an induction on a large structure embedding equational reasoning.

  The current paper describes a new and lighter presentation of the construction where equational reasoning is replaced by definition. Being lighter, it can now be described in full details, closely following the corresponding new machine-checked formalisation.
\end{abstract}
\maketitle
\vspace{-2em} % Remove space after abstract

\section{Introduction}
A family of sets can commonly be represented in two ways: as a family properly speaking, indexed by the elements of a given set $S$, or as a set $T$ together with a map from $T$ to $S$, which specifies for each element of $T$ its dependency on $S$. In the former case, we call it an \emph{indexed} presentation. In the latter case, the set associated to a given element of $S$ is the fibre of this element, so we call it a \emph{fibred} presentation. The two presentations are equivalent and the equivalence can be phrased concisely in the language of homotopy type theory~\citep{hottbook} as the fibred/indexed equivalence\footnote{In an informal discussion, alternative nomenclatures were proposed: fibration/family equivalence and unbundled/bundled equivalence. The fibred/indexed nomenclature echoes the Grothendieck construction of fibred categories from indexed categories. The most elementary instance of the equivalence, with $\Type$ instead of $\U$, is sometimes called ``Grothendieck construction for dummies'', and its proof requires univalence~\citep{hottbook}.}.
\begin{equation*}
  \mbox{(fibred)}\qquad(\Sigma T: \U. (T \rightarrow S)) ~\simeq~ (S \rightarrow \U)\qquad \mbox{(indexed)}
\end{equation*}
Here, $\U$ represents in homotopy type theory the subset of types within a given universe where equality of any two elements has at most one proof.

A \emph{presheaf} on an category is a family of sets indexed by the object of the category with maps indexed by the morphisms. As such, it lives on the indexed side of the equivalence, contrasting with the fibred side, where we have \emph{discrete Grothendieck fibrations}~\citep{LoregianRiehl20}. However, there are situations where a presheaf can also be seen as living on the fibred side of the equivalence. This happens when the indexing category is \emph{direct}, or has a downwards-well-founded collection of non-identity morphisms. Let us consider, for instance, the case of a semi-cubical set~\citep{grandis03,buchholtz17} presented with $2n$ face maps from the set of $n$-cubes to the set of $(n-1)$-cubes. Formulated in type theory, the corresponding presheaf definition of a semi-cubical set prescribes a family of sets and face maps between them as follows.

\begin{equation*}
  \begin{tikzcd}
    X_0: \U & X_1: \U \arrow[l, "\partial^L" description, shift left=2] \arrow[l, "\partial^R" description, shift right=2] & X_2: \U \arrow[l, "\partial^{L\kstar}" description, shift left=6] \arrow[l, "\partial^{R\kstar}" description, shift left=2] \arrow[l, "\partial^{\kstar L}" description, shift right=2] \arrow[l, "\partial^{\kstar R}" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}
up to cubical faces identities. Here, $X_1$ can be seen as a family over $X_0 \times X_0$, and $X_2$ can be seen as a family over $X_1 \times X_1 \times X_1 \times X_1$, in the fibred presentation, together with coherence conditions between the $X_1$ seen as families over $X_0 \times X_0$. This suggests an alternative indexed presentation of the presheaf as a stratified sequence of families indexed by families of lower rank, taking into account those coherence conditions to prevent duplications. Formulated in type theory, it takes the form:
\begin{equation*}
  \begin{array}{lll}
    X_0 & :               \U                                                                          \\
    X_1 & :               X_0 \times X_0 \rightarrow  \U                                              \\
    X_2 & : \Pi a b c d.\,  X_1(a,b) \times X_1 (c,d) \times X_1(a,c) \times X_1 (b,d) \rightarrow \U \\
    \ldots
  \end{array}
\end{equation*}

The idea for such an indexed presentation of presheaves over a direct category was mentioned at the Univalent Foundations year in the context of defining semi-simplicial types\footnote{\href{https://ncatlab.org/nlab/show/semi-simplicial+types+in+homotopy+type+theory}{ncatlab.org/nlab/show/semi-simplicial+types+in+homotopy+type+theory}}. A few constructions have been proposed since then. The first construction by \cite{voevodsky12} relies on the presentation of semi-simplicial sets as a presheaf over increasing injective maps between finite ordinals. The second, by \cite{herbelin15}\footnote{In hindsight, the title of the paper ``A dependently-typed construction of semi-simplicial types'' is somewhat confusing: it implicitly claimed to construct semi-simplicial types, but the construction was done in a type theory with Uniqueness of Identity Proofs. Consequently, what was really obtained was an indexed presentation of semi-simplicial sets. The confusion was however, common at the time.} formalized in the Coq proof assistant, relies on the presentation of semi-simplicial sets as a presheaf over face maps. Another by \cite{part15} formalized in an emulation of logic-enriched homotopy type theory in the Plastic proof assistant, and yet another by \cite{altenkirch16} formalized in an emulation of a two-level type theory in the Agda proof assistant\footnote{\href{https://github.com/nicolaikraus/HoTT-Agda/blob/master/nicolai/SemiSimp/SStypes.agda}{github.com/nicolaikraus/HoTT-Agda/blob/master/nicolai/SemiSimp/SStypes.agda}}, rely, like in Voevodsky, on the presentation of the semi-simplicial category from increasing injective maps between finite ordinals. The latter constructions, besides being stated as providing semi-simplicial types (thanks to an extension of the type theory), are particularly concise, taking advantage of a definition of increasing injective maps between finite ordinals as type-theoretic functions to inherit the associativity of composition directly from it holding in type theory. This contrasts with the combinatorial construction in \cite{herbelin15} where equations over face maps have to be proved by induction.

By taking the sum of each component of an indexed presentation over the indexing set of this component, one obtains back a presheaf in the ordinary sense that has a property of \emph{Reedy fibrancy}, that is whose morphisms are projections in the set-theoretic sense. Such Reedy fibrant presheaves over a direct category have been studied in e.g. \cite{shulman15}, \cite{kraus17} and \cite{annenkovCK17,AnnenkovCKS2023}, presenting generic constructions over such presheaves.

The indexed definition of a presheaf over a direct category is technically more involved than the presheaf definition, as it requires hard-wiring in the structure the dependencies between elements of the sets of the presheaf, including the coherence conditions between these dependencies, such as taking the $i$-th face of the $j$-th face of a $n$-simplex being the same as taking the $(j-1)$-th face of the $i$-th face (when $j>i$). However, exhibiting a concrete instance of a presheaf in indexed form only requires providing the families, since the responsibility of defining maps and showing the coherence conditions is already accounted for in the definition of the structure.

\section{Reminder of our construction}
% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{painting}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrpainting}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohpainting}[D, d]

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and painting
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and painting
% Drop the universe letter
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrp}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
% Keep only ε, ω; n, p; proposition on n and p
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][][][][][#9]}

A $\nu$-set in indexed form is a sequence of families of $\U$, that is $\U[m]$ for some universe level $m$. We call such sequence a $\nu$-set at level $m$, whose type thus lives in $\U[m+1]$.

Table~\ref{tab:coind} describes the type of a $\nu$-set at level $m$ as a dependent stream of type families representing the limit of $n$-truncated $\nu$-sets: using the notations of Section~\ref{sec:tt}, the recursive equation $\Xfrom{m}{n}{D} \,\defeq\, \Sigma R: \Xcomp{m}{n}[D=\D].\, \Xfrom{m}{n+1}[D=\pair{D}{R}]$ from the table formally corresponds to the stream $Stream_{\Sigma n.\, \Xto{m}{n},\, \lambda (n, \D).\, \Xcomp{m}{n}[D=\D],\,\lambda ((n, D),R).(n+1,(\pair{D}{R}))}(n, \D)$. Therefore, $\Xfrom{m}{n}$ denotes an infinite sequence $X_{n}, X_{n+1}, \ldots$ dependent on a $(<n)$-truncated $\nu$-set, $\Xto{m}{n}$, so that, when $n$ is $0$, it denotes a full $\nu$-set, written $\Xp{m}$. This is made possible because the $(<0)$-truncated $\nu$-set, $\Xto{m}{0}$, is degenerated: it is an empty family, and there is thus only one $(<0)$-truncated $\nu$-set, namely the canonical inhabitant $\kstar$ of $\unittype$.

The definition of the type of a $n$-truncated $\nu$-set is in turn described in table~\ref{tab:core}. In the infinite sequence of type families representing a $\nu$-set, the $n$-th component is a type dependent over a $\fullframe$. It is recursively defined in table~\ref{tab:frames}, using the auxiliary definitions of $\framep$, $\layer$ and $\painting$. A $\fullframe$ describes a boundary of a standard form (simplex, cube), which we decompose into $\layer$, and a $\painting$ corresponds to a filled frame. Notice that the type $\layer$ relies on an operator of frame restriction $\restrf$ which is defined in table~\ref{tab:faces}, and this restriction operator is in turn defined using auxiliary definitions $\restrl$ and $\restrp$.

Notably, the definition of $\restrl$ relies on an equality expressing the commutation of the composition of two $\restrf$. The proof of this commutation is worth being made explicit, which we do in table~\ref{tab:coh} using proof-term notations. The proof requires an induction on the dimension and on the structure of $\framep$, $\layer$, and $\painting$. This is what $\cohf$ does using auxiliary proofs $\cohl$ and $\cohc$. Even though it looks independent of the definitions from the other tables, $\cohf$ has to be proved mutually with the definitions of $\framep$, $\layer$, $\painting$, and their corresponding restrictions. More precisely, for a fixed $n$, the block of $\framep$, $\restrf$, and $\cohf$ has to be defined in one go by induction on $p$. Also, each of $\painting$, $\restrp$, and $\cohc$ is built by induction from $p$ to $n$. The $\painting$ block at $n$ relies on the $\framep$ block at $n$, but the converse dependency is only on lower $n$, so this is well-founded. Note that $\layer$, $\restrl$ and $\cohl$ are just abbreviations. The exact way this mutual recursion is eventually formalized is explained in section~\ref{sec:wf}.

Note that for a fixed constant $n$, relying on the evaluation rules of type theory, the coherence conditions degenerate to a reflexivity proof, so that the construction builds an effective sequence of types not mentioning coherences anymore. \\

\def\lab{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

\def\lab{tab:core}
\input{tab-core.tex}

% Drop the universe letter in fullframe for all remaining tables
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[][#2][][][#3]}
\def\lab{tab:frames}
\input{tab-frames.tex}

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\def\lab{tab:faces}
\input{tab-faces-ett.tex}

% Restriction for frame, layer, and painting
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrp}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[][#2][#3][#4][#5][#6][#7,#8][#9]}

\def\lab{tab:coh}
\input{tab-coh-ett.tex}

\renewcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\renewcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\renewcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\renewcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrp}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}

\section{The recursive structure of iterated parametricity}
Iterated parametricity (in indexed form) produces a family of type
families of the following form:
\begin{equation*}
  \begin{array}{llr}
    X_0 & :              & \U                                                                        \\
    X_1 & :              & X_0 \times X_0 \rightarrow  \U                                            \\
    X_2 & : \Pi a b c d. & X_1(a,b) \times X_1 (c,d) \times X_1(a,c) \times X_1 (b,d) \rightarrow \U \\
    \ldots
  \end{array}
\end{equation*}

Such family can be recursively described by the equations given on Table ?.

The well-foundedness of the construction can be justified by the observation that:
\begin{itemize}
  \item Defining $\framep[n][p]$ for $p \leq n$ requires the definition
        of $\painting[n-1][p-1]$, thus also $\framep[n-1][p-1]$ by typing
        dependency, as well as $\restrf[n][p-1]$, where
        $\restrf[n][p-1]$ in turn depends in $\framep[n][p-1]$ for its
        typing.

        Moreover, $\framep[n][p]$ depends on $\framep[n][p-1]$, so these
        dependencies are between the blocks of $\framep[n][k]$ for all
        $k\leq p$, as well as $\framep[n-1][k]$, $\painting[n-1][k]$ and
        $\restrf[n][k]$ for all $k\leq p-1$, which we respectively
        abbreviate as $\framep[n][0,...,p]$,
        $\framep[n-1][0,...,p-1]$, $\painting[n-1][0,...,p-1]$ and
        $\restrf[n][0,...,p-1]$.

        Also, $\restrf[n][p-1]$ depends on $n$.

        Schematically, using dotted arrows for dependencies in
        the type and plain arrows for dependencies in the definition, this
        gives the following dependencies for $p\leq n$ fixed:
        \begin{center}
          \fontsize{7.2}{9}\selectfont
          \begin{tikzcd}
            \framep[n][0,...,p] \arrow[d] \arrow[ddr]\\
            \painting[n-1][0,...,p-1] \arrow[d, dotted] \\
            \framep[n-1][0,...,p-1] &
            \restrf[n][0,...,p-1] \arrow[l, dotted] \arrow[uul, dotted, "\mbox{$[0,...,p-1]$}"', near start, shift right=2mm, hook']\\
          \end{tikzcd}
        \end{center}

        In particular, the mutual dependency on one side of
        $\framep[n][0,...,p-1]$ within the type of
        $\restrf[n][0,...,p-1]$ and on the other side of
        $\restrf[n][0,...,p-1]$ within the definition of
        $\framep[n][0,...,p]$ requires to mutually define the type of
        $\restrf[n][0,...,p-1]$ together with $\framep[n][p]$ (or
        $\framep[n][0,...,p]$) as a function from
        $\restrf[n][0,...,p-1]$.

        To talk about sequences of $\framep$, $\painting$ or $\restrf$,
        we need to specify their types. The type of $\restrf$ will be
        defined mutually with $\framep$ of the same level, but the type of
        $\framep$, $\painting$ can be defined in advance, the second one
        being however dependent on the first one. In general, components of
        such sequences will have a type dependent on the previous components
        of the sequence, as it is the case for $\restrf$. So, the type of
        a sequence of length $p$ will be expressed as a $n$-iterated
        $\Sigma$-type. In the case of $\framep$ and $\painting$, there will
        be however no dependency, so an ordinary product can be used. If
        $\framep[n][0,...,p]$ is such a sequence of length $p+1$, we write
        $\framep[n][0,...,p-1]$ for its immediate subsequence of length $p$
        and $\framep[n][p]$ for its last component. We can now define the
        types of sequences of $\framep$ and $\painting$ as follows:

        $$
          \fontsize{7.2}{9}\selectfont
          \begin{array}{llcl}
            \frametype[n][0,...,p]    &                                              & :      & Type_{l+1}                                                                                   \\
            \frametype[n][]           &                                              & \defeq & unit                                                                                         \\
            \frametype[n][0,...,p]    &                                              & \defeq & \frametype[n][0,...,p-1] \times Type_l                                                       \\
            \\
            \paintingtype[n][0,...,p] & (\framep[n][0,...,p]:\frametype[n][0,...,p]) & :      & Type_{l+1}                                                                                   \\
            \paintingtype[n][]        & \star                                        & \defeq & unit                                                                                         \\
            \paintingtype[n][0,...,p] & (\framep[n][0,...,p])                        & \defeq & \paintingtype[n][0,...,p-1](\framep[n][0,...,p-1]) \times (\framep[n][p] \rightarrow Type_l) \\
          \end{array}
        $$

        Formally, this can be described as:
        $$
          \fontsize{7.2}{9}\selectfont
          \begin{array}{llcl}
            \framep[n][0,...,p]        &
            \multicolumn{3}{l}{
              \left(\begin{array}{l}
                        \framep[n-1][0,...,p-1]:\frametype[n-1][0,...,p-1]                               \\
                        \painting[n-1][0,...,p-1]:\paintingtype[n-1][0,...,p-1](\framep[n-1][0,...,p-1]) \\
                        \restrf[n][0,...,p-1]:\restrftype[n][0,...,p-1]
                        \left(\begin{array}{l}
                            \framep[n-1][0,...,p-1]   \\
                            \painting[n-1][0,...,p-1] \\
                          \end{array}\right)                                                  \\
                      \end{array}\right) : \frametype[n-1][0,...,p]
            }                                                                         \\
            \framep[n][0]              &
            \left(\begin{array}{l}
                      \star \\
                      \star \\
                      \star \\
                    \end{array}\right)     & \defeq & (\star,unit)                      \\
            \framep[n][0,...,p+1]      &
            \left(\begin{array}{l}
                      \framep[n-1][0,...,p]   \\
                      \painting[n-1][0,...,p] \\
                      \restrf[n][0,...,p]     \\
                    \end{array}\right) & \defeq &
            \left(\begin{array}{l}
                      \framep[n][0,...,p]
                      \left(\begin{array}{l}
                          \framep[n-1][0,...,p-1]   \\
                          \painting[n-1][0,...,p-1] \\
                          \restrf[n][0,...,p-1]     \\
                        \end{array}\right)     ,                       \\
                      \Sigma d:\framep[n][0,...,p]
                      \left(\begin{array}{l}
                          \framep[n-1][0,...,p-1]   \\
                          \painting[n-1][0,...,p-1] \\
                          \restrf[n][0,...,p-1]     \\
                        \end{array}\right).\,                       \\
                      \quad \Pi\omega.\,\painting[n-1][p](\restrf[n][p](d)) \\
                    \end{array}\right) \\
            \restrftype[n][0,...,p-1]  &
            \multicolumn{3}{l}{
              \left(\begin{array}{l}
                        \framep[n-1][0,...,p-1]:\frametype[n-1][0,...,p-1]                               \\
                        \painting[n-1][0,...,p-1]:\paintingtype[n-1][0,...,p-1](\framep[n-1][0,...,p-1]) \\
                      \end{array}\right) : Type_{l}
            }                                                                         \\
            \restrftype[n][]           &
            \left(\begin{array}{l}
                      \star \\
                      \star \\
                    \end{array}\right)     & \defeq &
            unit                                                                      \\
            \restrftype[n][0,...,p]    &
            \left(\begin{array}{l}
                      \framep[n-1][0,...,p]   \\
                      \painting[n-1][0,...,p] \\
                    \end{array}\right) & \defeq &
            \begin{array}{l}
              \Sigma \restrf[n][0,...,p-1]    \\
              \quad:\restrftype[n][0,...,p-1]
              \left(\begin{array}{l}
                        \framep[n-1][0,...,p-1]   \\
                        \painting[n-1][0,...,p-1] \\
                      \end{array}\right)
              .\,                             \\
              \Pi q\leq n.\,\Pi \omega.\,\framep[n][0,...,p]
              \left(\begin{array}{l}
                        \framep[n-1][0,...,p-1]   \\
                        \painting[n-1][0,...,p-1] \\
                        \restrf[n][0,...,p-1]     \\
                      \end{array}\right) \\
            \end{array}                             \\
          \end{array}
        $$
  \item Defining $\painting[n][p]$, in addition to the type dependency
        in $\framep[n][p]$, requires the definition of
        $\painting[n-1][p-1]$, thus also $\framep[n-1][p-1]$ by typing
        dependency, as well as $\restrf[n][p-1]$. Since
        $\painting[n][p]$ also depends on $\painting[n][p+1]$ when $p<n$,
        these dependencies are actually between $\painting[n][p,...,n]$,
        $\painting[n-1][p,...,n-1]$, $\framep[n][p,...,n]$,
        $\framep[n-1][p,...,n-1]$ and $\restrf[n][p,...,n]$. Also,
        for the case $p=n$, this also requires the assumption of an
        inhabitant $X_{n}$ of $\nu$Set$^{=n}$. Finally,
        $\framep[n][p,...,n]$, $\framep[n-1][p,...,n-1]$ and
        $\restrf[n][p,...,n-1]$ respectively depend on the earlier
        values $\framep[n][0,...,p-1]$, $\framep[n-1][0,...,p-1]$ and
        $\restrf[n][0,...,p-1]$.  Below, we use dashed underline and
        dashed arrows for dependencies in subconstructions, here in the
        construction of $\framep$ at level $n-1$ and $\restrftype$ at
        level $n$:
        \begin{center}
          \fontsize{7.2}{9}\selectfont
          \begin{tikzcd}
            & & \painting[n][p,...,n] \arrow[dd, bend right=70] \arrow[dddr] \arrow[d, dotted]\\
            \udensdash{\framep}^{n,[0,...,p-1]} \arrow[d, dashed] \arrow[ddr, dashed] & &
            \udensdash{\framep}^{n,[p,...,n]} \arrow[ll, dotted] \arrow[d, dashed] \arrow[ddr, dashed, shift right=2mm] \\
            \painting[n-1][0,...,p-1] \arrow[d, dotted] & &
            \painting[n-1][p,...,n-1] \arrow[ll, dotted] \arrow[d, dotted] \\
            \framep[n-1][0,...,p-1] &
            \udensdash{\restrf}^{n,[0,...,p-1]} \arrow[l, dotted] \arrow[uul, dotted, shift right=2mm, hook'] &
            \framep[n-1][p,...,n-1] \arrow[ll, dotted, bend left=15] &
            \udensdash{\restrf}^{n,[p,...,n-1]},X_n \arrow[ll, dotted, bend left=15] \arrow[l, dotted] \arrow[uul, dotted, hook']\\
          \end{tikzcd}
        \end{center}

        To define $\painting$ formally, we need to define $\framep[n][p,...,n]$, $\painting[n][p,...,n]$ and $\restrf[n][p,...,n]$:

        $$
          \fontsize{7.2}{9}\selectfont
          \begin{array}{llcl}
            \frametype[n][p,...,n]         &                                              & :      & Type_{l+1}                                                                                   \\
            \frametype[n][]                &                                              & \defeq & unit                                                                                         \\
            \frametype[n][p,...,n]         &                                              & \defeq & Type_l \times \frametype[n][p+1,...,n-1]                                                     \\
            \\
            \paintingtype[n][p,...,n]      & (\framep[n][p,...,n]:\frametype[n][p,...,n]) & :      & Type_{l+1}                                                                                   \\
            \paintingtype[n][]             & \star                                        & \defeq & unit                                                                                         \\
            \paintingtype[n][p,...,n](p<n) & (\framep[n][p,...,n])                        & \defeq & (\framep[n][p] \rightarrow Type_l) \times \paintingtype[n][p+1,...,n](\framep[n][p+1,...,n]) \\
            \\
            \restrftype[n][p,...,n]        &
            \multicolumn{3}{l}{
              \left(\begin{array}{l}
                        \framep[n-1][0,...,p-1]:\frametype[n-1][0,...,p-1]                               \\
                        \painting[n-1][0,...,p-1]:\paintingtype[n-1][0,...,p-1](\framep[n-1][0,...,p-1]) \\
                        \framep[n-1][p,...,n-1]:\frametype[n-1][p,...,n-1]                               \\
                        \painting[n-1][p,...,n-1]:\paintingtype[n-1][p,...,n-1](\framep[n-1][p,...,n-1]) \\
                        \restrf[n][0,...,p-1]:\restrftype[n][0,...,p-1]
                        \left(\begin{array}{l}
                            \framep[n-1][0,...,p-1]   \\
                            \painting[n-1][0,...,p-1] \\
                          \end{array}\right)                                                  \\
                      \end{array}\right) : Type_{l}
            }                                                                                                                                                                                     \\
            \restrftype[n][]               &
            \left(\begin{array}{l}
                      \framep[n-1][0,...,n-1]   \\
                      \painting[n-1][0,...,n-1] \\
                      \star                     \\
                      \star                     \\
                      \restrp[n][0,...,n-1]     \\
                    \end{array}\right)   & \defeq                                       & unit                                                                                                      \\
            \restrftype[n][p,...,n-1]      &
            \left(\begin{array}{l}
                      \framep[n-1][0,...,p-1]   \\
                      \painting[n-1][0,...,p-1] \\
                      \framep[n-1][p,...,n-1]   \\
                      \painting[n-1][p,...,n-1] \\
                      \restrf[n][0,...,p-1]     \\
                    \end{array}\right)
                                           & \defeq                                       &
            \begin{array}{l}
              \framep[n][p]
              \left(\begin{array}{l}
                        \framep[n-1][0,...,p-1]   \\
                        \painting[n-1][0,...,p-1] \\
                        \restrf[n][0,...,p-1]     \\
                      \end{array}\right)
              \rightarrow \framep[n-1][p] \\
              \times                      \\
              \restrftype[n][p+1,...,n]
              \left(\begin{array}{l}
                        \framep[n-1][0,...,p]       \\
                        \painting[n-1][0,...,p]     \\
                        \framep[n-1][p+1,...,n-1]   \\
                        \painting[n-1][p+1,...,n-1] \\
                        \restrf[n][0,...,p]         \\
                      \end{array}\right)
            \end{array}
          \end{array}
        $$


        This allows to define $\painting[n][p]$ formally:
        $$
          \fontsize{7.2}{9}\selectfont
          \begin{array}{llcl}
            \painting[n][p]              &
            \multicolumn{3}{l}{
              \left(\begin{array}{l}
                        \framep[n-1][0,...,p-1]:\frametype[n-1][0,...,p-1]                               \\
                        \painting[n-1][0,...,p-1]:\paintingtype[n-1][0,...,p-1](\framep[n-1][0,...,p-1]) \\
                        \framep[n-1][p,...,n-1]:\frametype[n-1][p,...,n-1]                               \\
                        \painting[n-1][p,...,n-1]:\paintingtype[n-1][p,...,n-1](\framep[n-1][p,...,n-1]) \\
                        \restrf[n][0,...,p-1]:\restrftype[n][0,...,p-1]
                        \left(\begin{array}{l}
                            \framep[n-1][0,...,p-1]   \\
                            \painting[n-1][0,...,p-1] \\
                          \end{array}\right)                                                  \\
                        \restrf[n][p,...,n-1]:\restrftype[n][p,...,n-1]
                        \left(\begin{array}{l}
                            \framep[n-1][0,...,p-1]   \\
                            \painting[n-1][0,...,p-1] \\
                            \framep[n-1][p,...,n-2]   \\
                            \painting[n-1][p,...,n-2] \\
                            \restrf[n][0,...,p-1]     \\
                          \end{array}\right)                                                  \\
                        E:\framep[n-1][n-1]\rightarrow Type_l                                            \\
                      \end{array}\right) : \framep[n-1][n-1]\rightarrow Type_l
            }                                                            \\
            \painting[n][n]              &
            \left(\begin{array}{l}
                      \framep[n-1][0,...,n-1]   \\
                      \painting[n-1][0,...,n-1] \\
                      \star                     \\
                      \star                     \\
                      \restrp[n][0,...,n-1]     \\
                      \star                     \\
                      E                         \\
                    \end{array}\right) & \defeq & E                        \\
            \painting[n][p](p<n)         &
            \left(\begin{array}{l}
                      \framep[n-1][0,...,p-1]   \\
                      \painting[n-1][0,...,p-1] \\
                      \framep[n-1][p,...,n-1]   \\
                      \painting[n-1][p,...,n-1] \\
                      \restrf[n][0,...,p-1]     \\
                      \restrf[n][p,...,n-1]     \\
                      E                         \\
                    \end{array}\right) & \defeq & d \mapsto
            \left(\begin{array}{l}
                      \Sigma l:(\Pi q\leq n.\,\Pi \omega.\
                      \painting[n-1][0,...,p](\restrf[n][p](d))). \\
                      \painting[n][p+1,...,n-1]
                      \left(\begin{array}{l}
                          \framep[n-1][0,...,p]       \\
                          \painting[n-1][0,...,p]     \\
                          \framep[n-1][p+1,...,n-1]   \\
                          \painting[n-1][p+1,...,n-1] \\
                          \restrf[n][0,...,p]         \\
                          \restrf[n][p+1,...,n-1]     \\
                          E                           \\
                        \end{array}\right)(d,l)           \\
                    \end{array}\right) \\
          \end{array}
        $$

        From which we can deduce $\painting[n][0,...,p]$ by recursion on $p$.

\end{itemize}


\newpage
\bibliographystyle{msclike}
\bibliography{paper}

\end{document}
