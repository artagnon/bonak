\documentclass[10pt]{art.cls/art}

\usepackage{multirow, float, tabularx, environ, booktabs, setspace, makecell, caption, art.cls/joinargs, colortbl, pdflscape}
\usepackage[prefix=bonak]{art.cls/xkeymask}
\usepackage[skip=0.4em]{parskip}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{filler}{D}{(#1)}
\define@cmdkey[bonak]{filler}{E}{(#1)}
\define@cmdkey[bonak]{filler}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrfiller}{D}{(#1)}
\define@cmdkey[bonak]{restrfiller}{E}{(#1)}
\define@cmdkey[bonak]{restrfiller}{d}{(#1)}
\define@cmdkey[bonak]{restrfiller}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohfiller}{D}{(#1)}
\define@cmdkey[bonak]{cohfiller}{E}{(#1)}
\define@cmdkey[bonak]{cohfiller}{d}{(#1)}
\define@cmdkey[bonak]{cohfiller}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \ensuremath{\mathsf{\color{carolina}{X}}_{#1}^{#2}}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and filler: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs{}[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and filler: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4]}^{\joinargs{}[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

% Coherence conditions for frame, layer, and filler: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4][#5][#6]}^{\joinargs{}[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4][#5][#6][#7]}^{\joinargs{}[#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}{\ensuremath{\boldsymbol{\square}}}
\renewcommand{\I}[1]{\ensuremath{\mathsf{I}^{#1}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommand{\U}[1]{\ensuremath{\mathsf{\color{spanish-blue}{HSet}}_{#1}}}

% The unit type
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\unitpoint}{\ensuremath{\star}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\eqHSet}{\ensuremath{\equiv_{\mathit{HSet}}}}
\newcommand{\reflHSet}{\ensuremath{\mathsf{refl}_{\mathit{HSet}}}}

% Some abbreviations
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\newcommand{\ap}{\mathsf{ap}}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\filler}[2][1,2]{\prim{filler}[][#1][#2][][]}
\newcommandx{\restrf}[1][1]{\restr{frame}[][#1][][][][][]}

% Kerning for star
\newcommand{\kstar}{{\star}}

% The eqntable environment, displaying the various
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{eqntable}[1]{
  \begin{table}[H]
    \small
    \begin{tabularx}{\linewidth}{@{}>{$}l<{$} >{$}c<{$} >{$}c<{$} >{$}Y<{$} @{}}
      \toprule
      \BODY
      \bottomrule
    \end{tabularx}
    \caption{#1}
  \end{table}
}

% The label, since we're including twice
\newcommand*{\lab}{}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

% Table caption set up
\DeclareCaptionFormat{hfillunittypet}{\hfill#1#2#3\par}
\DeclareCaptionFont{mdit}{\mdseries\itshape}
\captionsetup[table]{
  justification=centering,
  font=bf,
  labelfont=mdit,
}

\title{A mechanization of semi-simplicial and semi-cubical sets in the calculus of inductive constructions}
\author{
  \textcolor{gray80}{Ramkumar Ramachandra} \\
  \itshape \textcolor{gray80}{Université Paris-Cité}
  \and
  \textcolor{gray80}{Hugo Herbelin} \\
  \itshape \textcolor{gray80}{IRIF/Inria Paris/Université Paris-Cité}
}
\date{}

\color{gray65}

\begin{document}
\thispagestyle{empty}
\maketitle
\begin{abstract}
  We present a parametricity-based construction of semi-simplicial sets and semi-cubical sets in indexed form, in the calculus of inductive constructions. The accompanying artifact is an axiom-less~\footnote{Technically speaking, we use some axioms related to functional extensionality, but the requirement arises only from our generalization to $\nu$-types; if $\nu$ is finite (say, unit type corresponding to augmented semi-simplicial types), this requirement vanishes.} Coq formalization that uses sophisticated rewriting techniques and pushes the boundaries of proof assistant technology.
\end{abstract}
\tableofcontents
\newpage

\section{Overture}

In the context of typed functional programming, Reynolds' parametricity~\cite{reynolds72} interprets types as relations characterizing the observational equality of programs of this type. Parametricity can be iterated, and it has been noted that iterated Reynolds' parametricity has a cubical flavor~\cite{johann17,altenkirch14,moulin16}. We obtain a \emph{unary} variant of Reynolds' \emph{binary} parametricity by using predicates instead of relations, in which case we obtain a form of (Kreisel) realizability~\cite{bernardy12,moulin16}. It has then been noted that iterated unary parametricity has an augmented simplicial flavor~\footnote{Observation from Hugo Moeneclaey}.

We exploit the connection between iterated unary parametricity and augmented simplicial sets, and between iterated binary parametricity and cubical sets to present a uniform construction of both semi-simplicial semi-cubical sets obtained by applying simple rules iterating parametricity.  In contrast to the presheaf presentation of semi-simplicial and semi-cubical sets, our uniform construction, which we call \emph{$\nu$-sets}, is \emph{indexed}. That is, instead of having the set of semi-simplices or semi-cubes in dimension $n+1$
\emph{fibered} over the set of semi-simplices or semi-cubes in dimension $n$, we consider families of semi-simplices and semi-cubes indexed over their faces.

\begin{table}[H]
  \begin{tabularx}{\linewidth}{p{.3\linewidth}|p{.3\linewidth}|p{.3\linewidth}}
    \toprule
            & Set theory  & Type theory \\
    \graymidrule
    Fibered & \cite{cchm} &             \\
    \graymidrule
    Indexed &             & Our work    \\
    \bottomrule
  \end{tabularx}
\end{table}

The outline of the paper is as follows. First, we briefly describe semi-simplicial and semi-cubical sets, as it appears in mathematical literature, and our generalization to $\nu$-sets. We then proceed to explain our construction, with the help of diagrams. Before spelling out the details of our formalization in type-theoretic language, we have a section on reasoning in sets.

\section{Mathematical treatment of \texorpdfstring{$\nu$}{𝜈}-sets}
It is well-known that simplicial sets exist purely in the imagination of the mathematician, as every simplicial set has an infinite number of degenerate simplices. What we have formalized is \emph{semi-simplicial} sets, and \emph{semi-cubical} sets, which is to say that they are the usual simplicial sets and cubical sets, minus the degeneracies. Indeed, we plan to extend our work to do degeneracies in the future, but let us briefly explain the mathematical objects we have formalized.

\begin{table}[H]
  \begin{tabularx}{\linewidth}{p{.2\linewidth}|p{.4\linewidth}|p{.3\linewidth}}
    \toprule
    Value of $\nu$ & 1                               & 2                  \\
    \graymidrule
    Interpretation & Augmented semi-simplicial types & Semi-cubical types \\
    \bottomrule
  \end{tabularx}
\end{table}

\subsection{Augmented semi-simplicial sets}
We consider the category of augmented semi-simplices, which can be written in different ways, up to equivalence. Here, we describe the combinatorial definition.

\begin{notation}[Sequences of integers]
  We write $\{i_1, \ldots i_n\}$ for (ordered) sequences of integers. In particular, the empty sequence is written $\{\}$.
\end{notation}

\begin{definition}[\DeltaPlus]
  The category of augmented semi-simplices is defined in terms of objects and morphisms:

  \begin{align*}
    \obj(\DeltaPlus)   & := \Nat                                                                                    \\
    \hom(p, n)         & := \{i_{p + 1}, \ldots, i_n \mid 0 < i_{p + 1} < \ldots < i_n \leq n\}                     \\
    g \circ f          & := \{i_{j_{p + 1}}, \ldots, i_{j_n} \mid j_0 < i_{j_{p + 1}} < \ldots < i_{j_n} \leq j_n\} \\
    \id \in \hom(n, n) & := \{\}                                                                                    \\
  \end{align*}
\end{definition}

\begin{definition}[$\Set_{\DeltaPlus}$]
  We define the category of augmented semi-simplicial sets as the functor category:

  \begin{equation*}
    \Set_{\DeltaPlus} := \Set^{\op{\DeltaPlus}}
  \end{equation*}
\end{definition}

\begin{definition}[$\DeltaPlus^n$]
  The standard augmented $n$-semi-simplex $\DeltaPlus^n$ is defined as:
\end{definition}

We now illustrate the standard augmented $n$-semi-simplices for dimensions $1$, $2$, and $3$.

\begin{example}[$\DeltaPlus^1$]
  In dimension $1$, the standard augmented semi-simplex is simply the unit type:

  \begin{equation*}
    \begin{tikzcd}
      0
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\DeltaPlus^2$]
  \begin{equation*}
    \begin{tikzcd}
      \kstar0 \arrow[r, dash, "\kstar\kstar"] & 0\kstar
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\DeltaPlus^3$]
  \begin{equation*}
    \begin{tikzcd}
      & |[alias=F]|00\kstar \arrow[ddr, dash, "0\kstar\kstar"] & \\\\
      \kstar00 \arrow[rr, dash, "\kstar\kstar0"{name=T, below}]\arrow[uur, dash, "\kstar0\kstar"] && 0\kstar0 \\
      \arrow[rightarrow, from=F, to=T, phantom, "\kstar\kstar\kstar" description]
    \end{tikzcd}
  \end{equation*}
\end{example}

\subsection{Semi-cubical sets}
\begin{notation}[Faces of cube]
  We use $\epsilon$ to indicate opposite faces of a cube; it takes values $+$ or $-$.
\end{notation}

\begin{definition}[\Cube]
  \begin{align*}
    \obj(\Cube)        & := \Nat                                                                                                             \\
    \hom(p, n)         & := \{(i_{p + 1}, \epsilon_{p + 1}) \ldots, (i_n, \epsilon_n) \mid p < i_{p + 1} < i_{p + 2} < \ldots < i_n \leq n\} \\
    g \circ f          & :=                                                                                                                  \\
    \id \in \hom(n, n) & := \{\}                                                                                                             \\
  \end{align*}
\end{definition}

\begin{definition}[\CSet]
  We define the category of semi-cubical sets as the functor category:

  \begin{equation*}
    \CSet := \Set^{\op{\Cube}}
  \end{equation*}
\end{definition}

\begin{remark}
  $\CSet$ does not admit degeneracies.
\end{remark}

\begin{definition}[$\Cube^n$]
  The standard semi-cube $\Cube^n$ is defined as:
\end{definition}

We now illustrate the standard $n$-semi-cubes for dimensions $0$, $1$, and $2$.

\begin{example}[$\Cube^0$]
  $\Cube^0$ can be drawn as:

  \begin{equation*}
    \begin{tikzcd}
      \{\}
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\Cube^1$]
  \begin{equation*}
    \begin{tikzcd}
      0 \arrow[r, "\kstar", dash] & 1
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\Cube^2$]
  \begin{equation*}
    \begin{tikzcd}
      (0, 1) \arrow[r, dash, "\kstar1"{name=F}] \arrow[d, dash, "0\kstar" left] & (1, 1) \arrow[d, dash, "1\kstar"] \\
      (0, 0) \arrow[r, dash, "\kstar0"{name=T, below}] & (1, 0) \\
      \arrow[rightarrow, from=F, to=T, phantom, "\kstar\kstar" description]
    \end{tikzcd}
  \end{equation*}
\end{example}

\section{Our construction}
In this section, we briefly explain the difference between the fibered and indexed representations, and illustrate our approach to the construction, with the help of some figures.

\subsection{Fibered versus indexed representation}
The fibered representation can be illustrated as:

\begin{equation*}
  \begin{tikzcd}
    X_0 : \U{} & X_1 : \U{} \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] & X_2 : \U{} \arrow[l, "\delta^\epsilon_1" description, shift left=6] \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] \arrow[l, "\delta^\omega_1" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}

The indexed representation can be illustrated as:

\begin{align*}
  X_0 & : \U{}                                                                                                              \\
  X_1 & : X_0 \times X_0 \rightarrow \U{}                                                                                   \\
  X_2 & : \forall a b c d, X_1 (a, b) \rightarrow X_1 (a, c) \rightarrow X_1 (b, d) \rightarrow X_1 (c, d) \rightarrow \U{} \\
  \ldots
\end{align*}

One way to obtain one construction from the other is via the \emph{Grothendieck construction}, although this is not relevant to our work.

\subsection{Iterated parametricity}
One step of parametricity can be seen as interpreting a point by a line. Iterating parametricity shall lead to map terms typed in a context with $n$ declarations of an axis as $n$-fillers. We shall interpret a typing derivation with $n$ axis declarations as an $n$-filler of typing derivations in the target. For instance, a typing derivation with exactly one declaration of an axis will be interpreted by 3 typing derivations in the target, two of them typing points and the third one typing a proof, seen as a line, together with the fact that these two points are related (as in ordinary parametricity), while a typing derivation with $n$ declarations of an axis shall be interpreted as a $3^n$ derivations, split into $2^n$ derivations of points.

The characterization of homogeneous $n$-frame and full $n$-fillers can be obtained by a recursive definition reminiscent from parametricity: a full $(n+1)$-filler is obtained by taking two full $n$-fillers plus a third full $n$-filler connecting the two full $n$-fillers. Since it connects full $n$-fillers, the third full $n$-filler is actually a full $n$-filler over lines, so it is shifted by one relatively to the underlying relational structure. Let us write $\filler[n][p]$ for a full $(n-p)$-filler over points which are full $p$-fillers. Working informally, we thus have the equation:

\begin{equation*}
  \filler[n+1][0] \defeq (\filler[n][0] \times \filler[n][0]) \times \filler[n+1][1]
\end{equation*}

and, iterating and generalizing the process, we have actually:

\begin{equation*}
  \filler[n+1][p] \defeq (\filler[n][p] \times \filler[n][p]) \times \filler[n+1][p+1]
\end{equation*}

Now, the third filler (of dimension $n - p$) connects the first two $(n - p)$-fillers, so it has to depend on them. So, the equation is rather something of the form:

\begin{equation*}
  \filler[n+1][p] \defeq \Sigma a:(\filler[n][p] \times \filler[n][p]).\, \filler[n+1][p+1](a)
\end{equation*}

Then, by iterating, we obtain:

\begin{equation*}
  \filler[n+1][p] \defeq \Sigma a:(\filler[n][p] \times \filler[n][p]).\,
  \Sigma b:(\filler[n][p+1](a) \times \filler[n][p+1](a)). \, \filler[n+1][p+2](a,b)
\end{equation*}

and so on. Thus, we need first to make the definition of $\filler[n][p]$ dependent over the part of the full filler built up to this point and secondly to accumulate this information. At the end of the accumulation of the process, i.e. at the time of building $\filler[n+1][n]$, a complete $n$-frame will have been built. So, let us call $\filler[n][p]$ the partial $n$-frame built up to the stage $p$ of the construction. Thus, we refine our definition into something like:

\begin{equation*}
  \begin{array}{lll}
    \framep[n][0]                    & \defeq & \unittype                                                                       \\
    \framep[n][p+1]                  & \defeq & \Sigma d:\framep[n][p] .\,(\filler[n][p](d) \times \filler[n][p](d))            \\
    \\
    \filler[n+1][p](d:\framep[n][p]) & \defeq & $\Sigma$ a:(\filler[n][p](d) \times \filler[n][p](d)) .\,\filler[n+1][p+1](d,a)
  \end{array}
\end{equation*}

where $\unittype$ is a canonical singleton type used to initiate the
construction of a list of pairs of $n$-fillers.

Now, the two fillers $\filler[n][p](d)$ and $\filler[n][p](d)$ cannot be any fillers. They have to represent two opposite fillers, and we need a way to express this. The answer is simple. The partial frame has two faces and these two fillers have to respectively fill the left face and the right face of the partial frame. We thus have to rely on operations $\restrf[L]$ and $\restrf[R]$ which extract the sides of a frame, leading to the refined definition:

\begin{equation*}
  \begin{array}{lll}
    \filler[n+1][p](d:\framep[n][p]) & \defeq & \Sigma a:(\filler[n][p](\restrf[L](d)) \times \filler[n][p](\restrf[R](d))) .\, \filler[n+1][p+1](d,a)
  \end{array}
\end{equation*}

The full explicit definition shall be given in the next sections but, to give an idea, let us show the structure of an $n$-filler for the first three dimensions.

A full $2$-filler is made of two full $1$-fillers connected by a lifted $1$-filler made of two lines connecting the former points and a square connecting the former lines:

{\scriptsize
\begin{equation*}
  \begin{array}{l}
    \begin{array}{lll}
      \mbox{\textit{squares}}     \\
      [3mm]\mbox{\textit{lines}}  \\
      [3mm]\mbox{\textit{points}} \\
      [1mm]\end{array}
    \framebox{$\begin{array}{lll}
                     \overbrace{\raisebox{0.05cm}{\framebox{$
                           \begin{array}{ll}
                  \raisebox{0cm}{\hspace{.5cm}{\layer[1][0]}}              & \framebox{$a_{0\unitpoint}$} \\
                  [1mm]\overbrace{\framebox{$a_{00}$}~\framebox{$a_{01}$}} &
                  \raisebox{-0.1cm}{\hspace{0.1cm}\filler[1][0]\!\!\!\!\!\!\!\!}
                  \\
                \end{array}
                         $}}~
                     {\raisebox{0.05cm}{\framebox{$
                           \begin{array}{ll}
                  \raisebox{0cm}{\hspace{.5cm}{\layer[1][0]}}              & \framebox{$a_{1\unitpoint}$} \\
                  [1mm]\overbrace{\framebox{$a_{10}$}~\framebox{$a_{11}$}} &
                  \raisebox{-0.1cm}{\filler[1][0]\!\!\!\!\!\!\!\!}
                \end{array}
                         $}}}}^{\layer[2][0]}~\stackrel{\raisebox{9.5mm}{$\framebox{$
                               \begin{array}{ll}
                      \raisebox{0cm}{\hspace{.5cm}{$\layer[2][1]$}}                                & \framebox{$a_{\unitpoint\unitpoint}$} \\
                      [1mm]\overbrace{\framebox{$a_{\unitpoint 0}$}~\framebox{$a_{\unitpoint 1}$}} &
                      \raisebox{-0.1cm}{ \hspace{0.1cm}\filler[2][1]\!\!\!\!\!\!\!\!}
                    \end{array}$}$}}
                     {\raisebox{-0.4cm}{\hspace{2.5cm}\filler[2][0]\!\!\!\!\!\!\!}}
                   \end{array}$}
    ~~~\parbox{2cm}{additionally, each atomic component at dimension $n$ is a \filler[n][n]} \\\\
    [-1mm]\qquad\qquad\quad~~
    \begin{tikzcd}[column sep=5.2em, row sep=1em]
      \phantom{\bullet}\arrow[r, leftrightarrow] & \phantom{\bullet}
    \end{tikzcd}
    \mbox{\framep[1][1]}
    \qquad
    \begin{tikzcd}[column sep=5.2em, row sep=1em]
      \phantom{\bullet}\arrow[r, leftrightarrow] & \phantom{\bullet}
    \end{tikzcd}
    \mbox{\framep[1][1]}                                                                     \\
    \qquad\qquad~~
    \begin{tikzcd}[column sep=32em, row sep=1em]
      \phantom{\bullet}\arrow[r, leftrightarrow] & \phantom{\bullet}
    \end{tikzcd}
    \mbox{\framep[2][1]}                                                                     \\
    \qquad\qquad~~
    \begin{tikzcd}[column sep=39em, row sep=1em]
      \phantom{\bullet}\arrow[r, leftrightarrow] & \phantom{\bullet}
    \end{tikzcd}
    \mbox{\framep[2][2]}                                                                     \\
  \end{array}
\end{equation*}
}

\section{Reasoning about sets in type theory}
Since proof irrelevance is an inherent part of set theory and first-order logic, and proof irrelevance is \emph{extensional} in type theory, we work in a universe known as \texttt{HSet}, which we describe shortly.

\subsection{Unicity of identity proofs}
UIP is a flavor of proof-irrelevance:

\begin{align*}
  \forall x y, \forall p q : x = y, p = q
\end{align*}

which is to say that any two proofs of \emph{equality} of the same two types are \emph{equal}. In other words, the proofs cannot be distinguished from one another.

An equivalent defintion of UIP is given by \textsf{UIP\_refl}:

\begin{align*}
  \textsf{UIP\_refl} & : \forall x, \forall p : x = x, p = \textsf{eq\_refl } x
\end{align*}

In type theory, UIP can be proved on the unit type and bool type:

\begin{align*}
  \textsf{eq\_refl}        & : \forall x, x = x                                                    \\
  \textsf{UIP\_refl\_unit} & : \forall u : \textsf{unit}, \forall x : u = u, x = \textsf{eq\_refl} \\
  \textsf{UIP\_refl\_bool} & : \forall b : \textsf{bool}, \forall x : b = b, x = \textsf{eq\_refl} \\
\end{align*}

\subsection{HSet}
\texttt{HSet} provides us a restricted setting of UIP, and our implementation of \texttt{HSet} is a straightforward packaging of two fields:

\begin{align*}
  \mathsf{Dom} & : \mathsf{Type}                                          \\
  \mathsf{UIP} & : \forall x y : \mathsf{Dom}, \forall p q : x = y, p = q
\end{align*}

In the \texttt{HSet} universe, three properties hold:

\begin{enumerate}
  \item[(i)] UIP holds on the unit type.
  \item[(ii)] UIP propagates to $\Sigma$-types.
  \item[(iii)] UIP propagates to $\Pi$-types, with some additional functional extensionality axioms.
\end{enumerate}

\section{Type-theoretic construction of \texorpdfstring{$\nu$}{nu}-sets}
% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{filler}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrfiller}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohfiller}[D, d]

% Now, we write the type theory bit, and input the abbreviated tables

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and filler
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and filler
% Drop the unviverse letter
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\newcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\newcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and filler
% Keep only ε, ω; n, p; proposition on n and p
\newcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\newcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\newcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[][#2][#3][][][][][#9]}

The definition in \ref{tab:coind}, the coinductive limit, is dispatched over tables \ref{tab:core}, \ref{tab:frames}, \ref{tab:faces} and \ref{tab:coh}. They describe the structure of the underlying higher-dimensional relations on which fillers are built.

\renewcommand*{\lab}{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\newcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

We now describe \emph{bare truncated sets}: \emph{bare} because it can be seen as defining truncated $\nu$-sets without face maps, and \emph{truncated} because it is $n$-truncated.

\renewcommand*{\lab}{tab:core}
\input{tab-core.tex}

% Drop the universe letter in fullframe for all remaining tables
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[][#2][][][#3]}
\renewcommand*{\lab}{tab:frames}
\input{tab-frames.tex}

% Truncated sets, otherwise referred to as X
% Drop the universe letter for the third and fourth tables
\renewcommandx{\Xto}[3][3]{\X[][<#2][#3]}
\renewcommandx{\Xcomp}[3][3]{\X[][=#2][#3]}
\renewcommandx{\Xfrom}[3][3]{\X[][\geq#2][#3]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

In the way we have chosen to formlate these tables, there is, for instance, coherence condition $\cohf$ both sides of the equality in $\restrl$ and $\restrc$, to ensure that they are the same type.

For a given $n$, the coherence conditions evaluate to a reflexivity proof, so that the construction evaluates to an effective sequence of types of iterated relations not mentioning $\restrf$ nor $\cohf$ anymore.

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\renewcommand*{\lab}{tab:faces}
\input{tab-faces.tex}

% Restriction for frame, layer, and filler
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[][#2][#3][#4][#5][#6][#7]}

% Frame, layer, and filler
% Drop all arguments for coh table; they're not present in coind table.
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][][][][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][][][][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[][][][][#5]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

The proof of $\cohf$ require a higher-dimensional coherence condition which we obtain by working in \texttt{HSet}. If the proofs of the same equality were not equated, there would be a need for arbitrary many higher-dimensional coherences (see e.g.~\cite{herbelin15} for a discussion on the de facto need for recursive higher-dimensional coherence conditions in formulating higher-dimensional structures in type theory).

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\newcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{tab:coh}
\input{tab-coh.tex}


where $\cohtwo{frame}$ is:

\begin{align*}
  \cohf[m][\omega][\theta][r][p][n][p][][d = {\restrf[m][\epsilon][q+2][n][p][][d = \d, D = \D]}, D = \D]\;\bullet         \\
  \ap (\restrf[m][\omega][r][n][p][][d = {\cohf[m][\epsilon][\theta][q+1][p][n][p][][d = \d, D = \D]}, D = \D]\;\bullet    \\
  \cohf[m][\epsilon][\omega][q][r][n][p][][d = {\restrf[m][\theta][p][n][p][][d = \d, D = \D]}, D = \D] =                  \\
  \ap (\restrf[m][\theta][p][n][p][][d = {\cohf[m][\epsilon][\omega][q+1][r+1][n][p][][d = \d, D = \D]}, D = \D])\;\bullet \\
  \cohf[m][\epsilon][\theta][q][p][n][p][][d = {\restrf[m][\omega][r+1][n][p][][d = \d, D = \D]}, D = \D]\;\bullet         \\
  \ap (\restrf[m][\epsilon][q][n][p][][d = {\cohf[m][\omega][\theta][r][p][n][p][][d = \d, D = \D]}, D = \D])
\end{align*}

\newpage
\section{Future work}

\newpage
\appendix
\section{Tables in full detail}
% Full tables in this section
%
% Clear the mask and label
\clearmask

% Keep all arguments for all macros
% Frame, layer, and filler
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[#1][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[#1][#2][#3][#4][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[#1][#2][#3][#4][#5]}
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

% Restriction for frame, layer, and filler
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[#1][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[#1][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{fulltab:coind}
\input{tab-coind.tex}
\renewcommand*{\lab}{fulltab:core}
\input{tab-core.tex}
\renewcommand*{\lab}{fulltab:frames}
\input{tab-frames.tex}

\begin{landscape}
  \renewcommand*{\lab}{fulltab:faces}
  \input{tab-faces.tex}
  \renewcommand*{\lab}{fulltab:coh}
  \input{tab-coh.tex}
\end{landscape}

\bibliographystyle{alpha}
\bibliography{paper}

\end{document}
