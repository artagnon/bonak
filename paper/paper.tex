\documentclass[10pt]{art}

\usepackage{multirow, minted, tabularx, booktabs, setspace, makecell, caption}
\usepackage[hmargin=0.4in, vmargin=0.8in, headheight=10pt]{geometry}

% Some lua magic to join a variable number of arguments with commas
% Comma-separeated optional arguments
\begin{luacode*}
  function remove_empty(tbl)
    for i, v in ipairs(tbl) do
        if v == "" then
          table.remove(tbl, i)
          return remove_empty(tbl)
        end
    end
    return tbl
  end
  function join_with_comma(tbl)
    return table.concat(remove_empty(tbl), ",")
  end
\end{luacode*}

\newcommandx{\joinargs}[5][1=,2=,3=,4=,5=]{\directlua{tex.sprint(join_with_comma({"\luaescapestring{#1}";"\luaescapestring{#2}";"\luaescapestring{#3}";"\luaescapestring{#4}";"\luaescapestring{#5}"}))}}

% Simplicial and Cubical sets
\newcommand{\DeltaHat}{\ensuremath{\hat{\boldsymbol{\Delta}}}}
\newcommand{\Cube}[1]{\ensuremath{\boldsymbol{\square^{#1}}}}
\renewcommand{\I}[1]{\ensuremath{\mathsf{I}^{#1}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommand{\U}[1]{\ensuremath{\mathsf{\color{spanish-blue}{U}}_{#1}}}

% The unit type
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\unitpoint}{\ensuremath{\star}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\eqett}{\ensuremath{\equiv_{\mathit{ETT}}}}
\newcommand{\reflett}{\ensuremath{\mathsf{refl}_{\mathit{ETT}}}}

% Truncated sets, otherwise referred to as X
\newcommand{\Xp}[1]{\ensuremath{\mathsf{\color{carolina}{X}}_{#1}}}
\newcommand{\X}[2]{\ensuremath{\mathsf{\color{carolina}{X}}_{#1}^{<#2}}}
\newcommand{\Xcomp}[2]{\ensuremath{\mathsf{\color{carolina}{X}}_{#1}^{=#2}}}
\newcommand{\Xfrom}[2]{\ensuremath{\mathsf{\color{carolina}{X}}_{#1}^{\geq#2}}}

% Frame, layer, and filler: the general macro
\newcommandx{\prim}[5][2=,3=,4=,5=]{\ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{\joinargs[#3][#4][#5]}}}

% Full frame
\newcommandx{\fullframe}[2][1=,2=]{\ensuremath{\mathsf{\color{indian-yellow}{fullframe}}^{#2}}}

% Restriction for frame, layer, and filler: the general macro
\newcommandx{\restr}[7][2=,3=,4=,5=,6=,7=]{\ensuremath{\mathsf{\color{russian-green}{restr}}_{\mathsf{\color{indian-yellow}{#1}}, \joinargs[#2][#3][#4]}^{\joinargs[#5][#6][#7]}}}

% Coherence conditions for frame, layer, and filler: the general macro
\newcommandx{\coh}[9][2=,3=,4=,5=,6=,7=,8=,9=]{\ensuremath{\mathsf{\color{chestnut}{#1}}_{\joinargs[#2][#3][#4][#5][#6]}^{\joinargs[#7][#8][#9]}}}

% Logical implication
\newcommand{\imp}{\ensuremath{\rightarrow}}
\newcommand{\overright}[1]{\ensuremath{\overrightarrow{#1}}}

% Some abbreviations
\renewcommand{\D}{\ensuremath{(D)}}
\newcommand{\hdD}{\ensuremath{(D.1)}}
\newcommand{\tlD}{\ensuremath{(D.2)}}
\renewcommand{\d}{\ensuremath{(d)}}
\newcommand{\E}{\ensuremath{(E)}}
\renewcommand{\l}{\ensuremath{(l)}}
\renewcommand{\c}{\ensuremath{(c)}}


% Fancy headers
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\footnotesize\textcolor{gray80}{{\thepage / \pageref{LastPage}}}}
\renewcommand{\sectionmark}[1]{\markboth{}{\thesection.\ #1}}
\fancyhead[L]{\footnotesize\textcolor{gray80}{{\MakeUppercase{\rightmark}}}}

% Section and subsection styles
\renewcommand{\thesection}{\Roman{section}}
\titleformat{\section}{\centering\scshape\Large\color{raspeberry}}{\thesection}{0.7em}{}
\titleformat{\subsection}{\strongenv\large\color{gray80}}{\thesubsection}{0.7em}{}

% Pack enumerate items and bibitems
\setlist{nolistsep}
\setlength{\bibitemsep}{.2\baselineskip plus .05\baselineskip minus .05\baselineskip}

% The eqntable environment, displaying the various
\NewDocumentEnvironment{eqntable}{m}{\table[H]\small
\tabularx{\textwidth}{@{} l c c >{\centering\arraybackslash}X @{}}\toprule}
{\endtabularx\vspace{0.3em}\hrule\vspace{0.5em}\caption{#1}\endtable}

% A block in the eqntable environment
\newcommand{\eqnline}[4]{$#1$ & $#2$ & $#3$ & $#4$ \\}
\newcommand{\mc}[1]{\multicolumn{4}{c}{\textit{#1}} \\\\}

% Table caption set up
\DeclareCaptionFormat{hfillstart}{\hfill#1#2#3\par}
\DeclareCaptionFont{mdit}{\mdseries\itshape}
\captionsetup[table]{
  justification=centering,
  font=bf,
  labelfont=mdit,
}

% Code listings
\usemintedstyle{solarized-dark}
\setminted{escapeinside=~~}
\setmintedinline{escapeinside=~~}

% Fonts
\setmainfont{Avenir Next}
\setmonofont{Source Code Pro}
\defaultfontfeatures{Ligatures=TeX, Scale=MatchUppercase}

\title{An indexed construction of semi-simplicial and semi-cubical types}
\author{
  \textcolor{gray80}{Hugo Herbelin} \\
  \itshape \textcolor{gray80}{IRIF}
  \and
  \textcolor{gray80}{Ramkumar Ramachandra} \\
  \itshape \textcolor{gray80}{Universit√© de Paris}
}
\date{}

\color{gray65}

\begin{document}
\thispagestyle{empty}
\maketitle
\begin{abstract}
  A model of \emph{homotopy type theory}, that formalizes \emph{truncated} $n$-types in dependent type theory. The accompanying artifact is an axiomless Coq formalization~\footnote{Technically speaking, we use some axioms related to functional extensionality, but the requirement arises only from our generalization to truncated $n$-types; if one were to instantiate our development for a particular type (say, augmented simplicial types), this requirement vanishes.} that uses sophisticated rewriting techniques and pushes the boundary of proof assistant technology.
\end{abstract}
\tableofcontents
\newpage

\section{Overture}
Cubical type theory~\cite{Bezem14}~\cite{Cohen16}~\cite{Angiuli17} is an extension of dependent type theory that provides a computational interpretation of Voevodsky's \emph{univalence axiom}, in a field known as \emph{homotopy type theory}, or HoTT. Two real-world projects that implement cubical type theory are worthy of mention: an experimental branch of Agda, known as \emph{Cubical Agda}~\cite{Vezzosi21}, and the Arend theorem prover~\footnote{\href{https://arend-lang.github.io}{arend-lang.github.io}}. Cubical type theory is usually modeled as cubical sets, in the set-theoretic setting. Efforts to model cubical type theory have been ongoing since 2014, and many of these efforts are in the set-theoretic setting.

Our contribution is to model the core of semi-cubical sets that naturally generalizes to augmented simplicial sets in type theory, and we call our generalization \emph{truncated $n$-sets}. In contrast to previous efforts that use a fibered representation, we use an indexed representation, that can be derived from the fibered one using a \emph{iterated reverse-Grothendieck} construction. Our work is, in principle axiom-free, although the accompanying artifact uses functional extensionality in order to generalize our work to $n$-truncated sets.

\begin{table}[H]
  \begin{tabularx}{\linewidth}{p{.3\linewidth}|p{.3\linewidth}|p{.3\linewidth}}
    \toprule
            & Set theory & Type theory \\
    \midrule
    Fibered & CCHM       &             \\
    \midrule
    Indexed &            & Our work    \\
    \bottomrule
  \end{tabularx}
\end{table}

The outline of the paper is as follows. First, we take the opportunity to familize the reader with simplicial sets, as it appears in mathematical literature, along with a short section on semi-cubical sets. We then proceed to explain our construction, with the help of diagrams. Before spelling out the details of our formalization in type-theoretic language, we have a section on the unicity of identity proofs (UIP), since the use of \mintinline{coq}{SProp} has greatly eased our Coq formalization.

\section{Simplicial sets}
Simplicial sets are powerful mathematical objects, that form the basis of much of modern homotopy theory. Their power derives from the fact that their homotopy category is exceptionally well-behaved, and that there are multiple model structures defined on them. Unlike CW-complexes that rely on pure topological notions like spheres and disks to ``tame'' a topological space, the definition of simplicial sets is purely categorical, and exist independent of topological spaces. The \emph{geometric realization} and \emph{singular complex} functors facilitate travelling back-and-forth between simplicial sets and topological spaces, and these are non-trivial constructions. As such, simplicial sets exist purely in the imagination of the mathematician, as every simplicial set has an infinite number of degenerate simplices.

\subsection{\texorpdfstring{\SSet}{The category of simplicial sets}}
There exists vast mathematical literature on the subject, and we refer the uninitiated reader to \cite{Friedman08} for a gentle introduction with excellent intutions. With these intuitions in place, we proceed with a purely categorical treatment. Emily Riehl's \cite{Riehl11} is an especially well-written manuscript on the subject.

\begin{definition}[\sq{n}]
  $\sq{n}$ is used to denote a totally-ordered set of natural numbers less than or equal to $n$, ordered by magnitude.

  \begin{equation*}
    \sq{n} := \{0, 1, \ldots, n\}
  \end{equation*}

  We will regard the totally-ordered set as a category in certain contexts, and it should be clear which interpretation we're referring to from the context.

  \begin{equation*}
    \sq{n} := 0 \rightarrow 1 \rightarrow \ldots \rightarrow n
  \end{equation*}
\end{definition}

\begin{definition}[\Simplex{}]
  The category $\Simplex{}$ is defined in terms of its objects and morphisms:

  \begin{align*}
    \obj(\Simplex{}) & := \sq{n}, \text{regarded as a totally-ordered set}   \\
    \mor(\Simplex{}) & := \sq{m} \rightarrow \sq{n}, \text{order-preserving}
  \end{align*}
\end{definition}

\begin{definition}[\SSet]
  The category of simplicial sets is defined as:

  \begin{equation*}
    \SSet := \Set^{\op{\Simplex{}}}
  \end{equation*}

  It is a functor category, whose objects and morphisms are given by:

  \begin{align*}
    \obj(\SSet)            & := \text{functors} \; \op{\Simplex{}} \rightarrow \Set     \\
    \mor(\SSet)            & := \text{natural transforms between the functors}          \\
    \text{composition law} & := \text{the usual composition of natural transformations} \\
  \end{align*}
\end{definition}

\begin{definition}[\Simplex{n}]
  The Yoneda embedding of $\sq{n}$ is referred to as the standard $n$-simplex.

  \begin{equation*}
    \Simplex{n} := y(\sq{n})
  \end{equation*}
\end{definition}

\begin{notation}[$\sq{0, \ldots, n}$]
  The notation $\sq{0, \ldots, n}$ denotes all ordered subsets of \sq{n}.
\end{notation}

With the definition of the category of simplicial sets firmly in place, we look inside a simplicial set to see the data it actually encodes concretely.

\begin{definition}[The data of a simplicial set]
  A simplicial set is equivalent to the data of a set of $n$-simplices, related to each other via face and degeneracy maps.

  \begin{align*}
    X_n                             & \;\;\text{a set of n-simplices} \\
    d_i : X_{n + 1} \rightarrow X_n & \;\;\text{face maps}            \\
    s_i : X_n \rightarrow X_{n + 1} & \;\;\text{degeneracy maps}      \\
  \end{align*}

  where $X_n$ is the set of $n$-simplices contained within the simplicial set $X$:

  \begin{align*}
    X_n & : \Set                                             \\
    X_n & := X(\sq{n}), \text{where X is the simplicial set} \\
  \end{align*}

  and $d_i$ and $s_i$ operate on $X_n$ as follows (the hat on $i$ indicates that it is to be omitted):

  \begin{align*}
    d_i(\sq{0, \ldots, n}) & = \sq{0, \ldots, \hat{i}, \ldots, n} \\
    s_i(\sq{0, \ldots, n}) & = \sq{0, \ldots, i, i, \ldots, n}    \\
  \end{align*}

  and $d_i$, $s_i$ are constrained by the following ``simplicial identities'':

  \begin{equation*}
    \begin{matrix}
      d_i d_j & = & d_{j - 1} d_i & i < j \\
      s_i s_j & = & s_{j + 1} s_i & i < j \\
      d_i s_j & = &
      \begin{cases}
        s_{j - 1} d_i & i < j \\
        id            & i = j \\
        s_j d_{i - 1} & i > j \\
      \end{cases}
    \end{matrix}
  \end{equation*}
\end{definition}

We mentioned degeneracies in the introduction to this section, and we define precisely what a degenerate simplex is now.

\begin{definition}[Degenerate simplex]
  A simplex is $x \in X_n$ is termed degenerate if it is the image of some degeneracy map $s_i$, and non-degenerate otherwise.
\end{definition}

\begin{example}[Non-degenerate simplices of \Simplex{n}]
  The non-degenerate $k$-simplices of $\Simplex{n}$ are the injective maps $\sq{k} \rightarrow \sq{n}$ in $\Simplex{}$. In particular, $\Simplex{n}$ has a unique non-degenerate $n$-simplex.
\end{example}

As is clear from the above definitions, simplicial sets have an infinite number of degeneracies, and the first step towards drawing a simplicial set is to define a convention that omits these degeneracies in the drawing.

\begin{notation}[Drawing of a simplicial set\label{not:drawsset}]
  A diagram of the form

  \begin{equation*}
    \begin{tikzcd}
      x \arrow[r, "f"] & y
    \end{tikzcd}
  \end{equation*}

  in simplicial set $S$ will mean that $f$ is a non-degenerate $1$-simplex, and $x$ and $y$ are $0$-simplices. The simplices have a relationship to the simplicial set $S$ given by the following commutative diagram:

  \begin{equation*}
    \begin{tikzcd}
      \Simplex{0} \arrow[dr] \arrow[drr, "x", bend left] & & \\
      & \Simplex{1} \arrow[r, "f"] & S \\
      \Simplex{0} \arrow[ur] \arrow[urr, "y"', bend right] & & \\
    \end{tikzcd}
  \end{equation*}

  To attempting to draw simplices of dimension greater than $1$, we see that there is a potential ambiguity. Consider the following diagram:

  \begin{equation*}
    \begin{tikzcd}
      & \bullet \arrow[ddr] & \\
      \\
      \bullet \arrow[uur] \arrow[rr] & & \bullet
    \end{tikzcd}
  \end{equation*}

  In the above diagram, it is clear that there are three non-degenerate $1$-simplices, but it is unclear whether there is a non-degenerate $2$-simplex. By convention, when we draw such a diagram, we will assume that there is a non-degenerate $2$-simplex border by the three non-degenerate $1$-simplices. To generalize, we will always assume that there exists a non-degenerate $n$-simplex, when bounded by non-degenerate $(n - 1)$-simplices.
\end{notation}

\begin{example}[\Simplex{0}, \Simplex{1}, and \Simplex{2}]
  $\Simplex{0}$ can be drawn as:

  $$
    \begin{tikzcd}
      0
    \end{tikzcd}
  $$

  $\Simplex{1}$ can be drawn as:

  $$
    \begin{tikzcd}
      0 \arrow[r] & 1
    \end{tikzcd}
  $$

  and $\Simplex{2}$ can be drawn as:

  $$
    \begin{tikzcd}
      & 1 \arrow[ddr] & \\
      \\
      0 \arrow[uur] \arrow[rr] & & 2
    \end{tikzcd}
  $$
\end{example}

\subsection{\texorpdfstring{\DeltaHat}{Delta sets}}
As a first step towards formalizing simplicial sets, we restrict outselves to representing \emph{augmented simplicial sets}, which are described roughly as delta-sets in mathematical literature, which forgets about the degeneracies. We now proceed to describe \DeltaHat, which is identical to \Simplex{}, but for the fact that the maps $\sq{m} \rightarrow \sq{n}$ are \emph{strictly} order-preserving. The degeneracies then vanish, and we're left with the task of defining gluing conditions solely on the basis of face maps. In mathematical literature, there is little interest in studying \DeltaHat, since maps between delta sets are not well-defined, and it is therefore not possible to construct a category of delta sets.

\subsection{Semi-cubical sets}
We might naively attempt to define $\Cube{}$ identically to \DeltaHat, but let us briefly explain why this wouldn't work, motivating the definition of semi-cubical sets as in \cite{Antolini00}. If there were morphisms from every $\sq{m}$ to \sq{n}, we would end up with:

$$
  \begin{tikzcd}
    \bullet \arrow[r] \arrow[dr] \arrow[d] & \bullet \arrow[d] \\
    \bullet \arrow[r] \arrow[ur] & \bullet
  \end{tikzcd}
$$

where the filling conditions are conflated with the cube itself. $\Simplex{n}$ can be defined quite simply as the convex hull of $n$ points, but even defining the standard $n$-cube becomes a problem if we start with $\sq{n}$, but the situation becomes much more amenable if we define:

\begin{definition}[\Cube{n}]
  \begin{equation*}
    \Cube{n} := \I{n} = \sq{0, 1}^n
  \end{equation*}
\end{definition}

\begin{example}[$\Cube{0}$, $\Cube{1}$ and $\Cube{2}$]
  $\Cube{0}$ can be drawn as:

  $$
    \begin{tikzcd}
      0 \equiv 1
    \end{tikzcd}
  $$

  $\Cube{1}$ can be drawn as:

  $$
    \begin{tikzcd}
      0 \arrow[r, dash] & 1
    \end{tikzcd}
  $$

  and $\Cube{2}$ can be drawn as:

  $$
    \begin{tikzcd}
      (0, 1) \arrow[r, dash] & (1, 1) \arrow[d, dash] \\
      (0, 0) \arrow[u, dash] & (1, 0) \arrow[l, dash]
    \end{tikzcd}
  $$
\end{example}

Here, $\I{n}$ serves the purpose of \sq{n}, but this change will cascade into other definitions. In view of defining a category \CSet, we will restrict the morphisms in \Cube{}.

\begin{definition}[\Cube{}]
  \begin{align*}
    \obj(\Cube{}) & := \I{n}                                           \\
    \mor(\Cube{}) & := \delta^\epsilon_i : \I{n + 1} \rightarrow \I{n}
  \end{align*}

  where $\delta^\epsilon_i$ must satisfy the corresponding face map condition:

  \begin{equation*}
    \delta^\epsilon_i \delta^\omega_j = \delta^\omega_{j - 1} \delta^\epsilon_i
  \end{equation*}

  where $\epsilon$ and $\omega$ correspond to opposite faces.
\end{definition}

\begin{definition}[\CSet]
  Just as in \SSet, we define semi-cubical sets as the functor category:

  \begin{equation*}
    \CSet := \Set^{\Cube{}^{op}}
  \end{equation*}
\end{definition}

Or, in terms of objects and morphisms:

\begin{definition}[$\CSet$ in terms of objects and morphisms]
  \begin{align*}
    \obj(\CSet) & := X_n                                                   \\
    \mor(\CSet) & := X_\lambda, \text{where $\lambda$ is \Cube{}-morphism}
  \end{align*}

  where we term $X_n$ as the $n$-cubex, and $X_\lambda$ as the ``face map'', defined similarly:

  \begin{align*}
    X_n       & := X(\I{n}), \text{where X is the semi-cubical set} \\
    X_\lambda & := X(\lambda)
  \end{align*}
\end{definition}

\begin{theorem}
  $\CSet$ does not admit degeneracies.
\end{theorem}

\begin{proof}
  The reader is advised to refer to \cite{Antolini00} for the proof.
\end{proof}

\section{Grothendieck construction\label{sec:grothendieckconstr}}
The Grothendieck construction provides a correspondence between a fibered representation, and an indexed representation.

$$
  \begin{tikzcd}
    X_0 : \U{} & X_1 : \U{} \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] & X_2 : \U{} \arrow[l, "\delta^\epsilon_1" description, shift left=6] \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] \arrow[l, "\delta^\omega_1" description, shift right=6] & \ldots
  \end{tikzcd}
$$

\begin{align*}
  X_0 & : \U{}                                                                                                      \\
  X_1 & : X_0 \times X_0 \rightarrow \U{}                                                                           \\
  X_2 & : \forall a b c d, X_1 : ab \rightarrow X_1 : bc \rightarrow X_1 : cd \rightarrow X_1 : da \rightarrow \U{} \\
  \ldots
\end{align*}

\section{Unicity of identity proofs\label{sec:uip}}
We dedicate this section to discussing UIP in different settings, and supply intuitions into this notion.

UIP is a flavor of proof-irrelevance:

\begin{align*}
  \forall x y, \forall p q : x = y, p = q
\end{align*}

which is to say that any two proofs of \emph{equality} of the same two types are \emph{equal}. In other words, the proofs cannot be distinguished from one another.

Proof irrelevance is an inherent part of set theory and first-order logic, although the property cannot be stated in the language of natural deductions. Intuititively, what it means is that a tree of deductions converges to a result, with no memory of the proof route; the tree itself is forgotten once the final result is obtained.

One way of formalising set theory in type theory is via Aczel sets [ref]. It can be written down as an inductive as follows:

\begin{listing}[H]
  \begin{minted}[mathescape]{coq}
    Inductive SET : Type :=
      node : ~$\forall$~A : Type, (A -> SET) -> SET
      ~$=_\textrm{SET}$~ : ...
  \end{minted}
\end{listing}

\mintinline{coq}{(A -> SET) -> SET} can be drawn as:

\begin{equation*}
  \begin{tikzcd}
    \{0\} \arrow[dr] & \\
    & \{\} \\
  \end{tikzcd}
  \begin{tikzcd}
    & \{0, 1\} \arrow[dr]\arrow[dl] & \\
    \{0\} & & \{1\} \\
  \end{tikzcd}
  \begin{tikzcd}
    & & \{0, 1, 2\} \arrow[dr]\arrow[dl] & \\
    & \{0, 1\} \arrow[dl]\arrow[dr] & & \{2\} \\
    \{0\} & & \{1\} & \\
  \end{tikzcd}
\end{equation*}

In general, \mintinline{coq}{SET} can have an $n$-ary branching structure, splitting out the various subsets until we get to the leaves.

Then, proof irrelevance can be stated as:

\begin{align*}
  \forall x y, \forall p q : x =_{\textrm{SET}} y, p = q
\end{align*}

\section{Trunacated $n$-sets}
In this section, we give the core of the definition of truncated $n$-sets
as a coinductive limit.

% Now, we write the type theory bit, and input the abbreviated tables
% Frame, layer, and filler
\newcommandx{\framep}[4][1=,2=,3=,4=]{\prim{frame}[][#2][#3][#4]}
\newcommandx{\layer}[4][1=,2=,3=,4=]{\prim{layer}[][#2][#3][#4]}
\newcommandx{\filler}[4][1=,2=,3=,4=]{\prim{filler}[][#2][#3][#4]}

% Restriction for frame, layer, and filler
\newcommandx{\restrf}[6][1=,2=,3=,4=,5=,6=]{\restr{frame}[][#2][][#4][#5][#6]}
\newcommandx{\restrl}[6][1=,2=,3=,4=,5=,6=]{\restr{layer}[][#2][][#4][#5][#6]}
\newcommandx{\restrc}[6][1=,2=,3=,4=,5=,6=]{\restr{filler}[][#2][][#4][#5][#6]}

% Coherence conditions for frame, layer, and filler
\newcommandx{\cohframe}[8][1=,2=,3=,4=,5=,6=,7=,8=]{\coh{cohframe}[][#2][#3][][][][][#8]}
\newcommandx{\cohlayer}[8][1=,2=,3=,4=,5=,6=,7=,8=]{\coh{cohlayer}[#1][#2][#3][#4][#5][#6][#7][#8]}
\newcommandx{\cohfiller}[8][1=,2=,3=,4=,5=,6=,7=,8=]{\coh{cohfiller}[#1][#2][#3][#4][#5][#6][#7][#8]}

The definition is dispatched over tables \ref{tab:core}, \ref{tab:frames}, \ref{tab:faces} and \ref{tab:coh}. It describes the structure of the underlying higher-dimensional relations on which fillers are built. Note the presence of a coherence condition $\cohframe[l]$ to ensuring that both sides of the equality in $\restrl[l]$ and $\restrc[l]$ are in the same type. The proof of $\cohframe[l]$ itself requires an higher-dimensional coherence condition which we obtain by working in \mintinline{coq}{HSet}. Note that if the proofs of the same equality were not equated, there would be a need for arbitrary many higher-dimensional coherences (see e.g.~\cite{Herbelin15} for a discussion on the de facto need for recursive higher-dimensional coherence conditions in formulating higher-dimensional structures in type theory). Note also that for a given $n$, the coherence conditions evaluate to a reflexivity proof, so that the construction evaluates to an effective sequence of types of iterated relations not mentioning $\restrf[l]$ nor $\cohframe[l]$ anymore.

When reflexivities are excluded, we call the structure thus defined \emph{bare truncated sets}: \emph{bare} because it can be seen as defining truncated $n$-sets corresponding to simplical sets with only faces as part of the structure.

\input{tab-core.tex}
\input{tab-frames.tex}
\input{tab-faces.tex}

% Restriction for frame, layer, and filler
\renewcommandx{\restrf}[6][1=,2=,3=,4=,5=,6=]{\restr{frame}[][#2][#3][#4][#5][#6]}
\renewcommandx{\restrl}[6][1=,2=,3=,4=,5=,6=]{\restr{layer}[][#2][#3][#4][#5][#6]}
\renewcommandx{\restrc}[6][1=,2=,3=,4=,5=,6=]{\restr{filler}[][#2][#3][#4][#5][#6]}

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohframe}[8][1=,2=,3=,4=,5=,6=,7=,8=]{\coh{cohframe}[][][][#4][#5][][#7][#8]}
\renewcommandx{\cohlayer}[8][1=,2=,3=,4=,5=,6=,7=,8=]{\coh{cohlayer}[][][][#4][#5][][#7][#8]}
\renewcommandx{\cohfiller}[8][1=,2=,3=,4=,5=,6=,7=,8=]{\coh{cohfiller}[][][][#4][#5][][#7][#8]}

\input{tab-coh.tex}
\input{tab-coind.tex}

\section{Future work}

\newpage
\appendix
\section{Tables in full detail}
% Frame, layer, and filler
\renewcommandx{\framep}[4][1=,2=,3=,4=]{\prim{frame}[#1][#2][#3][#4]}
\renewcommandx{\layer}[4][1=,2=,3=,4=]{\prim{layer}[#1][#2][#3][#4]}
\renewcommandx{\filler}[4][1=,2=,3=,4=]{\prim{filler}[#1][#2][#3][#4]}

\renewcommandx{\fullframe}[2][1=,2=]{\ensuremath{\mathsf{\color{indian-yellow}{fullframe}}_{#1}^{#2}}}

% Restriction for frame, layer, and filler
\renewcommandx{\restrf}[6][1=,2=,3=,4=,5=,6=]{\restr{frame}[#1][#2][#3][#4][#5][#6]}
\renewcommandx{\restrl}[6][1=,2=,3=,4=,5=,6=]{\restr{layer}[#1][#2][#3][#4][#5][#6]}
\renewcommandx{\restrc}[6][1=,2=,3=,4=,5=,6=]{\restr{filler}[#1][#2][#3][#4][#5][#6]}

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohframe}[8][1=,2=,3=,4=,5=,6=,7=,8=]{\coh{cohframe}[#1][#2][#3][#4][#5][#6][#7][#8]}
\renewcommandx{\cohlayer}[8][1=,2=,3=,4=,5=,6=,7=,8=]{\coh{cohlayer}[#1][#2][#3][#4][#5][#6][#7][#8]}
\renewcommandx{\cohfiller}[8][1=,2=,3=,4=,5=,6=,7=,8=]{\coh{cohfiller}[#1][#2][#3][#4][#5][#6][#7][#8]}

\input{tab-core.tex}
\input{tab-frames.tex}
\input{tab-faces.tex}
\input{tab-coh.tex}
\input{tab-coind.tex}

\newpage

\begin{thebibliography}{10}
  \bibitem[Bez]{Bezem14}
  Bezem, M., Coquand, T., \& Huber, S. (2014, July). A model of type theory in cubical sets. \textit{In 19th International Conference on Types for Proofs and Programs (TYPES 2013)} (Vol. 26, pp. 107-128). Wadern, Germany: Schloss Dagstuhl‚ÄìLeibniz Zentrum fuer Informatik.

  \bibitem[CubAgda]{Vezzosi21}
  Vezzosi, A., M√∂rtberg, A., \& Abel, A. (2021). Cubical Agda: a dependently typed programming language with univalence and higher inductive types. \textit{Journal of Functional Programming, 31}.

  \bibitem[CohCoq]{Cohen16}
  Cohen, C., Coquand, T., Huber, S., \& M√∂rtberg, A. (2016). Cubical type theory: a constructive interpretation of the univalence axiom. arXiv preprint arXiv:1611.02108.

  \bibitem[Angiuli]{Angiuli17}
  Carlo Angiuli, Guillaume Brunerie, Thierry Coquand, Kuen-Bang Hou (Favonia), Robert Harper, \& Daniel R. Licata. arXiv preprint.

  \bibitem[Fri]{Friedman08}
  Friedman, G. (2008). An elementary illustrated introduction to simplicial sets. \textit{arXiv preprint arXiv:0809.4221}.

  \bibitem[Rie]{Riehl11}
  Riehl, E. (2011). A leisurely introduction to simplicial sets. \textit{Unpublished expository article available online from the author's web page}.

  \bibitem[CubSet]{Antolini00}
  Antolini, R. (2000). Cubical structures, homotopy theory. \textit{Annali di Matematica pura ed applicata, 178}(1), 317-324.

  \bibitem[Her]{Herbelin15}
  Herbelin, H. (2015). A dependently-typed construction of semi-simplicial types. \textit{Mathematical Structures in Computer Science, 25}(5), 1116-1131.

  \bibitem[CoqInCoq]{Barras97}
  Barras, B., \& Werner, B. (1997). Coq in coq. \textit{Available on the WWW.}
\end{thebibliography}

\end{document}
