\documentclass[10pt]{art.cls/art}

\usepackage{multirow, float, tabularx, environ, booktabs, setspace, makecell, caption, art.cls/joinargs, colortbl, pdflscape}
\usepackage[prefix=bonak]{art.cls/xkeymask}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{filler}{D}{(#1)}
\define@cmdkey[bonak]{filler}{E}{(#1)}
\define@cmdkey[bonak]{filler}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrfiller}{D}{(#1)}
\define@cmdkey[bonak]{restrfiller}{E}{(#1)}
\define@cmdkey[bonak]{restrfiller}{d}{(#1)}
\define@cmdkey[bonak]{restrfiller}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohfiller}{D}{(#1)}
\define@cmdkey[bonak]{cohfiller}{E}{(#1)}
\define@cmdkey[bonak]{cohfiller}{d}{(#1)}
\define@cmdkey[bonak]{cohfiller}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \mathsf{\color{carolina}{X}}_{#1}^{#2}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and filler: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs{}[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and filler: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4]}^{\joinargs{}[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

% Coherence conditions for frame, layer, and filler: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4][#5][#6]}^{\joinargs{}[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4][#5][#6][#7]}^{\joinargs{}[#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}[1]{\ensuremath{\boldsymbol{\square^{#1}}}}
\renewcommand{\I}[1]{\ensuremath{\mathsf{I}^{#1}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommand{\U}[1]{\mathsf{\color{spanish-blue}{HSet}}_{#1}}

% The unit type
\newcommand{\unittype}{\mathsf{unit}}
\newcommand{\unitpoint}{\star}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\eqHSet}{\ensuremath{\equiv_{\mathit{HSet}}}}
\newcommand{\reflHSet}{\ensuremath{\mathsf{refl}_{\mathit{HSet}}}}

% Some abbreviations
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\newcommand{\ap}{\mathsf{ap}}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\filler}[2][1,2]{\prim{filler}[][#1][#2][][]}

% The eqntable environment, displaying the various
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{eqntable}[1]{
  \begin{table}[H]
    \small
    \begin{tabularx}{\linewidth}{@{}>{$}l<{$} >{$}c<{$} >{$}c<{$} >{$}Y<{$} @{}}
      \toprule
      \BODY
      \bottomrule
    \end{tabularx}
    \caption{#1}
  \end{table}
}

% The label, since we're including twice
\newcommand*{\lab}{}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

% Table caption set up
\DeclareCaptionFormat{hfillunittypet}{\hfill#1#2#3\par}
\DeclareCaptionFont{mdit}{\mdseries\itshape}
\captionsetup[table]{
  justification=centering,
  font=bf,
  labelfont=mdit,
}

\title{A mechanization of semi-simplicial and semi-cubical sets in the calculus of inductive constructions}
\author{
  \textcolor{gray80}{Ramkumar Ramachandra} \\
  \itshape \textcolor{gray80}{Université Paris-Cité}
  \and
  \textcolor{gray80}{Hugo Herbelin} \\
  \itshape \textcolor{gray80}{IRIF/Inria Paris/Université Paris-Cité}
}
\date{}

\color{gray65}

\begin{document}
\thispagestyle{empty}
\maketitle
\begin{abstract}
  We present a parametricity-based construction of semi-simplicial sets and semi-cubical sets in indexed form, in the calculus of inductive constructions. The accompanying artifact is an axiom-less~\footnote{Technically speaking, we use some axioms related to functional extensionality, but the requirement arises only from our generalization to $\nu$-types; if $\nu$ is finite (say, unit type corresponding to augmented semi-simplicial types), this requirement vanishes.} Coq formalization that uses sophisticated rewriting techniques and pushes the boundaries of proof assistant technology.
\end{abstract}
\tableofcontents
\newpage

\section{Overture}

In the context of typed functional programming, Reynolds' parametricity~\cite{Reynolds72} interprets types as relations characterizing the observational equality of programs of this type. Parametricity can be iterated, and it has been noted that iterated Reynolds' parametricity has a cubical flavor~\cite{Johann17,Altenkirch15,Moulin16}. We obtain a \emph{unary} variant of Reynolds' \emph{binary} parametricity by using predicates instead of relations, in which case we obtain a form of (Kreisel) realizability~\cite{Bernardy12,Moulin16}. It has then been noted that iterated unary parametricity has an augmented simplicial flavor~\footnote{Observation from Hugo Moeneclaey}.

We exploit the connection between iterated unary parametricity and augmented simplicial sets and between binary parametricity and cubical sets to present a uniform construction of both semi-simplicial semi-cubical sets obtained by applying simple rules iterating parametricity.  In contrast to the presheaf presentation of semi-simplicial and semi-cubical sets, our uniform construction, which we call \emph{$\nu$-sets}, is \emph{indexed}. That is, instead of having the set of semi-simplices or semi-cubes in dimension $n+1$
\emph{fibered} over the set of semi-simplices or semi-cubes in dimension $n$, we consider families of semi-simplices and semi-cubes indexed over their faces.

\iffalse
  Our contribution is the following. We have modelled the core of semi-simplicial sets in a way that naturally generalizes to semi-cubical sets in type theory, and we call our generalization \emph{$\nu$-sets}. In contrast to the presheaf presentation of semi-cubical -based where the set of  that use a fibered representation, we use an indexed representation. Our work is, in principle axiom-free, although the accompanying artifact uses functional extensionality, and this requires disappears if $\nu$ is finite.
\fi

\begin{table}[H]
  \begin{tabularx}{\linewidth}{p{.3\linewidth}|p{.3\linewidth}|p{.3\linewidth}}
    \toprule
            & Set theory     & Type theory \\
    \graymidrule
    Fibered & \cite{Cohen16} &             \\
    \graymidrule
    Indexed &                & Our work    \\
    \bottomrule
  \end{tabularx}
\end{table}

The outline of the paper is as follows. First, we briefly describe semi-simplicial and semi-cubical sets, as it appears in mathematical literature, and our generalization to $\nu$-sets. We then proceed to explain our construction, with the help of diagrams. Before spelling out the details of our formalization in type-theoretic language, we have a section on reasoning in sets.

\section{Mathematical treatment of \texorpdfstring{$\nu$}{𝜈}-sets}
It is well-known that simplicial sets exist purely in the imagination of the mathematician, as every simplicial set has an infinite number of degenerate simplices. What we have formalized is \emph{semi-simplicial} sets, and \emph{semi-cubical} sets, which is to say that they are the usual simplicial sets and cubical sets, minus the degeneracies. Indeed, we plan to extend our work to do degeneracies in the future, but let us briefly explain the mathematical objects we have formalized.

\subsection{Augmented semi-simplicial sets}
We consider the category of augmented semi-simplices, which can be written in different ways, up to equivalence. We proceed to describe to combinatorial definition.
\begin{definition}[\DeltaPlus]
  The category of augmented semi-simplices is defined in terms of objects and morphisms:

  \begin{align*}
    \obj(\DeltaPlus) & := \Nat                                                                            \\
    \hom(p, n)       & := \{i_{p + 1}, \ldots, i_n \mid p < i_{p + 1} < i_{p + 2} < \ldots < i_n \leq n\} \\
    f \circ g        & := \text{concatenation of the sequences $f$ and $g$}
  \end{align*}
\end{definition}

\begin{example}[$\DeltaPlus^0$, $\DeltaPlus^1$]
  $\DeltaPlus^0$ can be drawn as:

  \begin{equation*}
    \begin{tikzcd}
      0 \arrow[r, dash] & 1
    \end{tikzcd}
  \end{equation*}

  $\DeltaPlus^1$ can be drawn as a filled triangle:

  \begin{equation*}
    \begin{tikzcd}
      & 2 \arrow[dr, dash] & \\
      0 \arrow[rr, dash]\arrow[ur, dash] && 1
    \end{tikzcd}
  \end{equation*}
\end{example}

\subsection{Semi-cubical sets}
\begin{definition}[\Cube{}]
  \begin{align*}
    \obj(\Cube{}) & := \Nat                                                                                                             \\
    \hom(p, n)    & := \{(i_{p + 1}, \epsilon_{p + 1}) \ldots, (i_n, \epsilon_n) \mid p < i_{p + 1} < i_{p + 2} < \ldots < i_n \leq n\}
  \end{align*}
\end{definition}

\begin{example}[$\Cube{0}$, $\Cube{1}$ and $\Cube{2}$]
  $\Cube{0}$ can be drawn as:

  \begin{equation*}
    \begin{tikzcd}
      0 \equiv 1
    \end{tikzcd}
  \end{equation*}

  $\Cube{1}$ can be drawn as:

  \begin{equation*}
    \begin{tikzcd}
      0 \arrow[r, dash] & 1
    \end{tikzcd}
  \end{equation*}


  and $\Cube{2}$ can be drawn as a filled square:


  \begin{equation*}
    \begin{tikzcd}
      (0, 1) \arrow[r, dash] & (1, 1) \arrow[d, dash] \\
      (0, 0) \arrow[u, dash] & (1, 0) \arrow[l, dash]
    \end{tikzcd}
  \end{equation*}
\end{example}

Here, $\I{n}$ serves the purpose of \sq{n}, but this change will cascade into other definitions. In view of defining a category \CSet, we will restrict the morphisms in \Cube{}.

\begin{definition}[\Cube{}]
  \begin{align*}
    \obj(\Cube{}) & := \I{n}                                           \\
    \mor(\Cube{}) & := \delta^\epsilon_i : \I{n + 1} \rightarrow \I{n}
  \end{align*}

  where $\delta^\epsilon_i$ must satisfy the corresponding face map condition:

  \begin{equation*}
    \delta^\epsilon_i \delta^\omega_j = \delta^\omega_{j - 1} \delta^\epsilon_i
  \end{equation*}

  where $\epsilon$ and $\omega$ correspond to opposite faces.
\end{definition}

\begin{definition}[\CSet]
  Just as in \SSet, we define semi-cubical sets as the functor category:

  \begin{equation*}
    \CSet := \Set^{\Cube{}^{op}}
  \end{equation*}
\end{definition}

Or, in terms of objects and morphisms:

\begin{definition}[$\CSet$ in terms of objects and morphisms]
  \begin{align*}
    \obj(\CSet) & := X_n                                                   \\
    \mor(\CSet) & := X_\lambda, \text{where $\lambda$ is \Cube{}-morphism}
  \end{align*}

  where we term $X_n$ as the $n$-cubex, and $X_\lambda$ as the ``face map'', defined similarly:

  \begin{align*}
    X_n       & := X(\I{n}), \text{where X is the semi-cubical set} \\
    X_\lambda & := X(\lambda)
  \end{align*}
\end{definition}

\begin{theorem}
  $\CSet$ does not admit degeneracies.
  \begin{proof}
    The reader is advised to refer to \cite{Antolini00} for the proof.
  \end{proof}
\end{theorem}

\subsection{Generalization to \texorpdfstring{$\nu$}{nu}}

\begin{table}[H]
  \begin{tabularx}{\linewidth}{p{.2\linewidth}|p{.4\linewidth}|p{.3\linewidth}}
    \toprule
    Value of $\nu$ & 1                     & 2                  \\
    \graymidrule
    Interpretation & Semi-simplicial types & Semi-cubical types \\
    \bottomrule
  \end{tabularx}
\end{table}

\section{Our construction}
In this section, we briefly explain the difference between the fibered and indexed representations, and illustrate our approach to the construction, with the help of some figures.

\subsection{Fibered versus indexed representation}
The fibered representation can be illustrated as:

\begin{equation*}
  \begin{tikzcd}
    X_0 : \U{} & X_1 : \U{} \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] & X_2 : \U{} \arrow[l, "\delta^\epsilon_1" description, shift left=6] \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] \arrow[l, "\delta^\omega_1" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}

The indexed representation can be illustrated as:

\begin{align*}
  X_0 & : \U{}                                                                                                              \\
  X_1 & : X_0 \times X_0 \rightarrow \U{}                                                                                   \\
  X_2 & : \forall a b c d, X_1 (a, b) \rightarrow X_1 (a, c) \rightarrow X_1 (b, d) \rightarrow X_1 (c, d) \rightarrow \U{} \\
  \ldots
\end{align*}

One way to obtain one construction from the other is via the \emph{Grothendieck construction}, although this is not relevant to our work.

\subsection{Iterated parametricity}
One step of parametricity can be seen as interpreting a point by a line. Iterating parametricity shall lead to map terms typed in a context with $n$ declarations of an axis as $n$-cubes. We shall interpret a
typing derivation with $n$ axis declarations as an $n$-cube of typing derivations in the target. For instance, a typing derivation with exactly one declaration of an axis will be interpreted by 3 typing derivations in the target, two of them typing points and the third one typing a proof, seen as a line, together with the fact that these two points are related (as in ordinary parametricity), while a typing derivation with $n$ declarations of an axis shall be interpreted as a $3^n$ derivations, split into $2^n$ derivations of points.

A full 2-cube is made of two full 1-cubes connected by a lifted 1-cube made of two lines connecting the former points and a square connecting the former lines:
{\scriptsize
\begin{equation*}
  \begin{array}{l}
    \begin{array}{lll}
      \mbox{\textit{squares}}     \\
      [3mm]\mbox{\textit{lines}}  \\
      [3mm]\mbox{\textit{points}} \\
      [1mm]\end{array}
    \framebox{$\begin{array}{lll}
                     \overbrace{\raisebox{0.05cm}{\framebox{$
                           \begin{array}{ll}
                  \raisebox{0cm}{\hspace{.5cm}{\layer[1][0]}}              & \framebox{$a_{0\unitpoint}$} \\
                  [1mm]\overbrace{\framebox{$a_{00}$}~\framebox{$a_{01}$}} &
                  \raisebox{-0.1cm}{\hspace{0.1cm}\filler[1][0]\!\!\!\!\!\!\!\!}
                  \\
                \end{array}
                         $}}~
                     {\raisebox{0.05cm}{\framebox{$
                           \begin{array}{ll}
                  \raisebox{0cm}{\hspace{.5cm}{\layer[1][0]}}              & \framebox{$a_{1\unitpoint}$} \\
                  [1mm]\overbrace{\framebox{$a_{10}$}~\framebox{$a_{11}$}} &
                  \raisebox{-0.1cm}{\filler[1][0]\!\!\!\!\!\!\!\!}
                \end{array}
                         $}}}}^{\layer[2][0]}~\stackrel{\raisebox{9.5mm}{$\framebox{$
                               \begin{array}{ll}
                      \raisebox{0cm}{\hspace{.5cm}{$\layer[2][1]$}}                                & \framebox{$a_{\unitpoint\unitpoint}$} \\
                      [1mm]\overbrace{\framebox{$a_{\unitpoint 0}$}~\framebox{$a_{\unitpoint 1}$}} &
                      \raisebox{-0.1cm}{ \hspace{0.1cm}\filler[2][1]\!\!\!\!\!\!\!\!}
                    \end{array}$}$}}
                     {\raisebox{-0.4cm}{\hspace{2.5cm}\filler[2][0]\!\!\!\!\!\!\!}}
                   \end{array}$}
    ~~~\parbox{2cm}{{\it additionally, each atomic component at dimension $n$ is a \filler[n][n]}} \\\\
    [-1mm]\qquad\qquad\quad~~
    \begin{tikzcd}[column sep=5.2em, row sep=1em]
      \phantom{\bullet}\arrow[r, leftrightarrow] & \phantom{\bullet}
    \end{tikzcd}
    \mbox{\framep[1][1]}
    \qquad
    \begin{tikzcd}[column sep=5.2em, row sep=1em]
      \phantom{\bullet}\arrow[r, leftrightarrow] & \phantom{\bullet}
    \end{tikzcd}
    \mbox{\framep[1][1]}                                                                           \\
    \qquad\qquad~~
    \begin{tikzcd}[column sep=32em, row sep=1em]
      \phantom{\bullet}\arrow[r, leftrightarrow] & \phantom{\bullet}
    \end{tikzcd}
    \mbox{\framep[2][1]}                                                                           \\
    \qquad\qquad~~
    \begin{tikzcd}[column sep=39em, row sep=1em]
      \phantom{\bullet}\arrow[r, leftrightarrow] & \phantom{\bullet}
    \end{tikzcd}
    \mbox{\framep[2][2]}                                                                           \\
  \end{array}
\end{equation*}
}

\section{Reasoning about sets in type theory}
Since proof irrelevance is an inherent part of set theory and first-order logic, and proof irrelevance is \emph{extensional} in type theory, we work in a universe known as \texttt{HSet}, which we describe shortly.

\subsection{Unicity of identity proofs}
UIP is a flavor of proof-irrelevance:

\begin{align*}
  \forall x y, \forall p q : x = y, p = q
\end{align*}

which is to say that any two proofs of \emph{equality} of the same two types are \emph{equal}. In other words, the proofs cannot be distinguished from one another.

In type theory, UIP can be proved on the unit type:

\begin{align*}
  \mathsf{eq\_refl}        & : \forall x, x = x                                                    \\
  \mathsf{UIP\_refl\_unit} & : \forall x : \unitpoint = \unitpoint, x = \mathsf{eq\_refl}          \\
  \mathsf{UIP\_refl\_bool} & : \forall b : \mathsf{bool}, \forall x : b = b, x = \mathsf{eq\_refl} \\
\end{align*}

\subsection{HSet}
\texttt{HSet} provides us a restricted setting of UIP, and our implementation of \texttt{HSet} is a straightforward packaging of two fields:

\begin{align*}
  \mathsf{Dom} & : \mathsf{Type}                                          \\
  \mathsf{UIP} & : \forall x y : \mathsf{Dom}, \forall p q : x = y, p = q
\end{align*}

In the \texttt{HSet} universe, three properties hold:

\begin{enumerate}
  \item[(i)] UIP holds on the unit type.
  \item[(ii)] UIP propagates to $\Sigma$-types.
  \item[(iii)] UIP propagates to $\Pi$-types, with some additional functional extensionality axioms.
\end{enumerate}

\section{Type-theoretic construction of \texorpdfstring{$\nu$}{nu}-sets}
% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{filler}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrfiller}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohfiller}[D, d]

% Now, we write the type theory bit, and input the abbreviated tables

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and filler
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and filler
% Drop the unviverse letter
\newcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\newcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\newcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and filler
% Keep only ε, ω; n, p; proposition on n and p
\newcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\newcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\newcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[][#2][#3][][][][][#9]}

The definition in \ref{tab:coind}, the coinductive limit, is dispatched over tables \ref{tab:core}, \ref{tab:frames}, \ref{tab:faces} and \ref{tab:coh}. They describe the structure of the underlying higher-dimensional relations on which fillers are built.

\renewcommand*{\lab}{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\newcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

We now describe \emph{bare truncated sets}: \emph{bare} because it can be seen as defining truncated $\nu$-sets without face maps, and \emph{truncated} because it is $n$-truncated.

\renewcommand*{\lab}{tab:core}
\input{tab-core.tex}

% Drop the universe letter in fullframe for all remaining tables
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[][#2][][][#3]}
\renewcommand*{\lab}{tab:frames}
\input{tab-frames.tex}

% Truncated sets, otherwise referred to as X
% Drop the universe letter for the third and fourth tables
\renewcommandx{\Xto}[3][3]{\X[][<#2][#3]}
\renewcommandx{\Xcomp}[3][3]{\X[][=#2][#3]}
\renewcommandx{\Xfrom}[3][3]{\X[][\geq#2][#3]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

In the way we have chosen to formlate these tables, there is, for instance, coherence condition $\cohf$ both sides of the equality in $\restrl$ and $\restrc$, to ensure that they are the same type.

For a given $n$, the coherence conditions evaluate to a reflexivity proof, so that the construction evaluates to an effective sequence of types of iterated relations not mentioning $\restrf$ nor $\cohf$ anymore.

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\renewcommand*{\lab}{tab:faces}
\input{tab-faces.tex}

% Restriction for frame, layer, and filler
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[][#2][#3][#4][#5][#6][#7]}

% Frame, layer, and filler
% Drop all arguments for coh table; they're not present in coind table.
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][][][][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][][][][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[][][][][#5]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

The proof of $\cohf$ require a higher-dimensional coherence condition which we obtain by working in \texttt{HSet}. If the proofs of the same equality were not equated, there would be a need for arbitrary many higher-dimensional coherences (see e.g.~\cite{Herbelin15} for a discussion on the de facto need for recursive higher-dimensional coherence conditions in formulating higher-dimensional structures in type theory).

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\newcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{tab:coh}
\input{tab-coh.tex}


where $\cohtwo{frame}$ is:

\begin{align*}
  \cohf[m][\omega][\theta][r][p][n][p][][d = {\restrf[m][\epsilon][q+2][n][p][][d = \d, D = \D]}, D = \D]\;\bullet         \\
  \ap (\restrf[m][\omega][r][n][p][][d = {\cohf[m][\epsilon][\theta][q+1][p][n][p][][d = \d, D = \D]}, D = \D]\;\bullet    \\
  \cohf[m][\epsilon][\omega][q][r][n][p][][d = {\restrf[m][\theta][p][n][p][][d = \d, D = \D]}, D = \D] =                  \\
  \ap (\restrf[m][\theta][p][n][p][][d = {\cohf[m][\epsilon][\omega][q+1][r+1][n][p][][d = \d, D = \D]}, D = \D])\;\bullet \\
  \cohf[m][\epsilon][\theta][q][p][n][p][][d = {\restrf[m][\omega][r+1][n][p][][d = \d, D = \D]}, D = \D]\;\bullet         \\
  \ap (\restrf[m][\epsilon][q][n][p][][d = {\cohf[m][\omega][\theta][r][p][n][p][][d = \d, D = \D]}, D = \D])
\end{align*}

\newpage
\section{Future work}

\newpage
\appendix
\section{Tables in full detail}
% Full tables in this section
%
% Clear the mask and label
\clearmask

% Keep all arguments for all macros
% Frame, layer, and filler
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[#1][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[#1][#2][#3][#4][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[#1][#2][#3][#4][#5]}
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

% Restriction for frame, layer, and filler
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[#1][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[#1][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{fulltab:coind}
\input{tab-coind.tex}
\renewcommand*{\lab}{fulltab:core}
\input{tab-core.tex}
\renewcommand*{\lab}{fulltab:frames}
\input{tab-frames.tex}

\begin{landscape}
  \renewcommand*{\lab}{fulltab:faces}
  \input{tab-faces.tex}
  \renewcommand*{\lab}{fulltab:coh}
  \input{tab-coh.tex}
\end{landscape}

\newpage
\begin{thebibliography}{10}
  \bibitem[Reynolds72]{Reynolds72}
  Reynolds, J. C. (1972, August). Definitional interpreters for higher-order programming languages. \emph{In Proceedings of the ACM annual conference-Volume 2} (pp. 717-740).

  \bibitem[Johann17]{Johann17}
  Johann, P., \& Sojakova, K. (2017). Cubical categories for higher-dimensional parametricity. \emph{arXiv preprint arXiv:1701.06244}.

  \bibitem[BernardyMoulin]{Bernardy12}
  Bernardy, J. P., \& Moulin, G. (2012, June). A computational interpretation of parametricity. \emph{In 2012 27th Annual IEEE Symposium on Logic in Computer Science} (pp. 135-144). IEEE.

  \bibitem[AltenkirchKaposi]{Altenkirch15}
  Altenkirch, Thorsten, and Ambrus Kaposi. "A nominal syntax for internal parametricity." \emph{TYPES 2015} (2015): 21.

  \bibitem[Moulin16]{Moulin16}
  Moulin, G. (2016). \emph{Internalizing parametricity.} Department of Computer Science and Engineering, Chalmers University of Technology.

  \bibitem[Bez]{Bezem14}
  Bezem, M., Coquand, T., \& Huber, S. (2014, July). A model of type theory in cubical sets. \emph{In 19th International Conference on Types for Proofs and Programs (TYPES 2013)} (Vol. 26, pp. 107-128). Wadern, Germany: Schloss Dagstuhl–Leibniz Zentrum fuer Informatik.

  \bibitem[CubAgda]{Vezzosi21}
  Vezzosi, A., Mörtberg, A., \& Abel, A. (2021). Cubical Agda: a dependently typed programming language with univalence and higher inductive types. \emph{Journal of Functional Programming, 31}.

  \bibitem[Takeuti–Gandy]{Barras15}
  Barras, B., Coquand, T., \& Huber, S. (2015). A generalization of the Takeuti–Gandy interpretation. \emph{Mathematical structures in computer science}, 25(5), 1071-1099.

  \bibitem[CCHM]{Cohen16}
  Cohen, C., Coquand, T., Huber, S., \& Mörtberg, A. (2016). Cubical type theory: a constructive interpretation of the univalence axiom. \emph{arXiv preprint arXiv:1611.02108}.

  \bibitem[Angiuli]{Angiuli17}
  Carlo Angiuli, Guillaume Brunerie, Thierry Coquand, Kuen-Bang Hou (Favonia), Robert Harper, \& Daniel R. Licata. \emph{arXiv preprint}.

  \bibitem[Fri]{Friedman08}
  Friedman, G. (2008). An elementary illustrated introduction to simplicial sets. \emph{arXiv preprint arXiv:0809.4221}.

  \bibitem[Rie]{Riehl11}
  Riehl, E. (2011). A leisurely introduction to simplicial sets. \emph{Unpublished expository article available online from the author's web page}.

  \bibitem[CubSet]{Antolini00}
  Antolini, R. (2000). Cubical structures, homotopy theory. \emph{Annali di Matematica pura ed applicata, 178}(1), 317-324.

  \bibitem[Her]{Herbelin15}
  Herbelin, H. (2015). A dependently-typed construction of semi-simplicial types. \emph{Mathematical Structures in Computer Science, 25}(5), 1116-1131.

  \bibitem[CoqInCoq]{Barras97}
  Barras, B., \& Werner, B. (1997). Coq in coq. \emph{Available on the WWW.}
\end{thebibliography}

\end{document}
