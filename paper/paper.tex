\documentclass[10pt]{art.cls/art}

\usepackage{multirow, float, tabularx, environ, booktabs, setspace, makecell, caption, art.cls/joinargs, colortbl, pdflscape}
\usepackage[prefix=bonak]{art.cls/xkeymask}
\usepackage[skip=0.4em]{parskip}
\usetikzlibrary{patterns}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{filler}{D}{(#1)}
\define@cmdkey[bonak]{filler}{E}{(#1)}
\define@cmdkey[bonak]{filler}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrfiller}{D}{(#1)}
\define@cmdkey[bonak]{restrfiller}{E}{(#1)}
\define@cmdkey[bonak]{restrfiller}{d}{(#1)}
\define@cmdkey[bonak]{restrfiller}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohfiller}{D}{(#1)}
\define@cmdkey[bonak]{cohfiller}{E}{(#1)}
\define@cmdkey[bonak]{cohfiller}{d}{(#1)}
\define@cmdkey[bonak]{cohfiller}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \ensuremath{{\color{carolina}{\nu\textsf{Set}}}_{#1}^{#2}}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and filler: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs{}[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and filler: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4]}^{\joinargs{}[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

% Coherence conditions for frame, layer, and filler: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4][#5][#6]}^{\joinargs{}[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \mathsf{\color{indian-yellow}{#1}}
    \joinargs{,}[#2][#3][#4][#5][#6][#7]}^{\joinargs{}[#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}{\ensuremath{\boldsymbol{\square}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommandx{\U}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HSet}}_{#1}}}

% The unit type
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\unitpoint}{\ensuremath{\ast}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\eqHSet}{\ensuremath{\equiv_{\mathit{HSet}}}}
\newcommand{\reflHSet}{\ensuremath{\mathsf{refl}_{\mathit{HSet}}}}

% Some abbreviations
\newcommand{\tl}{\ensuremath{\mathsf{tl}}}
\newcommand{\hd}{\ensuremath{\mathsf{hd}}}
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\newcommand{\ap}{\mathsf{ap}}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\Dom}{\textsf{Dom}}
\newcommand{\UIP}{\textsf{UIP}}

% These are renewed in tables, but let's define them now for in-document
% typesetting
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\filler}[2][1,2]{\prim{filler}[][#1][#2][][]}
\newcommandx{\restrf}[3][1,2,3]{\restr{frame}[][#3][][#1][#2][][]}
\newcommandx{\restrl}[3][1,2,3]{\restr{layer}[][#3][][#1][#2][][]}
\newcommandx{\restrc}[3][1,2,3]{\restr{filler}[][#3][][#1][#2][][]}
\newcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\newcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\newcommandx{\cohc}{\coh{filler}[][][][][][][][]}
\newcommandx{\fullframe}[1][1]{\prim{fullframe}[][#1][][][]}

% Kerning for star
\newcommand{\kstar}{{\star}}

% The eqntable environment, displaying the various
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{eqntable}[1]{
  \begin{table}[H]
    \small
    \begin{tabularx}{\linewidth}{@{}>{$}l<{$} >{$}c<{$} >{$}c<{$} >{$}Y<{$} @{}}
      \toprule
      \BODY
      \bottomrule
    \end{tabularx}
    \caption{#1}
  \end{table}
}

% The label, since we're including twice
\newcommand*{\lab}{}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

% Table caption set up
\DeclareCaptionFormat{hfillunittypet}{\hfill#1#2#3\par}
\DeclareCaptionFont{mdit}{\mdseries\itshape}
\captionsetup[table]{
  justification=centering,
  font=bf,
  labelfont=mdit,
}

\title{A mechanization of semi-simplicial and semi-cubical sets in the calculus of inductive constructions}
\author{
  \textcolor{gray80}{Ramkumar Ramachandra} \\
  \itshape \textcolor{gray80}{UniversitÃ© Paris-CitÃ©}
  \and
  \textcolor{gray80}{Hugo Herbelin} \\
  \itshape \textcolor{gray80}{IRIF/Inria Paris/UniversitÃ© Paris-CitÃ©}
}
\date{}

\color{gray65}

\begin{document}
\maketitle
\begin{abstract}
  We present a parametricity-based construction of semi-simplicial sets and semi-cubical sets in indexed form, in the calculus of inductive constructions. The accompanying artifact is an axiom-less~\footnote{Technically speaking, we use some axioms related to functional extensionality, but the requirement arises only from our generalization to $\nu$-types; if $\nu$ is finite (say, unit type corresponding to augmented semi-simplicial types), this requirement vanishes.} Coq formalization that uses sophisticated rewriting techniques and pushes the boundaries of proof assistant technology.
\end{abstract}
\tableofcontents
\newpage

\section{Overture}
In the context of typed functional programming, Reynolds' parametricity~\cite{reynolds72} interprets types as relations characterizing the observational equality of programs of this type. Parametricity can be iterated, and it has been noted that iterated Reynolds' parametricity has a cubical flavor~\cite{johann17,altenkirch15,moulin16}. We obtain a \emph{unary} variant of Reynolds' \emph{binary} parametricity by using predicates instead of relations, in which case we obtain a form of (Kreisel) realizability~\cite{bernardy12,moulin16}. It has then been noted that iterated unary parametricity has an augmented simplicial flavor~\footnote{Observation from Hugo Moeneclaey}.

We exploit the connection between iterated unary parametricity and augmented simplicial sets, and between iterated binary parametricity and cubical sets to present a uniform construction of both semi-simplicial semi-cubical sets obtained by applying simple rules iterating parametricity.  In contrast to the presheaf presentation of semi-simplicial and semi-cubical sets, our uniform construction, which we call \emph{$\nu$-sets}, is \emph{indexed}. That is, instead of having the set of semi-simplices or semi-cubes in dimension $n+1$
\emph{fibered} over the set of semi-simplices or semi-cubes in dimension $n$, we consider families of semi-simplices and semi-cubes indexed over their faces.

\begin{table}[H]
  \begin{tabularx}{\linewidth}{p{.3\linewidth}|p{.3\linewidth}|p{.3\linewidth}}
    \toprule
            & Set theory  & Type theory \\
    \graymidrule
    Fibered & \cite{cchm} &             \\
    \graymidrule
    Indexed &             & Our work    \\
    \bottomrule
  \end{tabularx}
\end{table}

The outline of the paper is as follows. First, we briefly describe semi-simplicial and semi-cubical sets, and our generalization to $\nu$-sets. We then proceed to explain our construction, with the help of diagrams. Before spelling out the details of our formalization in type-theoretic language, we have a section on reasoning in sets.

\section{Mathematical treatment of \texorpdfstring{$\nu$}{ðœˆ}-sets}
It is well-known that simplicial sets exist purely in the imagination of the mathematician, as every simplicial set has an infinite number of degenerate simplices. What we have formalized is \emph{augmented semi-simplicial} sets, and \emph{semi-cubical} sets. We will proceed to explain the mathematical objects we have formalized.

\subsection{Augmented semi-simplicial sets}
Augmented semi-simplicial sets are defined similarly to semi-simplicial sets, except that the connected components are additionally dependent on a ``color''. Conversely, semi-simplicial sets can be seen as augmented semi-simplicial sets over a singleton set of colors.

Let us associate dimension $0$ to colors; then, points are dimension $1$, lines are dimension $2$, and so on. There is hence a shift by one when compared to semi-simplicial sets. We can then draw augmented semi-simplicial sets like semi-simplicial sets, except for this shift by one.

While ordinary semi-simplicial sets are presheaves over the semi-simplex category $\hat{\Delta}$, augmented semi-simplicial sets are presheaves over, what we will define as $\DeltaPlus$. There are different ways to define $\DeltaPlus$, upto equivalence, and we use a combinatorial definition; the reason for our choice is that this definition has a straightforward extension to semi-cubical sets.

\begin{notation}[Sequences of integers]
  We write $\{i_1, \ldots i_n\}$ for sequences of integers. In particular, the empty sequence is written $\{\}$.
\end{notation}

We introduce two additional notations for working with sequences of integers.

\begin{notation}[::]
  We define $i :: \{j_1, \ldots, j_n\}$ to be $\{i, j_1, \ldots, j_n\}$.
\end{notation}

\begin{notation}[$\uparrow$]
  Let us write $\uparrow \{i_1, \ldots, i_n\}$ to denote $\{i_1 + 1, \ldots, i_n + 1\}$.
\end{notation}

\begin{definition}[\DeltaPlus]
  The category of augmented semi-simplices is defined in terms of objects, morphisms, composition, and identity.

  \begin{align*}
    \obj(\DeltaPlus) & := \Nat                                                                    \\
    \hom(p, n)       & := \{\{i_{p + 1}, \ldots, i_n\} \mid 0 < i_{p + 1} < \ldots < i_n \leq n\} \\
    g \circ f        & :=
    \begin{cases}
      g                          & \text{if f = \{\}}                                          \\
      f                          & \text{if g = \{\}}                                          \\
      b :: (g \circ f')          & \text{if $g = (a :: g')$, $f = (b :: f')$, with $b < a$}    \\
      a :: (g' \circ \uparrow f) & \text{if $g = (a :: g')$, $f = (b :: f')$, with $b \geq a$} \\
    \end{cases}      \\
    \id              & := \{\}
  \end{align*}

  Evidently, $\id$ is neutral. Further, composition can be shown to be associative.
\end{definition}

\begin{definition}[Alternative definition of $\DeltaPlus$]
  \begin{align*}
    \obj(\DeltaPlus) & := \Nat                                                                     \\
    \hom(p, n)       & := \{l \in \{0, \kstar\}^n \mid \text{number of $\kstar$ in l = p}\}        \\
    g \circ f        & :=
    \begin{cases}
      f                  & \text{if $g = \{\}$}                                                      \\
      0 :: (g' \circ f)  & \text{if $g = (0 :: g')$}                                                 \\
      a :: (g' \circ f') & \text{if $g = (\star :: g')$, $f = (a :: f')$, where $a = 0$ or $\kstar$} \\
    \end{cases} \\
    \id              & := \{\kstar, \ldots, \kstar\} \text{ $n$ times}
  \end{align*}

  Note that, if $g \circ f$ is well-defined, then the length of $f$ is less than that of $g$. It can be shown that composition is associative and that $\id$ is neutral.
\end{definition}

\begin{definition}[$\Set_{\DeltaPlus}$]
  We define the category of augmented semi-simplicial sets as the functor category:

  \begin{equation*}
    \Set_{\DeltaPlus} := \Set^{\DeltaPlus^{\mathsf{op}}}
  \end{equation*}
\end{definition}

\begin{definition}[$\DeltaPlus^n$]
  The standard augmented $n$-semi-simplex $\DeltaPlus^n$ is defined as:

  \begin{align*}
    \DeltaPlus^n    & : \Set_{\DeltaPlus}      \\
    \DeltaPlus^n(p) & := \Hom(p, n)            \\
    \DeltaPlus^n(f) & := \lambda g . g \circ f
  \end{align*}
\end{definition}

The standard augmented $0$-semi-simplex is a singleton of one color. Standard augmented $n$-semi-simplices have a geometric interpretation, and we illustrate them for dimensions $1$, $2$, and $3$.

\begin{example}[$\DeltaPlus^1$]
  In dimension $1$, the standard augmented semi-simplex can be pictured as a point, colored black, corresponding to the unique morphism in $\Hom(0, 1)$. This point is the identity in $\Hom(1, 1)$; it is hence shown as a singleton $\kstar$:

  \begin{equation*}
    \begin{tikzcd}
      \kstar
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\DeltaPlus^2$]
  In dimension $2$, the standard augmented semi-simplex is drawn as two points, given by $\Hom(1, 2)$, along with a line connecting them, given by $\Hom(2, 2)$. We use the color black to denote the unique morphims in $\Hom(0, 1)$ and $\Hom(0, 2)$.

  \begin{equation*}
    \begin{tikzcd}
      \kstar0 \arrow[r, dash, "\kstar\kstar"] & 0\kstar
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\DeltaPlus^3$]
  $\DeltaPlus^3$ is drawn as three points, given by $\Hom(1, 3)$, three lines connecting them, given by $\Hom(2, 3)$, and a filler given by $\Hom(3, 3)$.

  \begin{equation*}
    \begin{tikzcd}
      & |[alias=F]|00\kstar \arrow[ddr, dash, "0\kstar\kstar"] & \\\\
      \kstar00 \arrow[rr, dash, "\kstar\kstar0"{name=T, below}]\arrow[uur, dash, "\kstar0\kstar"] && 0\kstar0 \\
      \arrow[rightarrow, from=F, to=T, phantom, "\kstar\kstar\kstar" description]
    \end{tikzcd}
  \end{equation*}
\end{example}

\subsection{Semi-cubical sets}
\begin{definition}[\Cube]
  $\Cube$ is defined similarly to $\DeltaPlus$, except that we take sequences of $L$, $R$ and $\star$, instead of sequences of $0$ and $\kstar$. We use $L$ and $R$ to indicate opposite faces of a cube.

  \begin{align*}
    \obj(\Cube) & := \Nat                                                                                \\
    \hom(p, n)  & := \{l \in \{L, R, \kstar\}^n \mid \text{number of $\kstar$ in $l = p$}\}              \\
    g \circ f   & :=
    \begin{cases}
      f                  & \text{if $g = \{\}$}                                                            \\
      a :: (g' \circ f)  & \text{if $g = (a :: g')$}, \text{where $a = L$ or $R$}                          \\
      a :: (g' \circ f') & \text{if $g = (\star :: g')$, $f = (a :: f')$, where $a = L$, $R$, or $\kstar$} \\
    \end{cases} \\
    \id         & := \{\kstar, \ldots, \kstar\} \text{ $n$ times}
  \end{align*}

  Again, if $g \circ f$ is well-defined, then the length of $f$ is less than that of $g$. It can be shown that composition is associative and that $\id$ is neutral.
\end{definition}

\begin{definition}[\CSet]
  We define the category of semi-cubical sets as the functor category:

  \begin{equation*}
    \CSet := \Set^{\op{\Cube}}
  \end{equation*}
\end{definition}

\begin{definition}[$\Cube^n$]
  The standard semi-cube $\Cube^n$ is defined as:

  \begin{align*}
    \Cube^n    & : \CSet                  \\
    \Cube^n(p) & := \Hom(p, n)            \\
    \Cube^n(f) & := \lambda g . g \circ f
  \end{align*}
\end{definition}

Standard $n$-semi-cubes have a geometric interpretion, which we illustrate for dimensions $0$, $1$, and $2$.

\begin{example}[$\Cube^0$]
  $\Cube^0$ is $\Hom(0, 0)$, or the singleton set of the empty sequence:

  \begin{equation*}
    \begin{tikzcd}
      \{\}
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\Cube^1$]
  $\Cube^1$ is two points, given by $\Hom(0, 1)$ and a line, given by $\Hom(1, 1)$:

  \begin{equation*}
    \begin{tikzcd}
      L \arrow[r, "\kstar", dash] & R
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\Cube^2$]
  $\Cube^2$ is four points, given by $\Hom(0, 2)$, four lines connecting the four points, given by $\Hom(1, 2)$, and a filler, given by $\Hom(2, 2)$:

  \begin{equation*}
    \begin{tikzcd}
      LR \arrow[r, dash, "\kstar R"{name=F}] \arrow[d, dash, "L\kstar" left] & RR \arrow[d, dash, "R\kstar"] \\
      LL \arrow[r, dash, "\kstar L"{name=T, below}] & RL \\
      \arrow[rightarrow, from=F, to=T, phantom, "\kstar\kstar" description]
    \end{tikzcd}
  \end{equation*}
\end{example}

\subsection{Generalization to \texorpdfstring{$\nu$}{Î½}-sets}
Let us call $\nu$-sets, the straightforward generalization of augmented semi-simplicial sets and semi-cubical sets to an arbitrary cardinal, where morphisms are sequences of elements of an arbitrary set $\nu$, extended with $\kstar$. Then, we observe:

\begin{table}[H]
  \begin{tabularx}{\linewidth}{p{.2\linewidth}|p{.4\linewidth}|p{.3\linewidth}}
    \toprule
    Value of $\nu$ & 1                               & 2                  \\
    \graymidrule
    Interpretation & Augmented semi-simplicial types & Semi-cubical types \\
    \bottomrule
  \end{tabularx}
\end{table}

\section{Our construction}
In this section, we briefly explain the difference between the fibered and indexed representations, and illustrate our approach to the construction, with the help of some figures.

\subsection{Homotopy type theory}
Homotopy type theory (HoTT) is a logical foundation based on Martin-LÃ¶f type theory and the univalence axiom~\cite{hottbook}. HoTT is based on the notion of a basic Type, and the notion of sets can be recovered as \U, where $\U$ is a straightforward packaging of two fields:

\begin{align*}
  \Dom & : \Type                                          \\
  \UIP & : \forall x y : \Dom, \forall p q : x = y, p = q
\end{align*}

In the $\U$ universe, three properties hold:

\begin{enumerate}
  \item[(i)] UIP holds on the unit type.
  \item[(ii)] UIP propagates to $\Sigma$-types.
  \item[(iii)] UIP propagates to $\Pi$-types, with some additional functional extensionality axioms.
\end{enumerate}

$\U$ provides us a form of unicity of identity of proofs (UIP), which is a form of proof irrelevance:

\begin{align*}
  \forall x y, \forall p q : x = y, p = q
\end{align*}

which is to say that any two proofs of \emph{equality} of the same two types are \emph{equal}. In other words, the proofs cannot be distinguished from one another.

An equivalent defintion of UIP is given by \textsf{UIP\_refl}:

\begin{align*}
  \textsf{UIP\_refl} & : \forall x, \forall p : x = x, p = \textsf{eq\_refl } x
\end{align*}

In type theory, UIP can be proved on the unit type and bool type:

\begin{align*}
  \textsf{eq\_refl}        & : \forall x, x = x                                                    \\
  \textsf{UIP\_refl\_unit} & : \forall u : \textsf{unit}, \forall x : u = u, x = \textsf{eq\_refl} \\
  \textsf{UIP\_refl\_bool} & : \forall b : \textsf{bool}, \forall x : b = b, x = \textsf{eq\_refl} \\
\end{align*}

\subsection{Fibered versus indexed representation}
It is well-known in set theory, that families of small sets can be represented in a fibered or indexed way. In the fibered way, a family over $T$ is represented a pair of a set $S$, and a function $S \rightarrow T$. The function classifies the original set into fibers. In contrast, in the indexed way, a family over $T$ is represented as a functional relation with domain $T$, which itself, by replacement axiom, is a set.

In category theory, the correspondence between fibered and indexed way, manifests as the correspondence between Grothendieck fibrations and pseudofunctors, of which a particular instance is the correspondence between discrete fibrations and presheaves, or even between discrete fibrations over sets and families of sets.

The latter correspondence can be expressed in HoTT, for $T: \Type$, as an equivalence between $\Sigma S: \Type\;.\;S \rightarrow T$ and $T \rightarrow \Type$, which can be proved using univalence. This correspondence also holds on \U, for $T: \U$:

\begin{equation*}
  \Sigma S: \U\;.\;S\rightarrow T \simeq T \rightarrow \U
\end{equation*}

Let us now come back to cubical sets. A cubical set can be represented as a sequence of fibrations, together with appropriate coherence conditions.

\begin{equation*}
  \begin{tikzcd}
    X_0 : \U & X_1 : \U \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] & X_2 : \U \arrow[l, "\delta^\epsilon_1" description, shift left=6] \arrow[l, "\delta^\epsilon_0" description, shift left=2] \arrow[l, "\delta^\omega_0" description, shift right=2] \arrow[l, "\delta^\omega_1" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}

We can iteratively apply the above correspondence to obtain an indexed representation of cubical sets.

\begin{align*}
  X_0 & : \U                                                                                                              \\
  X_1 & : X_0 \times X_0 \rightarrow \U                                                                                   \\
  X_2 & : \forall a b c d, X_1 (a, b) \rightarrow X_1 (a, c) \rightarrow X_1 (b, d) \rightarrow X_1 (c, d) \rightarrow \U \\
  \ldots
\end{align*}

The focus of our work has been to formally define such an indexed presentation of not just semi-cubical, but more generally, $\nu$-sets.

\subsection{Intuition for our formal construction}
\begin{notation}[\Sigma]
  In the prose that follows, we assume the existence of $\Sigma$-types with projections $\hd$ and $\tl$.
\end{notation}

To assign $X_0, X_1, X_2, \ldots$ in the above indexed representation types, we need to exhibit a recursive definition over our building blocks, which we will call $\framep$, $\layer$, and $\filler$. A $\framep$ is a boundary of a standard form (simplex, cube, etc.), which we decompose into $\layer$, and a $\filler$ is a filled $\framep$.

We assign every $X_n$ the type $\fullframe[n] \rightarrow \U$ uniformly, applying the isomorphism between $A \rightarrow B \rightarrow C$ and $A \times B \rightarrow C$, or between $\Pi a : A, (B a \rightarrow C)$ and $(\Sigma a : A, B a) \rightarrow C$. Let us illustrate how we build $\fullframe[n]$ by refining types of $X_0, X_1, \ldots, X_{n - 1}$ so that they have the form $\fullframe[n] \rightarrow \U$. To begin, let us set $\fullframe[0] = \unittype$, so that the type $\U$ of $X_0$ can be equivalently formulated as $\unittype \rightarrow \U$. Each $\fullframe[n]$ is made of $n$-layers, written $\layer[n][p]$ with $p < n$, initalized with the $\unittype$ type. Then, $X_1$ is made of one layer, so that it can be written as a $\Sigma$-type of an inhabitant of the $\unittype$ and $\layer[1][0]$. The rest of the construction follows.

\begin{equation*}
  \begin{array}{ll}
    X_0                                : \underbrace{\unittype}_{\framep[0][0]}                                                    \rightarrow \U \\
    X_1                                : \underbrace{\Sigma \unitpoint: \unittype. \underbrace{\left(
    \begin{array}{c}
        \underbrace{X_0(\unitpoint)}_{\filler[0][0]}
        \\ \times \\
        \underbrace{X_0(\unitpoint)}_{\filler[0][0]}
      \end{array}\right)}_{\layer[1][0]}}_{\framep[1][1]} \rightarrow \U                                                                            \\
    X_2                                : \underbrace{\Sigma a: \underbrace{\left(\Sigma \unitpoint: \unittype. \underbrace{\left(
        \begin{array}{c}
          \underbrace{\Sigma b: \left(
          \hspace{-0.4em}\begin{array}{c}
                           X_0(\unitpoint)
                           \\ \times \\
                           X_0(\unitpoint)
                         \end{array}\hspace{-0.4em}
          \right).\; \underbrace{X_1 \underbrace{(\unitpoint, b)}_{\restrf[2][0][L]}}_{\filler[1][1]}}_{\filler[1][0]}
          \\ \times \\
          \underbrace{\Sigma b: \left(
          \hspace{-0.4em}\begin{array}{c}
                           X_0(\unitpoint)
                           \\ \times \\
                           X_0(\unitpoint)
                         \end{array}\hspace{-0.4em}
          \right).\; \underbrace{X_1 \underbrace{(\unitpoint, b)}_{\restrf[2][0][R]}}_{\filler[1][1]}}_{\filler[1][0]}
        \end{array}
        \right)}_{\layer[2][0]}\right)}_{\framep[2][1]}.\underbrace{\left(
      \begin{array}{c}
        \underbrace{X_1 \underbrace{\left(a.\hd, \left(
            \hspace{-0.4em}\begin{array}{c}
                             a.\tl.L.\hd.L, \\
                             a.\tl.R.\hd.L
                           \end{array}\hspace{-0.4em}
            \right)\right)}_{\restrf[2][1][L]}}_{\filler[1][1]}
        \\ \times \\
        \underbrace{X_1 \underbrace{\left(a.\hd, \left(
            \hspace{-0.4em}\begin{array}{c}
                             a.\tl.L.\hd.R, \\
                             a.\tl.R.\hd.R
                           \end{array}\hspace{-0.4em}
            \right)\right)}_{\restrf[2][1][R]}}_{\filler[1][1]}
      \end{array}
      \right)}_{\layer[2][1]}}_{\framep[2][2]}
    \rightarrow \U                                                                                                                                \\
    \ldots
  \end{array}
\end{equation*}

A $\fullframe[n]$ is a sequence of $\layer[n][p]$, and we write $\framep[n][p]$ for the $p$ first layers of a $\fullframe[n]$, so that $\fullframe[n]$ is a $\framep[n][n]$. Let us illustrate the construction of frames in dimension $3$, and $\nu = 2$:

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=2]
    \draw[spanish-blue, fill=spanish-blue] (0, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- (0, 0);
    \draw[spanish-blue, fill=spanish-blue, nearly transparent] (0.6, 1) -- (0.6, 1.6) -- (1.6, 1.6) -- (1.6, 0.6) -- (1, 0.6);
  \end{tikzpicture}
  \;\;
  \begin{tikzpicture}[scale=2]
    \draw[spanish-blue, fill=spanish-blue] (0, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- (0, 0);
    \draw[spanish-blue, fill=spanish-blue, nearly transparent] (0.6, 1) -- (0.6, 1.6) -- (1.6, 1.6) -- (1.6, 0.6) -- (1.0, 0.6);
    \draw[raspeberry, pattern=dots] (1.1, 1.1) -- (1.5, 1.5) -- (1.5, 0.5) -- (1.1, 0.1) -- (1.1, 1.1);
    \draw[raspeberry] (1.3, 1.3) -- (1.3, 0.3);
    \draw[raspeberry, pattern=dots] (0.1, 1.1) -- (0.5, 1.5) -- (0.5, 1.1);
    \draw[raspeberry] (0.3, 1.3) -- (0.3, 1.1);
  \end{tikzpicture}
  \;\;
  \begin{tikzpicture}[scale=2]
    \draw[spanish-blue, fill=spanish-blue] (0, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- (0, 0);
    \draw[spanish-blue, fill=spanish-blue, nearly transparent] (0.6, 1) -- (0.6, 1.6) -- (1.6, 1.6) -- (1.6, 0.6) -- (1.0, 0.6);
    \draw[raspeberry, pattern=dots] (1.1, 1.1) -- (1.5, 1.5) -- (1.5, 0.5) -- (1.1, 0.1) -- (1.1, 1.1);
    \draw[raspeberry] (1.3, 1.3) -- (1.3, 0.3);
    \draw[raspeberry] (0.1, 1.1) -- (0.5, 1.5);
    \draw[russian-green, pattern=dots] (0.2, 1.1) -- (1.0, 1.1) -- (1.4, 1.5) -- (0.6, 1.5) -- (0.2, 1.1);
    \filldraw[russian-green] (0.8, 1.3) circle (0.6pt);
  \end{tikzpicture}
\end{figure}

The figure on the left is $\framep[3][1]$, in the middle is $\framep[3][2]$, and on the right is $\framep[3][3]$. Further, $\framep[3][1]$ is made of one layer, $\layer[3][0]$, shown in blue, $\framep[3][2]$ is made of one additional layer, $\layer[3][1]$, shown in red, $\framep[3][3]$ is made of one more layer, $\layer[3][2]$, shown in green. In general, a $\layer[n][p]$ is a product of $\nu$ $\filler[n - 1][p]$. Then, a $\filler[n][p]$ is an $n$-dimensional object obtained by stretching a $(n - p)$-dimensional frame in $p$ directions. For instance, each of the two $\filler[2][0]$ of $\layer[3][0]$ is a filled blue square, each of the two $\filler[2][1]$ of $\layer[3][1]$ is the line shown in red, stretched into a square, and each of the two $\filler[2][2]$ of $\layer[3][2]$ is a point shown in green, stretched into a square. Note that a filler, which extends a frame with an element depending on it, shown as an element of $X_n$ below. As filler extends a frame, it also has layer components, but the layers are associated on the right that is opposite to the way they're associated in frames.

\begin{align*}
  \framep[n][p] & \defeq \Sigma a_n : (\ldots (\Sigma \unitpoint : \unittype .\; \layer[n][0]) \ldots) .\; \layer[n][p] \\
  \filler[n][p] & \defeq \Sigma l_p : \layer[n][p] . (\ldots (\Sigma l_n : \layer[n][n - 1] .\; X_n) \ldots)
\end{align*}

Up to now, we haven't paid attention to the fact that we have a dependent type, shown as a $\Sigma$. Let us be more precise about this requirement. First, $\fullframe[n]$ depends on all $X_i$ upto $n - 1$. So, we need to package up $X_i$, for $i < n$, into a type, which we call $\X[][<n][]$. This allows us to give the type $\X[][<n][] \rightarrow \U$ to $\fullframe[n]$. Then, for $D: \X[][<n][]$, representing an initial prefix of $X_0, X_1, \ldots X_{n - 1}$, the indexed set $X_n$ has type $\fullframe[n](D) \rightarrow \U$. Thus, $\framep[n][p]$, $\layer[n][p]$ and $\filler[n][p]$ also depend on $D$. We can then refine the previous equation by showing the dependencies on $D$. In particular, $X_n$ is just $D.\tl$.

\begin{align*}
  \framep[n][p](D) & \defeq \Sigma a_n : (\ldots (\Sigma \unitpoint : \unittype .\; \layer[n][0](D)) \ldots) .\; \layer[n][p](D) \\
  \filler[n][p](D) & \defeq \Sigma l_p : \layer[n][p](D) . (\ldots (\Sigma l_n : \layer[n][n - 1](D) .\; D.\tl) \ldots)
\end{align*}

So far, we haven't paid attention to the fact that each addition of a layer has to be glued onto the border of the previous layer. So, each $\layer[n][p]$ has to depend on $\layer[n][p - 1]$. We also need a way to characterize the border of a filler of a layer, and this is $\restrf[n][p][\epsilon]$, for all $\epsilon < \nu$. For instance, each of the $\filler[2][1]$, shown as the red boxes, is laid on the borders of the blue boxes, and hence needs to depend on $\framep[3][1]$. The left and right borders of the two blue boxes are extracted as $\restrf[2][1][L](D)(d)$ and $\restrf[2][1][R](D)(d)$. We can then refine the previous equation by showing the dependencies on $d$.

\begin{align*}
  \framep[n][p](D)    & \defeq \Sigma d : (\ldots (\Sigma \unitpoint : \unittype .\; \layer[n][0](D)(\unitpoint)) \ldots) .\; \layer[n][p](D)(d)                              \\
  \filler[n][p](D)(d) & \defeq \Sigma l_p : \layer[n][p](D)(d) . (\ldots (\Sigma l_n : \layer[n][n - 1](D)(d, l_p, \ldots, l_{n - 1}) .\; D.\tl(d, l_p, \ldots, l_n)) \ldots) \\
  \text{where}\;      & (d, l_p, \ldots, l_q) \text{ abbreviates } ((\ldots(d, l_p), \ldots), l_q)
\end{align*}

Let us recall that a layer is made of two fillers. This can now be made precise as illustrated below.

\begin{align*}
  \layer[n][p](D)(d) & \defeq \filler[n-1][p](D.\hd)(\restrf[n][p][L](d)) \times \filler[n-1][p](D.\hd)(\restrf[n][p][R](d))
\end{align*}

We now define $\restrf[n][p][\epsilon](d)$ by recursion on the structure of a frame $d$, which necessitates definitions of $\restrl[n][p][\epsilon](d)(l)$ and $\restrc[n][p][\epsilon](d)(c)$, for $l$ a layer and $c$ a filler. The key case is $\restrc[n][n-1][\epsilon](d)(c)$, where $c$, a $\filler[n][n-1]$, has necessarily the form of $((c_L, c_R), \_)$: $\restrc[n][n-1][L]$ picks out $c_L$, a $\filler[n][n]$, $\restrc[n][n-1][R]$ picks out the $c_R$, also a $\filler[n][n]$, and $\_$ is discarded. There is one more difficulty, which we illustrate by writing down expected and actual types.

Given $c_\omega$ of type

\begin{align*}
  c_\omega & : \filler[n-1][p](D.\hd)(\restrf[n-1][p][\omega](d))
\end{align*}

$\restrl[n][p][\epsilon](d)(c_L, c_R)$ produces a layer, of which $\omega$-component has the type

\begin{equation*}
  \filler[n-2][p](D.\hd.\hd)(\restrf[n-1][p][\epsilon](\restrf[n][p][\omega](d)))
\end{equation*}

while we expect a term of type

\begin{equation*}
  \filler[n-2][p](D.\hd.\hd)(\restrf[n-1][p][\omega](\restrf[n][p][\epsilon](d)))
\end{equation*}

Hence, we need a coherence condition to commute the $\restrf[n][p][\epsilon]$ and $\restrf[n][p][\omega]$. Coherence conditions similar to this necessitate, what are shown as, $\cohf$, $\cohl$ and $\cohc$ in tables in the next section.

\subsection{Formal construction of \texorpdfstring{$\nu$}{nu}-sets}
% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{filler}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrfiller}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohfiller}[D, d]

% Now, we write the type theory bit, and input the abbreviated tables

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and filler
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and filler
% Drop the unviverse letter
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and filler
% Keep only Îµ, Ï‰; n, p; proposition on n and p
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[][#2][#3][][][][][#9]}

The definition in \ref{tab:coind}, the coinductive limit, is dispatched over tables \ref{tab:core}, \ref{tab:frames}, \ref{tab:faces} and \ref{tab:coh}. They describe the structure of the underlying higher-dimensional relations on which fillers are built.

\renewcommand*{\lab}{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

We now describe \emph{bare truncated sets}: \emph{bare} because it can be seen as defining truncated $\nu$-sets without face maps, and \emph{truncated} because it is $n$-truncated.

\renewcommand*{\lab}{tab:core}
\input{tab-core.tex}

% Drop the universe letter in fullframe for all remaining tables
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[][#2][][][#3]}
\renewcommand*{\lab}{tab:frames}
\input{tab-frames.tex}

% Truncated sets, otherwise referred to as X
% Drop the universe letter for the third and fourth tables
\renewcommandx{\Xto}[3][3]{\X[][<#2][#3]}
\renewcommandx{\Xcomp}[3][3]{\X[][=#2][#3]}
\renewcommandx{\Xfrom}[3][3]{\X[][\geq#2][#3]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

In the way we have chosen to formlate these tables, there is, for instance, coherence condition $\cohf$ both sides of the equality in $\restrl$ and $\restrc$, to ensure that they are the same type.

For a given $n$, the coherence conditions evaluate to a reflexivity proof, so that the construction evaluates to an effective sequence of types of iterated relations not mentioning $\restrf$ nor $\cohf$ anymore.

% The third table mentions cohframe; keep Îµ, Ï‰ in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\renewcommand*{\lab}{tab:faces}
\input{tab-faces-ett.tex}

% Restriction for frame, layer, and filler
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[][#2][#3][#4][#5][#6][#7]}

% Frame, layer, and filler
% Drop all arguments for coh table; they're not present in coind table.
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][][][][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][][][][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[][][][][#5]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

The proof of $\cohf$ require a higher-dimensional coherence condition which we obtain by working in \U. If the proofs of the same equality were not equated, there would be a need for arbitrary many higher-dimensional coherences (see e.g.~\cite{herbelin15} for a discussion on the de facto need for recursive higher-dimensional coherence conditions in formulating higher-dimensional structures in type theory).

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\newcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{tab:coh}
\input{tab-coh-ett.tex}


where $\cohtwo{frame}$ is:

\begin{align*}
  \cohf[m][\omega][\theta][r][p][n][p][][d = {\restrf[m][\epsilon][q+2][n][p][][d = \d, D = \D]}, D = \D]\;\bullet         \\
  \ap (\restrf[m][\omega][r][n][p][][d = {\cohf[m][\epsilon][\theta][q+1][p][n][p][][d = \d, D = \D]}, D = \D]\;\bullet    \\
  \cohf[m][\epsilon][\omega][q][r][n][p][][d = {\restrf[m][\theta][p][n][p][][d = \d, D = \D]}, D = \D] =                  \\
  \ap (\restrf[m][\theta][p][n][p][][d = {\cohf[m][\epsilon][\omega][q+1][r+1][n][p][][d = \d, D = \D]}, D = \D])\;\bullet \\
  \cohf[m][\epsilon][\theta][q][p][n][p][][d = {\restrf[m][\omega][r+1][n][p][][d = \d, D = \D]}, D = \D]\;\bullet         \\
  \ap (\restrf[m][\epsilon][q][n][p][][d = {\cohf[m][\omega][\theta][r][p][n][p][][d = \d, D = \D]}, D = \D])
\end{align*}

\newpage
\section{Future work}

\newpage
\appendix
\section{Tables in full detail}
% Full tables in this section
%
% Clear the mask and label
\clearmask

% Keep all arguments for all macros
% Frame, layer, and filler
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[#1][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[#1][#2][#3][#4][#5]}
\renewcommandx{\filler}[5][1,2,3,4,5]{\prim{filler}[#1][#2][#3][#4][#5]}
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

% Restriction for frame, layer, and filler
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[#1][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{filler}[#1][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and filler
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{filler}[#1][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[#1][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{fulltab:coind}
\input{tab-coind.tex}
\renewcommand*{\lab}{fulltab:core}
\input{tab-core.tex}
\renewcommand*{\lab}{fulltab:frames}
\input{tab-frames.tex}

\begin{landscape}
  \renewcommand*{\lab}{fulltab:faces}
  \input{tab-faces.tex}
  \renewcommand*{\lab}{fulltab:coh}
  \input{tab-coh.tex}
\end{landscape}

\bibliographystyle{alpha}
\bibliography{paper}

\end{document}
