\documentclass{msc}

\usepackage{amsmath, amssymb, mathrsfs, wasysym, url, bookmark, tikz, tikz-cd, mathpazo, enumitem, xargs, multirow, float, tabularx, environ, booktabs, setspace, makecell, colortbl, pdflscape, flushend, minted, art.cls/colorpal, art.cls/ct, art.cls/sset, art.cls/lim, art.cls/joinargs}

\usepackage[prefix=bonak]{art.cls/xkeymask}
\usetikzlibrary{patterns}

% Magic with xkeyval to go over the 9-argument limit of LaTeX
\makeatletter
\define@cmdkey[bonak]{X}{D}{(#1)}

\define@cmdkey[bonak]{frame}{D}{(#1)}
\define@cmdkey[bonak]{layer}{D}{(#1)}
\define@cmdkey[bonak]{layer}{d}{(#1)}
\define@cmdkey[bonak]{painting}{D}{(#1)}
\define@cmdkey[bonak]{painting}{E}{(#1)}
\define@cmdkey[bonak]{painting}{d}{(#1)}
\define@cmdkey[bonak]{fullframe}{D}{(#1)}

\define@cmdkey[bonak]{restrframe}{D}{(#1)}
\define@cmdkey[bonak]{restrframe}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{D}{(#1)}
\define@cmdkey[bonak]{restrlayer}{d}{(#1)}
\define@cmdkey[bonak]{restrlayer}{l}{(#1)}
\define@cmdkey[bonak]{restrpainting}{D}{(#1)}
\define@cmdkey[bonak]{restrpainting}{E}{(#1)}
\define@cmdkey[bonak]{restrpainting}{d}{(#1)}
\define@cmdkey[bonak]{restrpainting}{c}{(#1)}

\define@cmdkey[bonak]{cohframe}{D}{(#1)}
\define@cmdkey[bonak]{cohframe}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{D}{(#1)}
\define@cmdkey[bonak]{cohlayer}{d}{(#1)}
\define@cmdkey[bonak]{cohlayer}{l}{(#1)}
\define@cmdkey[bonak]{cohpainting}{D}{(#1)}
\define@cmdkey[bonak]{cohpainting}{E}{(#1)}
\define@cmdkey[bonak]{cohpainting}{d}{(#1)}
\define@cmdkey[bonak]{cohpainting}{c}{(#1)}
\makeatother

% Truncated sets, otherwise referred to as X: the general macro
\newcommandx{\X}[3][1,2,3]{
  \ensuremath{{\color{carolina}{\nu\textsf{Set}}}_{#1}^{#2}}
  \setkeys*[bonak]{X}{#3}
}

% Frame, layer, and painting: the general macro
\newcommandx{\prim}[6][2,3,4,5,6]{
  \ensuremath{\mathsf{\color{indian-yellow}{#1}}_{#2}^{
    \joinargs[#3][#4][#5]}}
  \setkeys*[bonak]{#1}{#6}
}

% Restriction for frame, layer, and painting: the general macro
\newcommandx{\restr}[8][2,3,4,5,6,7,8]{
  \ensuremath{\mathsf{\color{russian-green}{restr}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4]}^{\joinargs[#5][#6][#7]}}
  \setkeys*[bonak]{restr#1}{#8}
}

% Coherence conditions for frame, layer, and painting: the general macro

% Hack: we'd like \coh to take 10 arguments, with the 10th being passed to
% xkeyval, but this is not possible. The only possible compromise is to join
% #7 and #8 by hand in usage of \coh: it's now #7 or '#6,#7' in \cohfoo commands
\newcommandx{\coh}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6]}^{\joinargs[#7][#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

\newcommandx{\cohtwo}[9][2,3,4,5,6,7,8,9]{
  \ensuremath{\mathsf{\color{chestnut}{coh2}}_{
    \joinargs[\mathsf{\color{indian-yellow}{#1}}][#2][#3][#4][#5][#6][#7]}^{\joinargs[#8]}}
  \setkeys*[bonak]{coh#1}{#9}
}

% Simplicial and Cubical sets
\newcommand{\DeltaHat}{\ensuremath{\hat{\boldsymbol{\Delta}}}}
\newcommand{\DeltaPlus}{\ensuremath{\boldsymbol{\Delta}_+}}
\newcommand{\Cube}{\ensuremath{\boldsymbol{{\square}}}}
\newcommand{\CSet}{\ensuremath{\mathsf{Set}_{\boldsymbol{\square}}}}

% Universe, referred to as U
\newcommandx{\U}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HSet}}_{#1}}}
\newcommandx{\HGpd}[1][1=]{\ensuremath{\mathsf{\color{spanish-blue}{HGpd}}_{#1}}}
\newcommand{\Type}{\ensuremath{\mathsf{\color{spanish-blue}{Type}}}}
\newcommand{\SProp}{\ensuremath{\mathsf{\color{spanish-blue}{SProp}}}}

% Examples
\newtheorem{example}[therm]{Example}

% The unit and bool types
\newcommand{\unittype}{\ensuremath{\mathsf{unit}}}
\newcommand{\booltype}{\ensuremath{\mathsf{bool}}}
\newcommand{\unitpoint}{\ensuremath{\ast}}

% Definitional and extensional equality
\newcommand{\defeq}{\ensuremath{\triangleq}}
\newcommand{\refl}{\ensuremath{\mathsf{refl}}}

% Some abbreviations
\newcommand{\tl}{\ensuremath{\mathsf{tl}}}
\newcommand{\hd}{\ensuremath{\mathsf{hd}}}
\newcommand{\imp}{\rightarrow}
\newcommand{\overright}[1]{\overrightarrow{#1}}
\renewcommand{\D}{D}
\newcommand{\hdD}{D.1}
\newcommand{\tlD}{D.2}
\renewcommand{\d}{d}
\renewcommand{\E}{E}
\newcommand{\ap}{\mathsf{ap}\;}
\renewcommand{\l}{l}
\renewcommand{\c}{c}
\newcommand{\pair}[2]{#1, #2}
\newcommand{\Dom}{\textsf{Dom}}
\newcommand{\UIP}{\textsf{UIP}}

% These are renewed in tables, but let's define them now for in-document
% typesetting
\newcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\newcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\newcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\newcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\newcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\newcommandx{\restrc}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\newcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\newcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\newcommandx{\cohc}{\coh{painting}[][][][][][][][]}
\newcommandx{\coht}{\cohtwo{frame}[][][][][][][][]}
\newcommandx{\fullframe}[1][1]{\prim{fullframe}[][#1][][][]}

% For typesetting type theory rules
\newcommand \seqr[3]
  {\shortstack{$#2$ \\ \mbox{}\\
                   \mbox{}\hrulefill\mbox{}\\ \mbox{}\\ $#3$} \raisebox{2ex}{$\;\;\mbox{$#1$}$}}

% Kerning for star
\newcommand{\kstar}{{\star}}

% The eqntable environment
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\NewEnviron{eqntable}[1]{
  \begin{table}[H]
    \small
    \begin{tabularx}{\linewidth}{
      @{}
      >{$}l<{$}
      >{$}c<{$}
      >{$}c<{$}
      >{$}Y<{$}
      @{}}
      \toprule
      \BODY
      \bottomrule
    \end{tabularx}
    \caption{#1}
  \end{table}
}

% The label, since we're including twice
\newcommand*{\lab}{}

% \midrule color
\def\graymidrule{\arrayrulecolor{gray30}\midrule\arrayrulecolor{gray65}}

% A block in the eqntable environment
\NewDocumentCommand{\eqnline}{m m m m}{#1 & #2 & #3 & #4 \\}
\newcommandx*{\mc}[1]{\multicolumn{4}{c}{\emph{#1}} \\\\}

% \eqnarg is slightly more involved: output ( ... ) if not in mask,
% and { ... } if in mask
\newcommandx*{\eqnarg}[3]{\ifinmask[bonak]{#1}[#2]{\{#2:#3\}}{(#2:#3)}}

\begin{document}
\title{A parametricity-based formalization of semi-simplicial and semi-cubical sets}
\begin{authgrp}
  \author{Hugo Herbelin}
  \affiliation{Université Paris Cité, Inria, CNRS, IRIF, Paris
    \email{Hugo.Herbelin@inria.fr}}
  \author{Ramkumar Ramachandra}
  \affiliation{Unaffiliated \email{r@artagnon.com}}
\end{authgrp}
\begin{abstract}
  Constructions such as semi-simplicial and semi-cubical sets can be defined in the ``usual way'' as presheaves over respectively, the semi-simplex or semi-cube category, which we call \emph{fibered} definitions, but also defined like in e.g. \cite{voevodsky12} or in \cite{herbelin15}, as a dependently-typed construction, which we call \emph{indexed}.

  On another side, it is known that semi-simplicial and semi-cubical sets are related to iterated Reynolds's parametricity, respectively in its unary and binary variants\dots

  We exploit this correspondence to develop a uniform indexed definition of both augmented semi-simplicial and semi-cubical sets, which is additionally fully formalized in Coq's dependent type theory. Beside the interest in the construction itself, we expect it to eventually serve as models of type theory preserving more definitional equalities than presheaf models do.
\end{abstract}
\begin{keywords}
  simplicial set, cubical set, coq, formalization, HoTT
\end{keywords}
% \maketitle

\section{Introduction}
\subsection*{Fibered vs indexed presentation of semi-simplicial and semi-cubical sets}
A family of sets can commonly be represented in two ways: as a family properly speaking, indexed over the elements of a given set $S$, or as a set $T$ together with a map from $T$ to $S$, which specifies for each element of set $T$ its dependency on $S$. In the former case, we call it an \emph{indexed} presentation. In the latter case, the set associated to a given element of $S$ is the fiber of this element, so we call it a \emph{fibered} presentation. The two presentations are equivalent and the equivalence can be phrased concisely in the language of homotopy type theory~\citep{hottbook} as the fibered/indexed correspondence\footnote{In an informal discussion, alternative nomenclatures were proposed: fibration/family correspondence and unbundled/bundled correspondence. The fibered/indexed nomenclature echoes the Grothendieck construction of fibered categories from indexed categories. The most elementary instance of the correspondence, with $\Type$ instead of $\U$, is sometimes called ``Grothendieck construction for dummies'' (its proof requires univalence, see \cite{hottbook}).}.
\begin{equation*}
  \mbox{(fibered)}\qquad(\Sigma T: \U. (T \rightarrow S)) ~\simeq~ (S \rightarrow \U)\qquad \mbox{(indexed)}
\end{equation*}
where $\U$ represents in homotopy type theory the subset of types within a given universe where equality of any two elements has at most one proof.

A \emph{presheaf} on an category is a family of sets connected with maps indexed over the morphisms of the category. As such, it lives on the indexed side of the correspondence, contrasting with the fibered side, where we have \emph{discrete Grothendieck fibrations}~\citep{LoregianRiehl20}. However, there are situations where a presheaf $F$ can also be seen as living on the fibered side of the correspondence. This happens when the indexing category is \emph{direct}, or has a downwards-well-founded collection of non-identity morphisms. This is the case in semi-simplicial and semi-cubical sets, where each $F(X)$ serving as source of a map $F(X) \stackrel{F(f)}{\rightarrow} F(Y)$ can be turned into a family $F(X)$ indexed on $F(Y)$. Since the maps are well-founded downward, this can be iterated from below, eventually producing a collection of families which we call an indexed presentation of the presheaf over the direct category.

Let us consider, for instance, the case of a semi-cubical set~\citep{grandis03,buchholtz17} presented with $2n$ face maps from the set of $n$-cubes to the set of $(n-1)$-cubes. Formulated in type theory, the corresponding presheaf definition of a semi-cubical set prescribes a family of sets and face
maps between them as follows:

\begin{equation*}
  \begin{tikzcd}
    X_0: \U & X_1: \U \arrow[l, "\partial^L" description, shift left=2] \arrow[l, "\partial^R" description, shift right=2] & X_2: \U \arrow[l, "\partial^{L\kstar}" description, shift left=6] \arrow[l, "\partial^{R\kstar}" description, shift left=2] \arrow[l, "\partial^{\kstar L}" description, shift right=2] \arrow[l, "\partial^{\kstar R}" description, shift right=6] & \ldots
  \end{tikzcd}
\end{equation*}
up to cubical faces identities. In it, $X_1$ can be seen as a family over $X_0 \times X_0$ presented in a fibered form, $X_2$ can be seen as a family of $X_1 \times X_1 \times X_1 \times X_1$, and so on. This suggests an alternative indexed presentation of the same presheaf as a stratified sequence of families indexed on elements of families of lower rank, taking into account the coherence conditions to prevent duplications. Formulated in type theory, it takes the form:

\begin{align*}
  X_0 & :              & \U                                                                                           \\
  X_1 & :              & X_0 \times X_0 \rightarrow \U                                                           \\
  X_2 & : \Pi a b c d. & X_1(a)(b) \times X_1(a)(c) \times X_1 (b)(d) \times X_1 (c)(d) \rightarrow \U \\
  \ldots
\end{align*}

The idea for such an indexed presentation of presheaves over a direct category was mentioned at the Univalent Foundations year in the context of defining semi-simplicial types~\footnote{See e.g. \url{https://ncatlab.org/nlab/show/semi-simplicial+types+in+homotopy+type+theory}.}. A couple of constructions were proposed since then. One, by \cite{voevodsky12}, relies on the presentation of semi-simplicial sets as a presheaf over increasing injective maps between finite ordinals. Another, by \cite{herbelin15}\footnote{In hindsight, the title of the paper ``A dependently-typed construction of semi-simplicial types'' is somewhat confusing: it was part of a project for defining semi-simplicial types, but, in practice, the definition is done in a type theory with Unicity of Identity Proofs, meaning, in a type theory where types (intended to represent arbitrary $\infty$-groupoids) are actually sets ($0$-truncated $\infty$-groupoids or $0$-groupoids). The confusion between the question of moving from semi-simplicial sets to semi-simplicial types, and moving from a presheaf to an indexed presentation was, however, common at the time.}, and fully formalized in the Coq proof assistant, relies on the presentation of semi-simplicial sets as a presheaf over face maps. Another by \cite{part15}, formalized in (an emulation of logic-enriched homotopy type theory in) the Plastic proof assistant, and yet another by \cite{annenkovCK17}, formalized in (an emulation of a two-level type theory in) the Agda proof assistant~\footnote{\url{https://github.com/nicolaikraus/HoTT-Agda/blob/master/nicolai/SemiSimp/SStypes.agda}}, also rely on the presentation of the semi-simplicial category from increasing injective functions over finite ordinals.

The indexed definition of a presheaf over a direct category is technically more involved than the presheaf definition, as it requires hard-wiring in the structure the dependencies between elements of the sets of the presheaf, including the coherence conditions between these dependencies, such as taking the $i$-th face of the $j$-th face of a $n$-simplex being the same as taking the $(j-1)$-th face of the $i$-th face (when $j>i$). However, defining a concrete presheaf in indexed form only requires providing the family, since the responsibility of defining maps and showing the coherence conditions is already accounted for in the definition.

In category-theoretic terms, the indexing set of the family $X_n$ in the indexed presentation is a \emph{matching object} of the presheaf at $n$. The indexed presentation of presheaves over a direct category can then be identified with a subclass of ordinary presheaves known as Reedy fibrant, where Reedy fibrancy precisely expresses that the set $X_n$ in the fibered presentation is a $\Sigma$-type over a representative of the class of equivalence of matching objects at level $n$~\citep{shulman14,kraus17}.

\subsection*{Reynolds' parametricity and its unary and binary variants}
In the context of functional programming, Reynolds' parametricity~(\citeyear{reynolds83}) interprets types as relations characterizing the observational behavior of programs of this type. More generally, correspondences, in the sense of ``relevant'' relation, that is of a family over a product of sets, can be used in place of relations. Parametricity can then be iterated, and relying on the fibered representation of correspondences as spans, it has been noted that iterated Reynolds' parametricity has the structure of a cubical set~\citep{johann17,altenkirch15,moulin16,moeneclaey21,moeneclaey22phd}. We obtain a \emph{unary} variant of Reynolds' \emph{binary} parametricity by using predicates or families instead of relations or correspondences, in which case, we obtain a form of realizability~\citep{bernardy12,lasson12,moulin16}. It has then been noted that iterated unary parametricity has the structure of an augmented simplicial set~\footnote{Private communication with Hugo Moeneclaey and Thorsten Altenkirch.}. This similarity suggests that the definition of augmented semi-simplicial sets and semi-cubical sets can both be seen as instances of a more general construction which we call $\nu$-sets of presheaves over a $\nu$-semi-shape category made of words of some cardinal $\nu$+1, where $\nu=1$ gives augmented semi-simplicial sets and $\nu=2$ gives semi-cubical sets.

\subsection*{Contribution}
The main contribution of the paper is to describe in full, the details of a recipe that uniformly characterizes unary and binary iterated parametricity in indexed form, and to derive from it a new indexed presentation, called indexed \emph{$\nu$-sets}, of augmented semi-simplicial and semi-cubical sets. Alternatively, from a category-theory perspective, we are characterizing, among the class of matching objects up to isomorphism for augmented semi-simplicial and cubical sets, a particular instance that reflects the structure of iterated parametricity.

This new construction is useful in the direction of better understanding the technicality of coherence issues in defining ``semi-simplicial types''~\citep{part15,shulman14,altenkirch16,kraus17}, as well as the dialectic between reasoning in Extensional Type Theory and Intensional Type Theory (as will be discussed in Section~\ref{sec:ett}).

Our work is a step in the direction of the program initiated in \cite{altenkirch15} to develop parametricity-based models of parametric type theory~\citep{bernardy15,nuyts17,cavallo19} and cubical type theory~\citep{bezem13,cohen16,angiuli21} which are closer to the syntax of type theory, and is likely to better reflect the definitional properties of type theory than presheaf-based cubical sets would do. Compare, for example, the loss of definitional properties when interpreting ``indexed'' dependent types of type theory as ``fibrations'' in models such as locally cartesian closed categories~\citep{curien14}.

Our mechanization can be found at \href{https://github.com/artagnon/bonak}{github.com/artagnon/bonak}. The construction was conceived in Summer 2019, and the mechanization began in late 2019. A sketch of the construction was presented at the 2020 HoTT-UF workshop and the completion of the mechanization was reported at the TYPES 2022 conference.

\section{Semi-simplicial and semi-cubical sets\label{sec:nu}}
In this section, we generalize semi-simplicial and semi-cubical sets to $\nu$-sets, subsuming the earlier definitions. We start with some introductory material on semi-simplicial and semi-cubical sets.

\subsection*{Augmented semi-simplicial sets}
Augmented semi-simplicial sets are defined similarly to semi-simplicial sets, except that the connected components are additionally dependent on a ``color''. Conversely, semi-simplicial sets can be seen as augmented semi-simplicial sets over the singleton set of one fixed color.

Let us associate dimension $0$ to colors; then, points are dimension $1$, lines are dimension $2$, and so on. There is hence a shift by one when compared to semi-simplicial sets. We can then draw augmented semi-simplicial sets like semi-simplicial sets, except for this shift by one.

While ordinary semi-simplicial sets are presheaves over the semi-simplex category, augmented semi-simplicial sets are presheaves over, what we will define as, \DeltaPlus. There are different ways to define \DeltaPlus, up to equivalence, and we use a definition that can be extended to semi-cubical sets in a straightforward manner.

\begin{notation}[Finite sequences]
  We denote finite sequences by $[i_1, \ldots i_n]$ for $i_j$ ranging over some domain. In particular, the empty sequence is written $[]$ and we define $i :: [j_1, \ldots, j_n]$ to be $[i, j_1, \ldots, j_n]$.
\end{notation}

\begin{definition}[$\DeltaPlus$]
  The definition of $\DeltaPlus$ is shown below. Note that, if $g \circ f$ is well-defined, then the length of $f$ is less than that of $g$. It can be shown that composition is associative and that $\id$ is neutral.

  \begin{figure}[H]
    \centering
    \begin{align*}
      \Obj_{\DeltaPlus}       & := \Nat                                                                             \\
      \Hom_{\DeltaPlus}(p, n) & := \{l \in \{0, \kstar\}^n \mid \text{number of $\kstar$ in $l = p$}\}              \\
      g \circ f               & :=
      \begin{cases}
        f                  & \text{if $g = []$}                                                        \\
        0 :: (g' \circ f)  & \text{if $g = (0 :: g')$}                                                 \\
        a :: (g' \circ f') & \text{if $g = (\star :: g')$, $f = (a :: f')$, where $a = 0$ or $\kstar$} \\
      \end{cases}                \\
      \id                     & := [\kstar, \ldots, \kstar] \text{ $n$ times for $\id \in \Hom_{\DeltaPlus}(n, n)$}
    \end{align*}
  \end{figure}
\end{definition}

\begin{definition}[$\Set_{\DeltaPlus}$]
  We define the category of augmented semi-simplicial sets as the functor category:
  \begin{equation*}
    \Set_{\DeltaPlus} := \Set^{\DeltaPlus^{\mathsf{op}}}
  \end{equation*}
\end{definition}

To provide examples, we define the standard augmented $n$-semi-simplex.

\begin{definition}[$\DeltaPlus^n$]
  The standard augmented $n$-semi-simplex $\DeltaPlus^n$ is defined as the Yoneda embedding of $n \in \Obj(\DeltaPlus)$:
  \begin{align*}
    \DeltaPlus^n    & : \Set_{\DeltaPlus}        \\
    \DeltaPlus^n(p) & := \Hom(p, n)              \\
    \DeltaPlus^n(f) & := \lambda g .\, g \circ f
  \end{align*}
\end{definition}

The standard augmented $0$-semi-simplex is a singleton made of one color (in our case black). Standard augmented $n$-semi-simplices for $n\geq 1$ have a geometric interpretation, and we illustrate them for dimensions $1$, $2$, and $3$.

\begin{example}[$\DeltaPlus^1$]
  The standard augmented $1$-semi-simplex can be pictured as a point, colored black, corresponding to the unique morphism in $\Hom(0, 1)$. This point is the identity in $\Hom(1, 1)$; it is hence shown as a singleton $\kstar$.
  \begin{equation*}
    \begin{tikzcd}
      \kstar
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\DeltaPlus^2$]
  The standard augmented $2$-semi-simplex is drawn as two points, given by $\Hom(1, 2)$, along with a line connecting them, given by $\Hom(2, 2)$. We use the color black to denote the unique morphisms in $\Hom(0, 1)$ and $\Hom(0, 2)$.
  \begin{equation*}
    \begin{tikzcd}
      \kstar0 \arrow[r, dash, "\kstar\kstar"] & 0\kstar
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\DeltaPlus^3$]
  $\DeltaPlus^3$ is drawn as three points, given by $\Hom(1, 3)$, three lines connecting them, given by $\Hom(2, 3)$, and a triangular filler given by $\Hom(3, 3)$.
  \begin{equation*}
    \begin{tikzcd}
      & |[alias=F]|00\kstar \arrow[ddr, dash, "0\kstar\kstar"] & \\\\
      \kstar00 \arrow[rr, dash, "\kstar\kstar0"{name=T, below}]\arrow[uur, dash, "\kstar0\kstar"] && 0\kstar0 \\
      \arrow[rightarrow, from=F, to=T, phantom, "\kstar\kstar\kstar" description]
    \end{tikzcd}
  \end{equation*}
\end{example}

More generally, the standard augmented $(n + 1)$-semi-simplex can be obtained by taking a copy of the standard augmented $n$-semi-simplex serving as a base and gluing on top of it another copy lifted by one dimension. In the second copy, the color becomes an extra point, the points become lines connecting the points of the base to the extra point and so on. In particular, the components of the base are those of the standard augmented $n$-semi-simplex postfixed by $0$ while the components of the lifted copy are postfixed by~$\kstar$. Note that the components may be oriented by letting each $n$-dimensional component point to the $(n-1)$-dimensional component obtained by replacing the leftmost $\kstar$ of the $n$-dimensional component with $0$.

\subsection*{Semi-cubical sets}
Semi-cubical sets are defined like augmented semi-simplicial sets except that $\DeltaPlus$ is replaced by $\Cube$ in which we take sequences of $L$, $R$ and $\star$, instead of sequences of $0$ and $\kstar$. They represent ordinary semi-cubical sets, with faces (and no augmentation).

\begin{definition}[\Cube]
  The definition of $\Cube$ is shown below. The symbols $L$ and $R$ indicate opposite faces of a cube.

  \begin{figure}[H]
    \centering
    \begin{align*}
      \Obj_{\Cube}       & := \Nat                                                                          \\
      \Hom_{\Cube}(p, n) & := \{l \in \{L, R, \kstar\}^n \mid \text{number of $\kstar$ in $l = p$}\}        \\
      g \circ f          & :=
      \begin{cases}
        f                  & \text{if $g = []$}                                                               \\
        a :: (g' \circ f)  & \text{if $g = (a :: g')$}, \text{where $a = L$ or $R$}                           \\
        a :: (g' \circ f') & \text{if $g = (\kstar :: g')$, $f = (a :: f')$, where $a = L$, $R$, or $\kstar$} \\
      \end{cases} \\
      \id                & := [\kstar, \ldots, \kstar] \text{ $n$ times}
    \end{align*}
  \end{figure}

  Again, if $g \circ f$ is well-defined, then the length of $f$ is less than that of $g$. It can be shown that composition is associative and that $\id$ is neutral.
\end{definition}

\begin{definition}[\CSet]
  We define the category of semi-cubical sets as the functor category:
  \begin{equation*}
    \CSet := \Set^{\op{\Cube}}
  \end{equation*}
\end{definition}

\begin{definition}[$\Cube^n$]
  The standard semi-cube $\Cube^n$ is defined as the Yoneda embedding of $n \in \Obj(\Cube)$:
  \begin{align*}
    \Cube^n    & : \CSet                    \\
    \Cube^n(p) & := \Hom(p, n)              \\
    \Cube^n(f) & := \lambda g .\, g \circ f
  \end{align*}
\end{definition}

Standard $n$-semi-cubes have a geometric interpretation, which we illustrate for dimensions $0$, $1$, and $2$.

\begin{example}[$\Cube^0$]
  $\Cube^0$ is $\Hom(0, 0)$, or the singleton set of the empty sequence:
  \begin{equation*}
    \begin{tikzcd}
      \{\}
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\Cube^1$]
  $\Cube^1$ consists of two points, given by $\Hom(0, 1)$, and a line, given by $\Hom(1, 1)$.
  \begin{equation*}
    \begin{tikzcd}
      L \arrow[r, "\kstar", dash] & R
    \end{tikzcd}
  \end{equation*}
\end{example}

\begin{example}[$\Cube^2$]
  $\Cube^2$ consists of four points, given by $\Hom(0, 2)$, four lines connecting the four points, given by $\Hom(1, 2)$, and a filler, given by $\Hom(2, 2)$:
  \begin{equation*}
    \begin{tikzcd}
      LR \arrow[r, dash, "\kstar R"{name=F}] \arrow[d, dash, "L\kstar" left] & RR \arrow[d, dash, "R\kstar"] \\
      LL \arrow[r, dash, "\kstar L"{name=T, below}] & RL \\
      \arrow[rightarrow, from=F, to=T, phantom, "\kstar\kstar" description]
    \end{tikzcd}
  \end{equation*}
\end{example}

More generally, the standard $(n + 1)$-semi-cube can be obtained by taking two copies of the standard $n$-semi-cube serving as bottom and top face and connecting them on their border by a cylinder obtained as a third copy stretched in the new dimension. The bottom and top faces are obtained from the standard $n$-semi-cube by postfixing with respectively $L$ and $R$ while the cylinder is obtained by postfixing with $\kstar$. Note that the components can

time be oriented by letting each $n$-dimensional component go from the $(n-1)$-dimensional component obtained by replacing the leftmost $\kstar$ with $L$ to the one obtained by replacing the leftmost $\kstar$ with $R$.

\subsection*{\texorpdfstring{$\nu$}{ν}-sets}
Let us call $\nu$-sets, the generalization of augmented semi-simplicial sets and semi-cubical sets obtained by building on an arbitrary alphabet $\nu$, so that the following holds:

\begin{table}[H]
  \centering
  \begin{tabularx}{0.7\linewidth}{X|X|X}
    \toprule
    Cardinal of $\nu$ & 1                               & 2                  \\
    \graymidrule
    Interpretation    & Augmented semi-simplicial types & Semi-cubical types \\
    \bottomrule
  \end{tabularx}
\end{table}

To obtain this, we extend $\DeltaPlus$ and $\Cube$ in a straightforward manner into a category which we call $\hexagon$.

\begin{definition}[$\hexagon$]
  The definition of $\nu$-semi-shape category is shown below. Note that, if $g \circ f$ is well-defined, then the length of $f$ is less than that of $g$. It can be shown that composition is associative and that $\id$ is neutral.

  \begin{figure}[H]
    \centering
    \begin{align*}
      \Obj_{\hexagon}       & := \Nat                                                                           \\
      \Hom_{\hexagon}(p, n) & := \{l \in (\nu \cup \{\kstar\})^n \mid \text{number of $\kstar$ in $l = p$}\}    \\
      g \circ f             & :=
      \begin{cases}
        f                  & \text{if $g = []$}                                                                 \\
        a :: (g' \circ f)  & \text{if $g = (a :: g')$}, \text{where $a \in \nu$}                                \\
        a :: (g' \circ f') & \text{if $g = (\kstar :: g')$, $f = (a :: f')$, where $a \in \nu$ or $a = \kstar$} \\
      \end{cases}   \\
      \id                   & := [\kstar, \ldots, \kstar] \text{ $n$ times for $\id \in \Hom_{\hexagon}(n, n)$}
    \end{align*}
  \end{figure}
\end{definition}

A $\nu$-set is thus a contravariant functor $\phi$ from the $\nu$-semi-shape category to $\Set$ and we call $n$-$\nu$-semi-shape an element of $\phi(n)$. As in the augmented semi-simplicial and semi-cubical cases, the standard $(n + 1)$-$\nu$-semi-shape is obtained by connecting together $\nu$ copies of the standard $n$-$\nu$-semi-shape with an extra copy stretched in the new dimension. We clarify in the next sections how this process of construction is similar to the parametricity translation developed for functional programming~\citep{reynolds83} and more generally for type theory~\citep{bernardy10, bernardy11, atkey14, bernardy15}.

\section{Type theory}
Martin-Löf's Type theory~\citep{martinlof75,martinlof84} is a logical formalism based on the notion of a \emph{type} rather than that of a \emph{set}. It can be seen as a foundation of mathematics alternative to set theory and is the core of several tools for the formalization of mathematics such as Agda~(\citeyear{agda23}), Coq~(\citeyear{coq22}) or Lean~(\citeyear{lean15}). In type theory, propositions are types and proofs are programs. A particularity of type theory is also that types and programs, hence propositions and proofs also, are considered modulo an equational theory called definitional equality.

Type theory is a flexible formalism supporting different models. Some models are based on topological spaces, where equality is interpreted as path, and substitutivity of equality as transport~\citep{kapulkin21}. These models support the univalence principle stating that equality of types mimics equivalence of types, leading to the development of Homotopy Type Theory~\citep{hottbook}. In type theory, types are organized in a hierarchy of universes written $\Type_m$ for $m$ a natural number. Main types in type theory are the types of dependent pairs, written $\Sigma a : A.\,B(a)$, the types of dependent functions, written $\Pi a:A.\,B(a)$, for $A$ a type and $B(a)$ a type dependent on the inhabitant $a$ of $A$, and the type of propositional equality, written $t = u$. We assume our type theory to also include a distinguished singleton type, written $\unittype$, and with inhabitant $\unitpoint$, the type of boolean values, called $\textsf{bool}$, and the type of natural numbers. We also assume that our type theory includes the coinductive type of infinite tuples. We also write $\hd$ and $\tl$ the projections of dependent pairs, and $\refl$ for reflexivity. Logical propositions being types themselves, we use $\Pi$ to represent universal quantification and $\Sigma$ to represent existential quantification.

A type-theoretic notion of sets can be recovered in each universe as $\U[m]$, denoting the subtype of $\Type_m$ for which paths are degenerated, what can be expressed by the property of Uniqueness of Identity Proofs (UIP). Technically, this is expressed as a structure equipping a domain $\Dom$ with the property $\UIP$:
\begin{align*}
  \Dom & : \Type_m                                  \\
  \UIP & : \Pi x y: \Dom.\, \Pi p q: x = y.\, p = q
\end{align*}

In $\U[m]$, the following properties hold:

\begin{enumerate}
  \item[(i)] UIP holds on the unit type, bool type, as well as all types of finite cardinal $\nu$.
  \item[(ii)] UIP propagates to $\Sigma$-types.
  \item[(iii)] UIP propagates to $\Pi$-types, with some additional functional extensionality axioms.
\end{enumerate}

By the notations $\Type$ and $\U$ will be meant $\Type_m$ or $\U[m]$ at some unspecified universe level $m$.

We are also interested in \emph{extensional} type theory; i.e. in a type theory with the following reflection rule, where $=$ is propositional equality in some type and $\equiv$ is definitional equality~\citep{martinlof84}:
\begin{equation*}
  \seqr{}{\Gamma \vdash p: t = u}{\Gamma \vdash t \equiv u}
\end{equation*}

Note that the reflection rule implies UIP so that $\U$ and $\Type$ ae equivalent in extensional type theory. The reflection rules also implies functional extensionality, and, actually, extensional type theory is logically equivalent to intentional type theory extended with UIP and functional extensionality~\citep{HofmannPhd}.

\section{Relating to parametricity\label{sec:rel-param}}
Let us recall from the introduction, the form taken by the indexed presentation of a semi-cubical set:
\begin{align*}
  X_0 & :              & \U                                                                                           \\
  X_1 & :              & X_0 \rightarrow X_0 \rightarrow \U                                                           \\
  X_2 & : \Pi a b c d. & X_1(a)(b) \rightarrow X_1(a)(c) \rightarrow X_1 (b)(d) \rightarrow X_1 (c)(d) \rightarrow \U \\
  \ldots
\end{align*}

In there, the process of construction of the type of $X_1$ from that of $X_0$, and from the type of $X_2$ to that of $X_1$, and so on, is similar to iteratively applying a binary parametricity translation. The parametricity which we consider interprets a type $A$ by a family $A_\kstar$ of edges in a graph over $A$, and a term $t: A$ as an edge in $A_\kstar(t)(t)$. To each type constructor is then associated the construction of a graph. In particular, the type of types $\U$ is interpreted as the family of families ${\U}_\kstar$, which takes $A_L$ and $A_R$ in $\U$ and returns the type $A_L \rightarrow A_R \rightarrow \U$ of families of edges over $A_L$ and $A_R$. Also, for $A$ interpreted by $A_\kstar$ and $B$ interpreted by $B_\kstar$, a dependent function type $\Pi a: A.\, B$ is interpreted as the graph $(\Pi a: A.\, B)_\kstar$ that takes two functions $f_L$ and $f_R$ of type $\Pi a: A.\, B$, and expresses that these functions map related arguments in $A$ to related arguments in $B$:
\begin{align*}
  (\Pi a: A.\, B)_\kstar(f_L)(f_R) \; \defeq \; \Pi a_L: A.\, \Pi a_R: A.\, \Pi a_\kstar: A_\kstar(a_L)(a_R).\, B_\kstar(f_L(a_L))(f_R(a_R))
\end{align*}

In particular, for $X: \U$, applying the parametricity translation is about canonically associating to $X$ an inhabitant $X_\kstar$ of ${\U}_\kstar(X)(X)$ i.e. of $X \rightarrow X \rightarrow \U$. In turn, applying the parametricity translation to $X_\kstar: X \rightarrow X \rightarrow \U$ is about canonically associating to $X_\kstar$ an inhabitant $X_{\kstar\kstar}$ of $(X \rightarrow X \rightarrow \U)_\kstar(X_\kstar)(X_\kstar)$ i.e. of:
\begin{align*}
  \Pi x_{LL}: X.\, \Pi x_{LR}: X.\, X_\kstar(x_{LL})(x_{LR})             \\
  \rightarrow \Pi x_{RL}: X.\, \Pi x_{RR}: X.\, X_\kstar(x_{RL})(x_{RR}) \\ \rightarrow X_\kstar(x_{LL}, x_{RL}) \rightarrow X_\kstar(x_{LR})(x_{RR})  \rightarrow \U
\end{align*}
which hints us at how the sequence $X_0$, $X_1$, $X_2$ can be seen as a sequence of inhabitants of the iteration of binary parametricity applied to an initial $X: \U$:
\begin{equation*}
  \begin{array}{llllr}
    X_0 & \defeq & X                & : & \U                                               \\
    X_1 & \defeq & X_\kstar         & : & {\U}_\kstar(X)(X)                                \\
    X_2 & \defeq & X_{\kstar\kstar} & : & ({\U}_\kstar(X)(X))_{\kstar}(X_\kstar)(X_\kstar) \\
    \ldots
  \end{array}
\end{equation*}

This tells us how the informal type given to $X_2$ in the previous section could be rephrased so that it comes as the instance of a general recipe characterizing the type of all $X_i$.

Notice, however, that the recipe obtained so far, $X_{n + 1}: ({S_n})_\kstar(X_n)(X_n)$ for $X_n: S_n$, applies parametricity on the \emph{syntax} of the type of $X_n$. It does not directly yield a characterization of $S_n$ as a function from $n$. Reformulating the recipe as an explicit recursive construction, without requiring an interpretation of the syntax of types, is the main outcome of this work, together with the mechanization and the uniform treatment of augmented semi-simplicial and semi-cubical sets by means of the generalization to $\nu$-sets.

% 5. The "mathematical" construction (and its intuition)
%   leaving equality and inequality side conditions implicit
%   in particular, this means:
%   - assuming equality reflection
%   - equality as in observational type theory
%   - assuming termination of recursive constructions
% 6. Formal details
% - making substitution of equals by equals explicit
% - observational properties of equality
% - the theory of inequality proofs
% - the well-foundedness
% - the formalization tricks
%   - implicit arguments
%   - refine-style vs tactic-style

\section{Our construction}
In this section, we describe our parametricity-based construction of $\nu$-sets in indexed form at two levels of formality:

Sections~\ref{sec:ett} and~\ref{sec:itt} describe the construction at an informal level of discourse:
\begin{enumerate}
  \item In \ref{sec:ett}, we present it in informal extensional type theory where equational reasoning is left implicit.
  \item While reasoning in extensional type theory is similar to reasoning in set theory regarding how equality is implicitly handled, extensional type theory has two limitations. The first limitation is that it enforces the principle of Uniqueness of Identity Proofs and this is inconsistent with the Univalence principle, thus making it inexpressible in Homotopy Type Theory. The second limitation is that we want the construction to be formalizable in the Coq proof assistant whose underlying type theory is intensional. Section~\ref{sec:itt} thus rephrases the construction in (informal) intensional type theory.
\end{enumerate}

Sections~\ref{sec:wf}, \ref{sec:le}, and \ref{sec:eqproperties} describe additional issues to be addressed in order to get a fully formal construction:
\begin{enumerate}
  \item The well-foundedness of the induction requires a special termination evidence which will be discussed in section~\ref{sec:wf}.
  \item The construction is indexed over integers and holds under some constraints on the range of these integers. There is a standard formalization dilemma in this kind of situation: either the constraints on the range are embedded in the construction so that the construction makes sense only on the corresponding range, or the construction is made first on a more general domain than needed but restricted to a smaller domain only at the time of use. We adopted the first approach, requiring however the construction to be dependent on proofs of inequalities on natural numbers. We discuss how we deal with such dependencies in section~\ref{sec:le}.
  \item A number of standard groupoid properties of equality as well as type isomorphisms have been left implicit in the informal definition. This is discussed in section~\ref{sec:eqproperties}.
\end{enumerate}

\subsection{The construction in informal type theory\label{sec:ett}}
% Abbreviated tables in this section
%
% The rule for implicit arguments for each table:
% show 1 explicit in first two parts
% show E + 1 explicit in the third part
\appendmask[bonak]{layer}[D]
\appendmask[bonak]{painting}[D]
\appendmask[bonak]{restrframe}[D]
\appendmask[bonak]{restrlayer}[D, d]
\appendmask[bonak]{restrpainting}[D, d]
\appendmask[bonak]{cohframe}[D]
\appendmask[bonak]{cohlayer}[D, d]
\appendmask[bonak]{cohpainting}[D, d]

% Now, we write the type theory bit, and input the abbreviated tables

% Truncated sets, otherwise referred to as X
% Keep all arguments
\newcommandx{\Xp}[1]{\X[#1][][]}
\newcommandx{\Xto}[3][3=]{\X[#1][<#2][#3]}
\newcommandx{\Xcomp}[3][3=]{\X[#1][=#2][#3]}
\newcommandx{\Xfrom}[3][3=]{\X[#1][\geq#2][#3]}

% Frame, layer, and painting
% Drop the universe letter
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[][#2][#3][#4][#5]}

% Restriction for frame, layer, and painting
% Drop the universe letter
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Coherence conditions for frame, layer, and painting
% Keep only ε, ω; n, p; proposition on n and p
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][][][][][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][][][][][#9]}

A $\nu$-set is a sequence of families of $\U$, that is $\U[m]$ for some universe level $m$. We call such sequence a $\nu$-set at level $m$, whose type thus lives in $\U[m+1]$.

Table \ref{tab:coind} describes the type of a $\nu$-set at level $m$ in indexed form, as the type of a coinductively-defined infinite sequence of type families representing the limit of $n$-truncated $\nu$-sets: $\Xfrom{m}{n}$ denotes an infinite sequence $X_{n+1}, X_{n+2}, \ldots$ dependent on a $n$-truncated $\nu$-set, $\Xto{m}{n}$, so that, when $m$ is $0$, it denotes a full $\nu$-set, written $\Xp{m}$. This is made possible because the $0$-truncated $\nu$-set, $\Xto{m}{0}$, is degenerated: it is an empty family, defined to be the unit type, and there is thus only one $0$-truncated $\nu$-set, namely the canonical inhabitant $\kstar$ of $\unittype$.

The definition of the type of a $n$-truncated $\nu$-set is in turn described in \ref{tab:core}. In the infinite sequence of type families representing a $\nu$-set, the $n$-th component is a type dependent over a $\fullframe$. The type $\fullframe$ represents a matching object. It is recursively defined in \ref{tab:frames}, using the auxiliary definitions of $\framep$, $\layer$ and $\painting$. The rationale behind $\framep$, $\layer$ and $\painting$ will be explained later but it should already be noticed that the type $\layer$ relies on an operator of frame restriction $\restrf$ which is defined in \ref{tab:faces}, and this restriction operator is in turn defined using the auxiliary definitions of $\restrl$ and $\restrc$.

Notably, the definition of $\restrl$ relies on an equality expressing the commutation of the composition of $\restrf$. The proof of this commutation is worth being made explicit, which we do in table \ref{tab:coh} using proof-term notations. The proof requires an induction on the dimension, and on the structure of $\framep$, $\layer$, and $\painting$. This is what $\cohf$ does using auxiliary proofs $\cohl$ and $\cohc$. Even though it looks independent of the definitions from the the other tables, $\cohf$ has to be proved mutually with the definitions of $\framep$, $\layer$, $\painting$, and their corresponding restrictions. More precisely, for a fixed $n$, the block of $\framep$, $\restrf$, and $\cohf$ has to be mutually defined by induction on $p$. Also, each of $\painting$, $\restrc$, and $\cohc$ is built by induction from $p$ to $n$. The $\painting$ block at $n$ relies on the $\framep$ block at $n$, but the converse dependency is only on lower $n$, so this is well-founded. Note that $\layer$, $\restrl$ and $\cohl$ are just abbreviations. The exact way this mutual recursion is eventually formalized is explained in section~\ref{sec:wf}.

Note that for a fixed constant $n$, relying on the evaluation rules of type theory, the coherence conditions degenerate to a reflexivity proof, so that the construction builds an effective sequence of types not mentioning coherences anymore.

\renewcommand*{\lab}{tab:coind}
\input{tab-coind.tex}

% For just the second table, keep the universe letter in fullframe
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[#1][#2][][][#3]}

\renewcommand*{\lab}{tab:core}
\input{tab-core.tex}

% Drop the universe letter in fullframe for all remaining tables
\renewcommandx{\fullframe}[3][1,2,3]{\prim{fullframe}[][#2][][][#3]}
\renewcommand*{\lab}{tab:frames}
\input{tab-frames.tex}

% Truncated sets, otherwise referred to as X
% Drop the universe letter for the third and fourth tables
\renewcommandx{\Xto}[3][3]{\X[][<#2][#3]}
\renewcommandx{\Xcomp}[3][3]{\X[][=#2][#3]}
\renewcommandx{\Xfrom}[3][3]{\X[][\geq#2][#3]}

% The third table mentions cohframe; keep ε, ω in this instance
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][#6,#7][#8][#9]}

\renewcommand*{\lab}{tab:faces}
\input{tab-faces-ett.tex}

% Restriction for frame, layer, and painting
% Drop just the universe letter for the coh table
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}

% Frame, layer, and painting
% Drop all arguments for coh table; they're not present in coind table.
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][][][][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][][][][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[][][][][#5]}

% Hack to remove , in \cohf
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][][][][][#9]}

% Coherence conditions for frame, layer, and painting
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[][#2][#3][#4][#5][#6][#7,#8][#9]}

\renewcommand*{\lab}{tab:coh}
\input{tab-coh-ett.tex}

\subsection{Intuition for our formal construction\label{sec:intuition}}
\renewcommandx{\fullframe}[1][1]{\prim{fullframe}[][#1][][][]}
\renewcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\renewcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\renewcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\renewcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrc}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\renewcommandx{\cohf}[1][1]{\coh{frame}[][][][][][#1][][]}
\renewcommandx{\cohl}[1][1]{\coh{layer}[][][][][][#1][][]}
\renewcommandx{\cohc}[1][1]{\coh{painting}[][][][][][#1][][]}
\renewcommandx{\coht}{\cohtwo{frame}[][][][][][][][]}

To assign types to $X_0, X_1, X_2, \ldots$ in the above indexed representation, we give a recursive definition relying on the building blocks which we call $\framep$, $\layer$, and $\painting$. A $\framep$ is a boundary of a standard form (simplex, cube, etc.), which we decompose into $\layer$, and a $\painting$ corresponds to a filled $\framep$. Some $\framep$ are full and we call them $\fullframe$: they represent matching objects.

To every $X_n$ is uniformly assigned a type of the form $\fullframe[n] \rightarrow \U$. Compared to the informal description given in section~\ref{sec:rel-param}, e.g. $X_1 : X_0 \rightarrow X_0 \rightarrow \U$, this amounts to apply the isomorphisms between $A \rightarrow B \rightarrow C$ and $A \times B \rightarrow C$, or between $\Pi a: A.\, (B a \rightarrow C)$ and $(\Sigma a: A.\, B a) \rightarrow C$ so as to get the expected form $\fullframe[n] \rightarrow \U$.. In particular, $\fullframe[n]$ is a ``telescope'', i.e. a nesting of $\Sigma$-types.

Let us now illustrate how we recursively build $\fullframe[n]$. To begin, let us set $\fullframe[0] = \unittype$, so that the type $\U$ given to $X_0$ in section~\ref{sec:rel-param} can be equivalently formulated as $\unittype \rightarrow \U$. Then, more generally, we let each $\fullframe[n]$ consist of $n$ layers, written $\layer[n][p]$ with $p < n$, that we stack in order, starting from the $\unittype$ type and writing $\framep[n][p]$ for the $p$ first layers of a $\fullframe[n]$, so that $\fullframe[n]$ is $\framep[n][n]$. For instance, $X_1$ is made of one layer, so that it can be written as a $\Sigma$-type of an inhabitant of the $\unittype$ and $\layer[1][0]$, as shown below. The figure also mentions how the type of $X_2$ is structured.

\begin{figure}[H]
  \centering
  \begin{equation*}
    \begin{array}{ll}
      X_0                                : \underbrace{\unittype}_{\framep[0][0]}                                                    \rightarrow \U \\
      X_1                                : \underbrace{\Sigma \unitpoint: \unittype. \underbrace{\left(
      \begin{array}{c}
          \underbrace{X_0(\unitpoint)}_{\painting[0][0]}
          \\ \times \\
          \underbrace{X_0(\unitpoint)}_{\painting[0][0]}
        \end{array}\right)}_{\layer[1][0]}}_{\framep[1][1]} \rightarrow \U                                                                            \\
      X_2                                : \underbrace{\Sigma a: \underbrace{\left(\Sigma \unitpoint: \unittype. \underbrace{\left(
          \begin{array}{c}
            \underbrace{\Sigma b: \left(
            \hspace{-0.4em}\begin{array}{c}
                             X_0(\unitpoint)
                             \\ \times \\
                             X_0(\unitpoint)
                           \end{array}\hspace{-0.4em}
            \right).\, \underbrace{X_1 \underbrace{(\unitpoint, b)}_{\restrf[2][0][L]}}_{\painting[1][1]}}_{\painting[1][0]}
            \\ \times \\
            \underbrace{\Sigma b: \left(
            \hspace{-0.4em}\begin{array}{c}
                             X_0(\unitpoint)
                             \\ \times \\
                             X_0(\unitpoint)
                           \end{array}\hspace{-0.4em}
            \right).\, \underbrace{X_1 \underbrace{(\unitpoint, b)}_{\restrf[2][0][R]}}_{\painting[1][1]}}_{\painting[1][0]}
          \end{array}
          \right)}_{\layer[2][0]}\right)}_{\framep[2][1]}.\underbrace{\left(
        \begin{array}{c}
          \underbrace{X_1 \underbrace{\left(a.\hd, \left(
              \hspace{-0.4em}\begin{array}{c}
                               a.\tl.L.\hd.L, \\
                               a.\tl.R.\hd.L
                             \end{array}\hspace{-0.4em}
              \right)\right)}_{\restrf[2][1][L]}}_{\painting[1][1]}
          \\ \times \\
          \underbrace{X_1 \underbrace{\left(a.\hd, \left(
              \hspace{-0.4em}\begin{array}{c}
                               a.\tl.L.\hd.R, \\
                               a.\tl.R.\hd.R
                             \end{array}\hspace{-0.4em}
              \right)\right)}_{\restrf[2][1][R]}}_{\painting[1][1]}
        \end{array}
        \right)}_{\layer[2][1]}}_{\framep[2][2]}
      \rightarrow \U                                                                                                                                \\
      \ldots
    \end{array}
  \end{equation*}
\end{figure}

Let us now illustrate the construction of $\fullframe[3]$, necessary to build the type of $X_3$.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=2]
    \draw[spanish-blue, fill=spanish-blue] (0, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- (0, 0);
    \draw[spanish-blue, fill=spanish-blue, nearly transparent] (0.6, 1) -- (0.6, 1.6) -- (1.6, 1.6) -- (1.6, 0.6) -- (1, 0.6);
  \end{tikzpicture}
  \;\;
  \begin{tikzpicture}[scale=2]
    \draw[spanish-blue, fill=spanish-blue] (0, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- (0, 0);
    \draw[spanish-blue, fill=spanish-blue, nearly transparent] (0.6, 1) -- (0.6, 1.6) -- (1.6, 1.6) -- (1.6, 0.6) -- (1.0, 0.6);
    \draw[raspeberry, pattern=dots] (1.1, 1.1) -- (1.5, 1.5) -- (1.5, 0.5) -- (1.1, 0.1) -- (1.1, 1.1);
    \draw[raspeberry] (1.3, 1.3) -- (1.3, 0.3);
    \draw[raspeberry, pattern=dots] (0.1, 1.1) -- (0.5, 1.5) -- (0.5, 1.1);
    \draw[raspeberry] (0.3, 1.3) -- (0.3, 1.1);
  \end{tikzpicture}
  \;\;
  \begin{tikzpicture}[scale=2]
    \draw[spanish-blue, fill=spanish-blue] (0, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- (0, 0);
    \draw[spanish-blue, fill=spanish-blue, nearly transparent] (0.6, 1) -- (0.6, 1.6) -- (1.6, 1.6) -- (1.6, 0.6) -- (1.0, 0.6);
    \draw[raspeberry, pattern=dots] (1.1, 1.1) -- (1.5, 1.5) -- (1.5, 0.5) -- (1.1, 0.1) -- (1.1, 1.1);
    \draw[raspeberry] (1.3, 1.3) -- (1.3, 0.3);
    \draw[raspeberry] (0.1, 1.1) -- (0.5, 1.5);
    \draw[russian-green, pattern=dots] (0.2, 1.1) -- (1.0, 1.1) -- (1.4, 1.5) -- (0.6, 1.5) -- (0.2, 1.1);
    \filldraw[russian-green] (0.8, 1.3) circle (0.6pt);
  \end{tikzpicture}
\end{figure}

The figure on the left is $\framep[3][1]$, in the middle is $\framep[3][2]$, and on the right is $\framep[3][3]$, which is full. Further, $\framep[3][1]$ is made of one layer, $\layer[3][0]$, shown in blue, $\framep[3][2]$ is made of one additional layer, $\layer[3][1]$, shown in red, $\framep[3][3]$ is made of one more layer, $\layer[3][2]$, shown in green.

We illustrated here the cubical case, that is $\nu = 2$, but, in general, a $\layer[n][p]$ is a product of $\nu$ $\painting[n - 1][p]$. A $\painting[n][0]$ is a $n$-dimensional object corresponding to a filled $\fullframe[n]$. More generally, a $\painting[n][p]$ is an $n$-dimensional object which has the form of a $\painting[n-p][0]$, thus of $(n-p)$-dimensional form, but shifted and living in dimensions $p$ to $n$. Such $\painting[n][p]$ fills a space framed by a partial $\framep[n][p]$ so that, together, they form a filled $\fullframe[n]$. For instance, in the picture, each of the two $\painting[2][0]$ of $\layer[3][0]$ is a filled blue square, each of the two $\painting[2][1]$ of $\layer[3][1]$ is the line shown in red, stretched into a partial square filling the partial frames made of respectively the left and right border of the blue square, and each of the two $\painting[2][2]$ of $\layer[3][2]$ is a point shown in green, stretched into a partial square filling the full frames made respectively of the upper and lower borders of the blue and red squares. A $\painting[n][p]$ complements a $\framep[n][p]$ by adding layers needed to form a $\fullframe[n]$ and by filling the resulting $\fullframe[n]$ with an inhabitant of $X_n$. Layers are added from dimension $n$ to dimension $p$ that is opposite to the order from $0$ to $p$ the $\framep[n][p]$ are built, as shown below.
\begin{equation*}
  \begin{array}{lll}
    \framep[n][p]   & \defeq & \Sigma a_n: (\ldots (\Sigma \unitpoint: \unittype .\, \layer[n][0]) \ldots) .\, \layer[n][p - 1] \\
    \painting[n][p] & \defeq & \Sigma l_p: \layer[n][p]. (\ldots (\Sigma l_n: \layer[n][n - 1] .\, X_n) \ldots)
  \end{array}
\end{equation*}

So far, we have not paid attention to the fact that we have a dependent type, shown as a $\Sigma$-type. Let us be more precise about this requirement. First, $\fullframe[n]$ depends on all $X_i$ up to $n - 1$. So, we need to package up $X_i$, for $i < n$, into a nesting of $\Sigma$-types, constituting the type of a $n$-truncated $\nu$-set, which we wrote $\X[][<n][]$. This allows us to give the type $\X[][<n][] \rightarrow \U$ to $\fullframe[n]$. Then, for $D: \X[][<n][]$, representing an initial prefix of $X_0, X_1, \ldots X_{n - 1}$, the indexed set $X_n$ has type $\fullframe[n](D) \rightarrow \U$. Thus, $\framep[n][p]$, $\layer[n][p]$ and $\painting[n][p]$ also depend on $D$. We can then reformulate the previous equation with its dependency on $D$. In particular, $X_n$ is just the last component of $D$, that is $D.\tl$.
\begin{equation*}
  \begin{array}{lll}
    \framep[n][p](D)   & \defeq & \Sigma a_n: (\ldots (\Sigma \unitpoint: \unittype.\, \layer[n][0](D)) \ldots) .\,\layer[n][p - 1](D) \\
    \painting[n][p](D) & \defeq & \Sigma l_p: \layer[n][p](D).\, (\ldots (\Sigma l_n: \layer[n][n - 1](D) .\, D.\tl) \ldots)
  \end{array}
\end{equation*}

An extra refinement arises from the fact that each new layer of a frame has to be glued onto the border of the partial frame built so far. So, each $\layer[n][p]$ has to depend on $\framep[n][p]$. We also need a way to characterize the $\nu$ borders of each $\painting[n-1][p]$ that composes a $\layer[n][p]$, and this is where the restriction $\restrf[n][p][\epsilon][p]$ arrives, for each $\epsilon < \nu$. For instance, on the picture, the left and right $\painting[2][1]$, shown in red, are laid on respectively the left and right borders of the blue boxes, and hence needs to depend on $\framep[3][1]$. The left and right borders of the two blue boxes are extracted as $\restrf[2][1][L](D)(d)$ and $\restrf[2][1][R](D)(d)$. We can then refine again the previous equation by showing the dependencies on $d$, as shown below.

\begin{equation*}
  \begin{array}{llr}
    \framep[n][p](D)      & \defeq & \Sigma d: (\ldots (\Sigma \unitpoint: \unittype.\, \layer[n][0](D)(\unitpoint)) \ldots).\, \layer[n][p](D)(d) \\
    \painting[n][p](D)(d) & \defeq & \Sigma l_p: \layer[n][p](D)(d).\, (\ldots (\Sigma l_n: \layer[n][n - 1](D)(d, l_p, \ldots, l_{n - 1}).        \\
                          &        & D.\tl(d, l_p, \ldots, l_n)) \ldots)                                                                           \\
                          &        & \text{where } (d, l_p, \ldots, l_q) \text{ abbreviates } ((\ldots(d, l_p), \ldots), l_q)
  \end{array}
\end{equation*}

When $\nu = 2$, the formation of layers from paintings amounts to:
\begin{equation*}
  \begin{array}{llc}
    \layer[n][p](D)(d) & \defeq & \painting[n-1][p](D.\hd)(\restrf[n][p][L][p](d)) \\
                       &        & \times                                           \\
                       &        & \painting[n-1][p](D.\hd)(\restrf[n][p][R][p](d))
  \end{array}
\end{equation*}

The operation $\restrf[n][p][\epsilon][q]$ restricts the $p$ first layers of a frame, and the construction is by recursion on the structure of a frame $d$. This necessitates the definitions $\restrl[n][p][\epsilon][q](d)(l)$ and $\restrc[n][p][\epsilon][q](d)(c)$, for $l$ a $\layer$ and $c$ a $\painting$. The key case is $\restrc[n][p][\epsilon][p](d)(c)$, where $c$, a $\painting[n][p]$, has necessarily the form of $((c_L, c_R), \_)$: $\restrc[n][p][L][p]$ picks out $c_L$, a $\painting[n-1][p]$, $\restrc[n][p][R][p]$ picks out the $c_R$, also a $\painting[n-1][p]$, and $\_$, a $\painting[n][p+1]$, is discarded. There is one last difficulty, which we illustrate by writing down expected and actual types.

Given $c_\omega$ of type
\begin{align*}
  c_\omega & : \painting[n-1][p](D.\hd)(\restrf[n-1][p][\omega][q](d))
\end{align*}
$\restrl[n][p][\epsilon](d)(c_L, c_R)$ produces a layer in which the $\omega$-component has the type
\begin{equation*}
  \painting[n-2][p](D.\hd.\hd)(\restrf[n-1][p][\epsilon][q](\restrf[n][p][\omega][p](d)))
\end{equation*}
while we expect a component of type
\begin{equation*}
  \painting[n-2][p](D.\hd.\hd)(\restrf[n-1][p][\omega][p](\restrf[n][p][\epsilon][q+1](d)))
\end{equation*}

Hence, we need a coherence condition to commute the restrictions. Coherence conditions similar to this necessitate what are shown as, $\cohf$, $\cohl$ and $\cohc$ in table~\ref{tab:coh}. These are by induction on the structure of $\framep$, $\layer$ and $\painting$. Note that, for the construction in intentional type theory, we further need a $2$-dimensional coherence condition, $\coht$, for $\cohl$. This is explained in the next section.

\subsection{From extensional to intentional type theory: explication of the equality proofs\label{sec:itt}}
\renewcommandx{\cohf}{\coh{frame}[][][][][][][][]}

In this section, we intend to get rid of the reflection rule and make explicit what is needed to rephrase the construction from extensional type theory to intentional type theory. For readability purpose, we however make explicit only the key coherence conditions of the construction.
Other form of equality reasoning would have to be made explicit to obtain a construction fully in intentional type theory but these other steps are standard enough to be omitted at this stage. See section~\ref{sec:eqproperties} for the details.

The need for transport along a proof of commutation of $\restrf$ in the definition of $\restrl$ is made explicit in table~\ref{fulltab:faces}, where the arrow over $\cohf$ indicates the direction of rewrite.

% Insert fulltab:faces and fulltab:coh, after overriding macros to make
% everything but the universe letter explicit.
\renewcommandx{\framep}[5][1,2,3,4,5]{\prim{frame}[][#2][#3][#4][#5]}
\renewcommandx{\layer}[5][1,2,3,4,5]{\prim{layer}[][#2][#3][#4][#5]}
\renewcommandx{\painting}[5][1,2,3,4,5]{\prim{painting}[][#2][#3][#4][#5]}
\renewcommandx{\restrf}[7][1,2,3,4,5,6,7]{\restr{frame}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrl}[7][1,2,3,4,5,6,7]{\restr{layer}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\restrc}[7][1,2,3,4,5,6,7]{\restr{painting}[][#2][#3][#4][#5][#6][#7]}
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[][#2][#3][#4][#5][#6][#7,#8][#9]}
\renewcommand*{\lab}{fulltab:faces}
\input{tab-faces.tex}
\renewcommand*{\lab}{fulltab:coh}
\input{tab-coh.tex}

\renewcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\renewcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\renewcommandx{\coht}{\cohtwo{frame}[][][][][][][][]}
The proof of $\cohf$ itself requires making explicit several rewritings which were invisible in extensional type theory. The commutation of $\restrl$ lives in a type referring to $\cohf$, so we need a transport along the commutation of $\restrf$ in the statement of $\cohl$. The proof of $\cohl$ is the most involved proof of the construction. It requires a higher-dimensional coherence condition, $\coht$, whose exact formulation is as follows.
\renewcommandx{\cohf}[9][1,2,3,4,5,6,7,8,9]{\coh{frame}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohl}[9][1,2,3,4,5,6,7,8,9]{\coh{layer}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\cohc}[9][1,2,3,4,5,6,7,8,9]{\coh{painting}[][#2][#3][#4][#5][#6,#7][#8][#9]}
\renewcommandx{\coht}[9][1,2,3,4,5,6,7,8,9]{\cohtwo{frame}[][#2][#3][#4][#5][#6][#7,#8][#9]}
\begin{align*}
  \cohf[m][\omega][\theta][r][p][n][p][][d = {\restrf[m][\epsilon][q+2][n][p][][d = \d]}]\;\bullet     \\
  \ap \restrf[m][\omega][r][n][p][][]\;(\cohf[m][\epsilon][\theta][q+1][p][n][p][][d = \d])\;\bullet   \\
  \cohf[m][\epsilon][\omega][q][r][n][p][][d = {\restrf[m][\theta][p][n][p][][d = \d]}] =              \\
  \ap \restrf[m][\theta][p][n][p][][]\;(\cohf[m][\epsilon][\omega][q+1][r+1][n][p][][d = \d])\;\bullet \\
  \cohf[m][\epsilon][\theta][q][p][n][p][][d = {\restrf[m][\omega][r+1][n][p][][d = \d]}]\;\bullet     \\
  \ap \restrf[m][\epsilon][q][n][p][]\;(\cohf[m][\omega][\theta][r][p][n][p][][d = \d])
\end{align*}
where $\ap$ applies a function on two sides of an equality, and $\bullet$ is transitivity of equality. This property of equality proofs holds in \U, and since our formalization is done in \U, the term is trivially discharged.

\renewcommandx{\coht}{\cohtwo{frame}[][][][][][][][]}
\renewcommandx{\restrf}{\restr{frame}[][][][][][][]}
\renewcommandx{\cohf}{\coh{frame}[][][][][][][][]}
\renewcommandx{\cohl}{\coh{layer}[][][][][][][][]}
\renewcommandx{\cohc}{\coh{painting}[][][][][][][][]}

Notice that each $\restrl$ in the type of $\cohl$ is hiding a $\cohf$ rewrite: this makes a sum total of three $\cohf$ rewrites on the left-hand side, and two $\cohf$ rewrites on the right-hand side. In the proof term of $\cohl$, $\cohc$ has one $\cohf$ rewrite on its left-hand side and zero on the right-hand side. This, combined with the two terms of the form $\ap \cohf$, matches our expectation of three $\cohf$ on the left-hand side and two $\cohf$ on the right-hand side. Then, $\coht$ can roughly be seen as a commutation of these $\cohf$ terms.

Finally, let us explain $\cohc$. The base case $p = r$ is the key case of the commutation of $\restrf$, when one of the $\restrc$ collapses, and the remaining equation holds trivially. The case of $p < r$ follows the structure of $\restrc$ by induction.

If we were not working in \U, but in $\HGpd$ we would need to prove one more higher-dimensional coherence, and if we were working in \Type, we would need to prove arbitrarily many higher-dimensional coherences. Here, $\HGpd$ is the subset of types $A$ such that for all $x$ and $y$ in $A$, $x = y$ is in \U. See \cite{herbelin15,altenkirch16,kraus21} for a discussion on the need for recursive higher-dimensional coherence conditions in formulating higher-dimensional structures in type theory.

\subsection{Well-foundedness of the construction\label{sec:wf}}
\renewcommandx{\framep}[2][1,2]{\prim{frame}[][#1][#2][][]}
\renewcommandx{\layer}[2][1,2]{\prim{layer}[][#1][#2][][]}
\renewcommandx{\painting}[2][1,2]{\prim{painting}[][#1][#2][][]}
\renewcommandx{\restrf}[4][1,2,3,4]{\restr{frame}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrl}[4][1,2,3,4]{\restr{layer}[][#3][#4][#1][#2][][]}
\renewcommandx{\restrc}[4][1,2,3,4]{\restr{painting}[][#3][#4][#1][#2][][]}
\renewcommandx{\cohf}[1][1]{\coh{frame}[][][][][][#1][][]}
\renewcommandx{\cohl}[1][1]{\coh{layer}[][][][][][#1][][]}
\renewcommandx{\cohc}[1][1]{\coh{painting}[][][][][][#1][][]}

Since the construction shown in the previous sections is by induction on $n$, and dependencies are on lower $n$ and $p < n$, one would imagine formalizing this using well-founded induction in dependent type theory. We initially tried this approach: we had terms dependent on the proofs of the case distinction of $n' \leq n$ implies $n' < n$ or $n' = n$, and these proofs did not have definitional computational rule; it started to be necessary to reason propositionally on the computational property of the case distinction, and it eventually turned out to be unmanageable. Hence, we chose a different route: in practice, since $\restrf[n]$ depends on $\framep[n]$ and $\framep[n-1]$, while $\cohf[n]$ depends on $\framep[n]$, $\framep[n-1]$, and $\framep[n-2]$, we only need to keep track of three ``levels'', and we built separate data structures for the levels, with dependencies. More concretely, we build the ten definitions shown in the tables by induction, and this is part of the definition of a larger record. The other fields of the record are $\framep$, $\layer$, $\painting$ at levels $n - 1$ and $n - 2$, $\restrf$, $\restrl$, and $\restrc$ at level $n - 1$, and equations to recall the definitions of these objects at lower levels.

\subsection{Dependencies in inequality proofs\label{sec:le}}
The entire construction relies on inequalities over natural numbers, and we use two different definitions of $\leq$ addressing different concerns in our formalization. In order to build our first variant, we present an intermediate ``recursive definition'', phrased as:

\begin{figure}[H]
  \begin{minted}{coq}
  Fixpoint leR (n m : nat) : SProp :=
  match n, m with
  | O, _ => STrue
  | S n, O => SFalse
  | S n, S m => leR n m
  end.
  \end{minted}
\end{figure}

Here $\SProp$ is a definitionally proof-irrelevant impredicative universe at the bottom of the universe hierarchy~\citep{gilbert19}. By placing the definition in \SProp, we have definitional equality of all inequality proofs. For the purpose of unification, however, this definition does not go far enough. Consider the unification problems:

\begin{figure}[H]
  \begin{minted}{coq}
  leR_trans ?p leR_refl = ?p
  leR_trans leR_refl ?p = ?p
  \end{minted}
\end{figure}
where \texttt{leR\_trans} is transitivity, \texttt{leR\_refl} is reflexivity, and \texttt{?p} is an existential variable. These two problems definitionally hold in \SProp, but equalizing them does not solve the existential. For unification to be useful in inferring existentials, we present our first variant of $\leq$, which we dub as the ``Yoneda variant'':

\begin{figure}[H]
  \begin{minted}{coq}
  Definition leY n m :=
    forall p, leR p n -> leR p m.
  \end{minted}
\end{figure}

This definition is an improvement over \texttt{leR} since reflexivity is now definitionally the neutral element of transitivity, and associativity of transitivity also holds definitionally. Although it significantly eases our proof, there are some instances where unification is unable to solve the existentials, and we have to provide them explicitly.

The second variant of $\leq$, the ``inductive variant'', is phrased as:

\begin{figure}[H]
  \begin{minted}{coq}
  Inductive leI : nat -> nat -> Type :=
  | leI_refl n : n <~ n
  | leI_down {n p} : p.+1 <~ n -> p <~ n
  where "n <~ m" := (leI n m) : nat_scope.
  \end{minted}
\end{figure}

Compared to \texttt{leY}, \texttt{leI} has no proof-irrelevance properties. This definition is specially crafted for $\painting$, where we have to reason inductively from $p \leq n$ to $n$. In our usage, we have lemmas \texttt{leY\_of\_leI} and \texttt{leI\_of\_leY} in order to equip \texttt{leY} with the induction scheme of \texttt{leI}. The resulting induction scheme has computational rules holding propositionally.

\subsection{Groupoid properties of equality and basic type isomorphisms\label{sec:eqproperties}}
The construction takes benefit of various provable equalities over proofs of equality being definitional by the reflection rule. This includes in particular the groupoid properties of equality. Notably, uniqueness of identity proofs holds in extensional type theory, so that any type is automatically an $\U$. Also, we left implicit in table~\ref{tab:coh} the use of the isomorphism between $u = v$ and $\Sigma (p:u.\hd = v.\hd). (u.\tl = v.\tl)$ for $u$ and $v$ in a $\Sigma$-type. In the same table, we also left implicit the use of the isomorphism between $f = g$ and $\Pi a: A.\, f(a) = g(a)$ for $f$ and $g$ in $\Pi a: A.\, B$, where it should be recalled that the right-to-left map, that is functional extensionality, holds by default in extensional type theory. As a final remark, note, as a consequence of $\eta$-conversion for finite enumerated types, that the requirement of functional extensionality disappears when $\nu$ is finite. However, this is a conversion which Coq does not implement, so, in Coq, the alternative would be to replace $\Pi a: \nu.\, B$ by a ``flat'' iterated product $B(1) \times B(2) \times \ldots \times B(\nu)$.

\section{Future work}
In the cubical case, we expect the construction to eventually provide a model of (some version of) parametric type theory~\citep{nuyts17,cavallo19} by adding degeneracies, a hierarchy of universes (as sketched e.g. in a talk by Herbelin at the HoTT-UF workshop for the bridge case~(\citeyear{herbelin-hott-uf})), as well as reasoning modulo permutations~\citep{grandis03}.

By equipping the universe construction with a structure of equivalences, as suggested along the lines of Altenkirch and Kaposi~(\citeyear{altenkirch15}), we expect the construction to be able to serve as a basis for syntactic models of various versions of cubical type theory~\citep{bezem13,cohen16,angiuli21}, saving the detour via the fibered approach inherent to usual presheaf models. This would a priori preserve definitional properties which may be lost when detouring via presheaves. In particular, we conjecture being able to justify univalence holding definitionally. Our approach would also definitively ground cubical type theory in iterated parametricity.

Another direction for future work would also be to generically construct the indexed form of any presentation of presheaves over a direct category and to show the equivalence between the two presentations.

\bibliographystyle{msclike}
\bibliography{paper}

\end{document}
